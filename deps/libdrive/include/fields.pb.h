// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fields.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fields_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fields_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fields_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fields_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_fields_2eproto;
namespace vts {
namespace protocol {
namespace main {
class AOIInfo;
class AOIInfoDefaultTypeInternal;
extern AOIInfoDefaultTypeInternal _AOIInfo_default_instance_;
class ArchiveInfo;
class ArchiveInfoDefaultTypeInternal;
extern ArchiveInfoDefaultTypeInternal _ArchiveInfo_default_instance_;
class ColliderBox;
class ColliderBoxDefaultTypeInternal;
extern ColliderBoxDefaultTypeInternal _ColliderBox_default_instance_;
class CompoundRole;
class CompoundRoleDefaultTypeInternal;
extern CompoundRoleDefaultTypeInternal _CompoundRole_default_instance_;
class QuaternionF;
class QuaternionFDefaultTypeInternal;
extern QuaternionFDefaultTypeInternal _QuaternionF_default_instance_;
class RLSL;
class RLSLDefaultTypeInternal;
extern RLSLDefaultTypeInternal _RLSL_default_instance_;
class RoleContainerInfo;
class RoleContainerInfoDefaultTypeInternal;
extern RoleContainerInfoDefaultTypeInternal _RoleContainerInfo_default_instance_;
class SimHeader;
class SimHeaderDefaultTypeInternal;
extern SimHeaderDefaultTypeInternal _SimHeader_default_instance_;
class SingleRole;
class SingleRoleDefaultTypeInternal;
extern SingleRoleDefaultTypeInternal _SingleRole_default_instance_;
class Vector3d;
class Vector3dDefaultTypeInternal;
extern Vector3dDefaultTypeInternal _Vector3d_default_instance_;
class Vector3f;
class Vector3fDefaultTypeInternal;
extern Vector3fDefaultTypeInternal _Vector3f_default_instance_;
}  // namespace main
}  // namespace protocol
}  // namespace vts
PROTOBUF_NAMESPACE_OPEN
template<> ::vts::protocol::main::AOIInfo* Arena::CreateMaybeMessage<::vts::protocol::main::AOIInfo>(Arena*);
template<> ::vts::protocol::main::ArchiveInfo* Arena::CreateMaybeMessage<::vts::protocol::main::ArchiveInfo>(Arena*);
template<> ::vts::protocol::main::ColliderBox* Arena::CreateMaybeMessage<::vts::protocol::main::ColliderBox>(Arena*);
template<> ::vts::protocol::main::CompoundRole* Arena::CreateMaybeMessage<::vts::protocol::main::CompoundRole>(Arena*);
template<> ::vts::protocol::main::QuaternionF* Arena::CreateMaybeMessage<::vts::protocol::main::QuaternionF>(Arena*);
template<> ::vts::protocol::main::RLSL* Arena::CreateMaybeMessage<::vts::protocol::main::RLSL>(Arena*);
template<> ::vts::protocol::main::RoleContainerInfo* Arena::CreateMaybeMessage<::vts::protocol::main::RoleContainerInfo>(Arena*);
template<> ::vts::protocol::main::SimHeader* Arena::CreateMaybeMessage<::vts::protocol::main::SimHeader>(Arena*);
template<> ::vts::protocol::main::SingleRole* Arena::CreateMaybeMessage<::vts::protocol::main::SingleRole>(Arena*);
template<> ::vts::protocol::main::Vector3d* Arena::CreateMaybeMessage<::vts::protocol::main::Vector3d>(Arena*);
template<> ::vts::protocol::main::Vector3f* Arena::CreateMaybeMessage<::vts::protocol::main::Vector3f>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vts {
namespace protocol {
namespace main {

// ===================================================================

class SimHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.SimHeader) */ {
 public:
  SimHeader();
  virtual ~SimHeader();

  SimHeader(const SimHeader& from);
  SimHeader(SimHeader&& from) noexcept
    : SimHeader() {
    *this = ::std::move(from);
  }

  inline SimHeader& operator=(const SimHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimHeader& operator=(SimHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimHeader* internal_default_instance() {
    return reinterpret_cast<const SimHeader*>(
               &_SimHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SimHeader& a, SimHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(SimHeader* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimHeader* New() const final {
    return CreateMaybeMessage<SimHeader>(nullptr);
  }

  SimHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimHeader& from);
  void MergeFrom(const SimHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.SimHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendTsFieldNumber = 1,
    kSimTsFieldNumber = 2,
    kSeqNoFieldNumber = 3,
  };
  // int64 send_ts = 1;
  void clear_send_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 send_ts() const;
  void set_send_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_send_ts() const;
  void _internal_set_send_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 sim_ts = 2;
  void clear_sim_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 sim_ts() const;
  void set_sim_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sim_ts() const;
  void _internal_set_sim_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 seq_no = 3;
  void clear_seq_no();
  ::PROTOBUF_NAMESPACE_ID::int64 seq_no() const;
  void set_seq_no(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seq_no() const;
  void _internal_set_seq_no(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.SimHeader)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 send_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 sim_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 seq_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class AOIInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.AOIInfo) */ {
 public:
  AOIInfo();
  virtual ~AOIInfo();

  AOIInfo(const AOIInfo& from);
  AOIInfo(AOIInfo&& from) noexcept
    : AOIInfo() {
    *this = ::std::move(from);
  }

  inline AOIInfo& operator=(const AOIInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AOIInfo& operator=(AOIInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AOIInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AOIInfo* internal_default_instance() {
    return reinterpret_cast<const AOIInfo*>(
               &_AOIInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AOIInfo& a, AOIInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AOIInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AOIInfo* New() const final {
    return CreateMaybeMessage<AOIInfo>(nullptr);
  }

  AOIInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AOIInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AOIInfo& from);
  void MergeFrom(const AOIInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AOIInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.AOIInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kAoiRadiusFieldNumber = 2,
  };
  // string role_id = 1;
  void clear_role_id();
  const std::string& role_id() const;
  void set_role_id(const std::string& value);
  void set_role_id(std::string&& value);
  void set_role_id(const char* value);
  void set_role_id(const char* value, size_t size);
  std::string* mutable_role_id();
  std::string* release_role_id();
  void set_allocated_role_id(std::string* role_id);
  private:
  const std::string& _internal_role_id() const;
  void _internal_set_role_id(const std::string& value);
  std::string* _internal_mutable_role_id();
  public:

  // float aoi_radius = 2;
  void clear_aoi_radius();
  float aoi_radius() const;
  void set_aoi_radius(float value);
  private:
  float _internal_aoi_radius() const;
  void _internal_set_aoi_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.AOIInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_id_;
  float aoi_radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class Vector3d :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.Vector3d) */ {
 public:
  Vector3d();
  virtual ~Vector3d();

  Vector3d(const Vector3d& from);
  Vector3d(Vector3d&& from) noexcept
    : Vector3d() {
    *this = ::std::move(from);
  }

  inline Vector3d& operator=(const Vector3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3d& operator=(Vector3d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector3d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3d* internal_default_instance() {
    return reinterpret_cast<const Vector3d*>(
               &_Vector3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vector3d& a, Vector3d& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3d* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3d* New() const final {
    return CreateMaybeMessage<Vector3d>(nullptr);
  }

  Vector3d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3d>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector3d& from);
  void MergeFrom(const Vector3d& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3d* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.Vector3d";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.Vector3d)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class RLSL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.RLSL) */ {
 public:
  RLSL();
  virtual ~RLSL();

  RLSL(const RLSL& from);
  RLSL(RLSL&& from) noexcept
    : RLSL() {
    *this = ::std::move(from);
  }

  inline RLSL& operator=(const RLSL& from) {
    CopyFrom(from);
    return *this;
  }
  inline RLSL& operator=(RLSL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RLSL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RLSL* internal_default_instance() {
    return reinterpret_cast<const RLSL*>(
               &_RLSL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RLSL& a, RLSL& b) {
    a.Swap(&b);
  }
  inline void Swap(RLSL* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RLSL* New() const final {
    return CreateMaybeMessage<RLSL>(nullptr);
  }

  RLSL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RLSL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RLSL& from);
  void MergeFrom(const RLSL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RLSL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.RLSL";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadIdFieldNumber = 1,
    kSFieldNumber = 3,
    kLFieldNumber = 4,
    kZFieldNumber = 5,
    kLaneIdFieldNumber = 2,
  };
  // string road_id = 1;
  void clear_road_id();
  const std::string& road_id() const;
  void set_road_id(const std::string& value);
  void set_road_id(std::string&& value);
  void set_road_id(const char* value);
  void set_road_id(const char* value, size_t size);
  std::string* mutable_road_id();
  std::string* release_road_id();
  void set_allocated_road_id(std::string* road_id);
  private:
  const std::string& _internal_road_id() const;
  void _internal_set_road_id(const std::string& value);
  std::string* _internal_mutable_road_id();
  public:

  // double s = 3;
  void clear_s();
  double s() const;
  void set_s(double value);
  private:
  double _internal_s() const;
  void _internal_set_s(double value);
  public:

  // double l = 4;
  void clear_l();
  double l() const;
  void set_l(double value);
  private:
  double _internal_l() const;
  void _internal_set_l(double value);
  public:

  // double z = 5;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // int32 lane_id = 2;
  void clear_lane_id();
  ::PROTOBUF_NAMESPACE_ID::int32 lane_id() const;
  void set_lane_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lane_id() const;
  void _internal_set_lane_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.RLSL)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr road_id_;
  double s_;
  double l_;
  double z_;
  ::PROTOBUF_NAMESPACE_ID::int32 lane_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class QuaternionF :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.QuaternionF) */ {
 public:
  QuaternionF();
  virtual ~QuaternionF();

  QuaternionF(const QuaternionF& from);
  QuaternionF(QuaternionF&& from) noexcept
    : QuaternionF() {
    *this = ::std::move(from);
  }

  inline QuaternionF& operator=(const QuaternionF& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuaternionF& operator=(QuaternionF&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QuaternionF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuaternionF* internal_default_instance() {
    return reinterpret_cast<const QuaternionF*>(
               &_QuaternionF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QuaternionF& a, QuaternionF& b) {
    a.Swap(&b);
  }
  inline void Swap(QuaternionF* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QuaternionF* New() const final {
    return CreateMaybeMessage<QuaternionF>(nullptr);
  }

  QuaternionF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QuaternionF>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QuaternionF& from);
  void MergeFrom(const QuaternionF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuaternionF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.QuaternionF";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float w = 4;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.QuaternionF)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  float w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class Vector3f :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.Vector3f) */ {
 public:
  Vector3f();
  virtual ~Vector3f();

  Vector3f(const Vector3f& from);
  Vector3f(Vector3f&& from) noexcept
    : Vector3f() {
    *this = ::std::move(from);
  }

  inline Vector3f& operator=(const Vector3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3f& operator=(Vector3f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector3f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3f* internal_default_instance() {
    return reinterpret_cast<const Vector3f*>(
               &_Vector3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Vector3f& a, Vector3f& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3f* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3f* New() const final {
    return CreateMaybeMessage<Vector3f>(nullptr);
  }

  Vector3f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3f>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector3f& from);
  void MergeFrom(const Vector3f& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3f* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.Vector3f";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.Vector3f)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class ColliderBox :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.ColliderBox) */ {
 public:
  ColliderBox();
  virtual ~ColliderBox();

  ColliderBox(const ColliderBox& from);
  ColliderBox(ColliderBox&& from) noexcept
    : ColliderBox() {
    *this = ::std::move(from);
  }

  inline ColliderBox& operator=(const ColliderBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColliderBox& operator=(ColliderBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColliderBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColliderBox* internal_default_instance() {
    return reinterpret_cast<const ColliderBox*>(
               &_ColliderBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ColliderBox& a, ColliderBox& b) {
    a.Swap(&b);
  }
  inline void Swap(ColliderBox* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColliderBox* New() const final {
    return CreateMaybeMessage<ColliderBox>(nullptr);
  }

  ColliderBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColliderBox>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColliderBox& from);
  void MergeFrom(const ColliderBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColliderBox* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.ColliderBox";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBottomCenterFieldNumber = 1,
    kSizeFieldNumber = 2,
    kRotationFieldNumber = 3,
  };
  // .vts.protocol.main.Vector3d bottom_center = 1;
  bool has_bottom_center() const;
  private:
  bool _internal_has_bottom_center() const;
  public:
  void clear_bottom_center();
  const ::vts::protocol::main::Vector3d& bottom_center() const;
  ::vts::protocol::main::Vector3d* release_bottom_center();
  ::vts::protocol::main::Vector3d* mutable_bottom_center();
  void set_allocated_bottom_center(::vts::protocol::main::Vector3d* bottom_center);
  private:
  const ::vts::protocol::main::Vector3d& _internal_bottom_center() const;
  ::vts::protocol::main::Vector3d* _internal_mutable_bottom_center();
  public:

  // .vts.protocol.main.Vector3f size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::vts::protocol::main::Vector3f& size() const;
  ::vts::protocol::main::Vector3f* release_size();
  ::vts::protocol::main::Vector3f* mutable_size();
  void set_allocated_size(::vts::protocol::main::Vector3f* size);
  private:
  const ::vts::protocol::main::Vector3f& _internal_size() const;
  ::vts::protocol::main::Vector3f* _internal_mutable_size();
  public:

  // .vts.protocol.main.QuaternionF rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::vts::protocol::main::QuaternionF& rotation() const;
  ::vts::protocol::main::QuaternionF* release_rotation();
  ::vts::protocol::main::QuaternionF* mutable_rotation();
  void set_allocated_rotation(::vts::protocol::main::QuaternionF* rotation);
  private:
  const ::vts::protocol::main::QuaternionF& _internal_rotation() const;
  ::vts::protocol::main::QuaternionF* _internal_mutable_rotation();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.ColliderBox)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::vts::protocol::main::Vector3d* bottom_center_;
  ::vts::protocol::main::Vector3f* size_;
  ::vts::protocol::main::QuaternionF* rotation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class SingleRole :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.SingleRole) */ {
 public:
  SingleRole();
  virtual ~SingleRole();

  SingleRole(const SingleRole& from);
  SingleRole(SingleRole&& from) noexcept
    : SingleRole() {
    *this = ::std::move(from);
  }

  inline SingleRole& operator=(const SingleRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleRole& operator=(SingleRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SingleRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SingleRole* internal_default_instance() {
    return reinterpret_cast<const SingleRole*>(
               &_SingleRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SingleRole& a, SingleRole& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleRole* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleRole* New() const final {
    return CreateMaybeMessage<SingleRole>(nullptr);
  }

  SingleRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SingleRole& from);
  void MergeFrom(const SingleRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.SingleRole";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFStatusFieldNumber = 11,
    kSStatusFieldNumber = 12,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSubtypeFieldNumber = 4,
    kBoxFieldNumber = 5,
    kRlslFieldNumber = 6,
    kLinearSpeedFieldNumber = 7,
    kAngularSpeedFieldNumber = 8,
    kLinearAccelerationFieldNumber = 9,
    kAngularAccelerationFieldNumber = 10,
    kReportTsFieldNumber = 13,
    kTypeFieldNumber = 3,
  };
  // repeated float f_status = 11;
  int f_status_size() const;
  private:
  int _internal_f_status_size() const;
  public:
  void clear_f_status();
  private:
  float _internal_f_status(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_f_status() const;
  void _internal_add_f_status(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_f_status();
  public:
  float f_status(int index) const;
  void set_f_status(int index, float value);
  void add_f_status(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      f_status() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_f_status();

  // repeated string s_status = 12;
  int s_status_size() const;
  private:
  int _internal_s_status_size() const;
  public:
  void clear_s_status();
  const std::string& s_status(int index) const;
  std::string* mutable_s_status(int index);
  void set_s_status(int index, const std::string& value);
  void set_s_status(int index, std::string&& value);
  void set_s_status(int index, const char* value);
  void set_s_status(int index, const char* value, size_t size);
  std::string* add_s_status();
  void add_s_status(const std::string& value);
  void add_s_status(std::string&& value);
  void add_s_status(const char* value);
  void add_s_status(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& s_status() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_s_status();
  private:
  const std::string& _internal_s_status(int index) const;
  std::string* _internal_add_s_status();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string subtype = 4;
  void clear_subtype();
  const std::string& subtype() const;
  void set_subtype(const std::string& value);
  void set_subtype(std::string&& value);
  void set_subtype(const char* value);
  void set_subtype(const char* value, size_t size);
  std::string* mutable_subtype();
  std::string* release_subtype();
  void set_allocated_subtype(std::string* subtype);
  private:
  const std::string& _internal_subtype() const;
  void _internal_set_subtype(const std::string& value);
  std::string* _internal_mutable_subtype();
  public:

  // .vts.protocol.main.ColliderBox box = 5;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::vts::protocol::main::ColliderBox& box() const;
  ::vts::protocol::main::ColliderBox* release_box();
  ::vts::protocol::main::ColliderBox* mutable_box();
  void set_allocated_box(::vts::protocol::main::ColliderBox* box);
  private:
  const ::vts::protocol::main::ColliderBox& _internal_box() const;
  ::vts::protocol::main::ColliderBox* _internal_mutable_box();
  public:

  // .vts.protocol.main.RLSL rlsl = 6;
  bool has_rlsl() const;
  private:
  bool _internal_has_rlsl() const;
  public:
  void clear_rlsl();
  const ::vts::protocol::main::RLSL& rlsl() const;
  ::vts::protocol::main::RLSL* release_rlsl();
  ::vts::protocol::main::RLSL* mutable_rlsl();
  void set_allocated_rlsl(::vts::protocol::main::RLSL* rlsl);
  private:
  const ::vts::protocol::main::RLSL& _internal_rlsl() const;
  ::vts::protocol::main::RLSL* _internal_mutable_rlsl();
  public:

  // .vts.protocol.main.Vector3f linear_speed = 7;
  bool has_linear_speed() const;
  private:
  bool _internal_has_linear_speed() const;
  public:
  void clear_linear_speed();
  const ::vts::protocol::main::Vector3f& linear_speed() const;
  ::vts::protocol::main::Vector3f* release_linear_speed();
  ::vts::protocol::main::Vector3f* mutable_linear_speed();
  void set_allocated_linear_speed(::vts::protocol::main::Vector3f* linear_speed);
  private:
  const ::vts::protocol::main::Vector3f& _internal_linear_speed() const;
  ::vts::protocol::main::Vector3f* _internal_mutable_linear_speed();
  public:

  // .vts.protocol.main.Vector3f angular_speed = 8;
  bool has_angular_speed() const;
  private:
  bool _internal_has_angular_speed() const;
  public:
  void clear_angular_speed();
  const ::vts::protocol::main::Vector3f& angular_speed() const;
  ::vts::protocol::main::Vector3f* release_angular_speed();
  ::vts::protocol::main::Vector3f* mutable_angular_speed();
  void set_allocated_angular_speed(::vts::protocol::main::Vector3f* angular_speed);
  private:
  const ::vts::protocol::main::Vector3f& _internal_angular_speed() const;
  ::vts::protocol::main::Vector3f* _internal_mutable_angular_speed();
  public:

  // .vts.protocol.main.Vector3f linear_acceleration = 9;
  bool has_linear_acceleration() const;
  private:
  bool _internal_has_linear_acceleration() const;
  public:
  void clear_linear_acceleration();
  const ::vts::protocol::main::Vector3f& linear_acceleration() const;
  ::vts::protocol::main::Vector3f* release_linear_acceleration();
  ::vts::protocol::main::Vector3f* mutable_linear_acceleration();
  void set_allocated_linear_acceleration(::vts::protocol::main::Vector3f* linear_acceleration);
  private:
  const ::vts::protocol::main::Vector3f& _internal_linear_acceleration() const;
  ::vts::protocol::main::Vector3f* _internal_mutable_linear_acceleration();
  public:

  // .vts.protocol.main.Vector3f angular_acceleration = 10;
  bool has_angular_acceleration() const;
  private:
  bool _internal_has_angular_acceleration() const;
  public:
  void clear_angular_acceleration();
  const ::vts::protocol::main::Vector3f& angular_acceleration() const;
  ::vts::protocol::main::Vector3f* release_angular_acceleration();
  ::vts::protocol::main::Vector3f* mutable_angular_acceleration();
  void set_allocated_angular_acceleration(::vts::protocol::main::Vector3f* angular_acceleration);
  private:
  const ::vts::protocol::main::Vector3f& _internal_angular_acceleration() const;
  ::vts::protocol::main::Vector3f* _internal_mutable_angular_acceleration();
  public:

  // int64 report_ts = 13;
  void clear_report_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 report_ts() const;
  void set_report_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_report_ts() const;
  void _internal_set_report_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .vts.protocol.main.RoleType type = 3;
  void clear_type();
  ::vts::protocol::main::RoleType type() const;
  void set_type(::vts::protocol::main::RoleType value);
  private:
  ::vts::protocol::main::RoleType _internal_type() const;
  void _internal_set_type(::vts::protocol::main::RoleType value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.SingleRole)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > f_status_;
  mutable std::atomic<int> _f_status_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> s_status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtype_;
  ::vts::protocol::main::ColliderBox* box_;
  ::vts::protocol::main::RLSL* rlsl_;
  ::vts::protocol::main::Vector3f* linear_speed_;
  ::vts::protocol::main::Vector3f* angular_speed_;
  ::vts::protocol::main::Vector3f* linear_acceleration_;
  ::vts::protocol::main::Vector3f* angular_acceleration_;
  ::PROTOBUF_NAMESPACE_ID::int64 report_ts_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class CompoundRole :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.CompoundRole) */ {
 public:
  CompoundRole();
  virtual ~CompoundRole();

  CompoundRole(const CompoundRole& from);
  CompoundRole(CompoundRole&& from) noexcept
    : CompoundRole() {
    *this = ::std::move(from);
  }

  inline CompoundRole& operator=(const CompoundRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompoundRole& operator=(CompoundRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CompoundRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompoundRole* internal_default_instance() {
    return reinterpret_cast<const CompoundRole*>(
               &_CompoundRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CompoundRole& a, CompoundRole& b) {
    a.Swap(&b);
  }
  inline void Swap(CompoundRole* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompoundRole* New() const final {
    return CreateMaybeMessage<CompoundRole>(nullptr);
  }

  CompoundRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompoundRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CompoundRole& from);
  void MergeFrom(const CompoundRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompoundRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.CompoundRole";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSingleRolesFieldNumber = 4,
    kIdFieldNumber = 1,
    kSubtypeFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // repeated .vts.protocol.main.SingleRole single_roles = 4;
  int single_roles_size() const;
  private:
  int _internal_single_roles_size() const;
  public:
  void clear_single_roles();
  ::vts::protocol::main::SingleRole* mutable_single_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole >*
      mutable_single_roles();
  private:
  const ::vts::protocol::main::SingleRole& _internal_single_roles(int index) const;
  ::vts::protocol::main::SingleRole* _internal_add_single_roles();
  public:
  const ::vts::protocol::main::SingleRole& single_roles(int index) const;
  ::vts::protocol::main::SingleRole* add_single_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole >&
      single_roles() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string subtype = 3;
  void clear_subtype();
  const std::string& subtype() const;
  void set_subtype(const std::string& value);
  void set_subtype(std::string&& value);
  void set_subtype(const char* value);
  void set_subtype(const char* value, size_t size);
  std::string* mutable_subtype();
  std::string* release_subtype();
  void set_allocated_subtype(std::string* subtype);
  private:
  const std::string& _internal_subtype() const;
  void _internal_set_subtype(const std::string& value);
  std::string* _internal_mutable_subtype();
  public:

  // .vts.protocol.main.RoleType type = 2;
  void clear_type();
  ::vts::protocol::main::RoleType type() const;
  void set_type(::vts::protocol::main::RoleType value);
  private:
  ::vts::protocol::main::RoleType _internal_type() const;
  void _internal_set_type(::vts::protocol::main::RoleType value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.CompoundRole)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole > single_roles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtype_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class ArchiveInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.ArchiveInfo) */ {
 public:
  ArchiveInfo();
  virtual ~ArchiveInfo();

  ArchiveInfo(const ArchiveInfo& from);
  ArchiveInfo(ArchiveInfo&& from) noexcept
    : ArchiveInfo() {
    *this = ::std::move(from);
  }

  inline ArchiveInfo& operator=(const ArchiveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArchiveInfo& operator=(ArchiveInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ArchiveInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArchiveInfo* internal_default_instance() {
    return reinterpret_cast<const ArchiveInfo*>(
               &_ArchiveInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ArchiveInfo& a, ArchiveInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ArchiveInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ArchiveInfo* New() const final {
    return CreateMaybeMessage<ArchiveInfo>(nullptr);
  }

  ArchiveInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ArchiveInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ArchiveInfo& from);
  void MergeFrom(const ArchiveInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArchiveInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.ArchiveInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUrlFieldNumber = 2,
    kMetaDataFieldNumber = 5,
    kModifyTsFieldNumber = 4,
    kTypeFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string meta_data = 5;
  void clear_meta_data();
  const std::string& meta_data() const;
  void set_meta_data(const std::string& value);
  void set_meta_data(std::string&& value);
  void set_meta_data(const char* value);
  void set_meta_data(const char* value, size_t size);
  std::string* mutable_meta_data();
  std::string* release_meta_data();
  void set_allocated_meta_data(std::string* meta_data);
  private:
  const std::string& _internal_meta_data() const;
  void _internal_set_meta_data(const std::string& value);
  std::string* _internal_mutable_meta_data();
  public:

  // int64 modify_ts = 4;
  void clear_modify_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 modify_ts() const;
  void set_modify_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_modify_ts() const;
  void _internal_set_modify_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .vts.protocol.main.ArchiveType type = 3;
  void clear_type();
  ::vts::protocol::main::ArchiveType type() const;
  void set_type(::vts::protocol::main::ArchiveType value);
  private:
  ::vts::protocol::main::ArchiveType _internal_type() const;
  void _internal_set_type(::vts::protocol::main::ArchiveType value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.ArchiveInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meta_data_;
  ::PROTOBUF_NAMESPACE_ID::int64 modify_ts_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// -------------------------------------------------------------------

class RoleContainerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.RoleContainerInfo) */ {
 public:
  RoleContainerInfo();
  virtual ~RoleContainerInfo();

  RoleContainerInfo(const RoleContainerInfo& from);
  RoleContainerInfo(RoleContainerInfo&& from) noexcept
    : RoleContainerInfo() {
    *this = ::std::move(from);
  }

  inline RoleContainerInfo& operator=(const RoleContainerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleContainerInfo& operator=(RoleContainerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoleContainerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoleContainerInfo* internal_default_instance() {
    return reinterpret_cast<const RoleContainerInfo*>(
               &_RoleContainerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RoleContainerInfo& a, RoleContainerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleContainerInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoleContainerInfo* New() const final {
    return CreateMaybeMessage<RoleContainerInfo>(nullptr);
  }

  RoleContainerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoleContainerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoleContainerInfo& from);
  void MergeFrom(const RoleContainerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleContainerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.RoleContainerInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fields_2eproto);
    return ::descriptor_table_fields_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 3,
    kTypeFieldNumber = 1,
    kRoleNumFieldNumber = 2,
    kLastAliveTsFieldNumber = 5,
    kIsAliveFieldNumber = 4,
  };
  // string address = 3;
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .vts.protocol.main.RoleContainerType type = 1;
  void clear_type();
  ::vts::protocol::main::RoleContainerType type() const;
  void set_type(::vts::protocol::main::RoleContainerType value);
  private:
  ::vts::protocol::main::RoleContainerType _internal_type() const;
  void _internal_set_type(::vts::protocol::main::RoleContainerType value);
  public:

  // uint32 role_num = 2;
  void clear_role_num();
  ::PROTOBUF_NAMESPACE_ID::uint32 role_num() const;
  void set_role_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_role_num() const;
  void _internal_set_role_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int64 last_alive_ts = 5;
  void clear_last_alive_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 last_alive_ts() const;
  void set_last_alive_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_last_alive_ts() const;
  void _internal_set_last_alive_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool is_alive = 4;
  void clear_is_alive();
  bool is_alive() const;
  void set_is_alive(bool value);
  private:
  bool _internal_is_alive() const;
  void _internal_set_is_alive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.RoleContainerInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 role_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_alive_ts_;
  bool is_alive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fields_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SimHeader

// int64 send_ts = 1;
inline void SimHeader::clear_send_ts() {
  send_ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimHeader::_internal_send_ts() const {
  return send_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimHeader::send_ts() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SimHeader.send_ts)
  return _internal_send_ts();
}
inline void SimHeader::_internal_set_send_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  send_ts_ = value;
}
inline void SimHeader::set_send_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_send_ts(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SimHeader.send_ts)
}

// int64 sim_ts = 2;
inline void SimHeader::clear_sim_ts() {
  sim_ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimHeader::_internal_sim_ts() const {
  return sim_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimHeader::sim_ts() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SimHeader.sim_ts)
  return _internal_sim_ts();
}
inline void SimHeader::_internal_set_sim_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sim_ts_ = value;
}
inline void SimHeader::set_sim_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sim_ts(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SimHeader.sim_ts)
}

// int64 seq_no = 3;
inline void SimHeader::clear_seq_no() {
  seq_no_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimHeader::_internal_seq_no() const {
  return seq_no_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimHeader::seq_no() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SimHeader.seq_no)
  return _internal_seq_no();
}
inline void SimHeader::_internal_set_seq_no(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  seq_no_ = value;
}
inline void SimHeader::set_seq_no(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seq_no(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SimHeader.seq_no)
}

// -------------------------------------------------------------------

// AOIInfo

// string role_id = 1;
inline void AOIInfo::clear_role_id() {
  role_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AOIInfo::role_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.AOIInfo.role_id)
  return _internal_role_id();
}
inline void AOIInfo::set_role_id(const std::string& value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.AOIInfo.role_id)
}
inline std::string* AOIInfo::mutable_role_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.AOIInfo.role_id)
  return _internal_mutable_role_id();
}
inline const std::string& AOIInfo::_internal_role_id() const {
  return role_id_.GetNoArena();
}
inline void AOIInfo::_internal_set_role_id(const std::string& value) {
  
  role_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AOIInfo::set_role_id(std::string&& value) {
  
  role_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.AOIInfo.role_id)
}
inline void AOIInfo::set_role_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  role_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.AOIInfo.role_id)
}
inline void AOIInfo::set_role_id(const char* value, size_t size) {
  
  role_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.AOIInfo.role_id)
}
inline std::string* AOIInfo::_internal_mutable_role_id() {
  
  return role_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AOIInfo::release_role_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.AOIInfo.role_id)
  
  return role_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AOIInfo::set_allocated_role_id(std::string* role_id) {
  if (role_id != nullptr) {
    
  } else {
    
  }
  role_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), role_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.AOIInfo.role_id)
}

// float aoi_radius = 2;
inline void AOIInfo::clear_aoi_radius() {
  aoi_radius_ = 0;
}
inline float AOIInfo::_internal_aoi_radius() const {
  return aoi_radius_;
}
inline float AOIInfo::aoi_radius() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.AOIInfo.aoi_radius)
  return _internal_aoi_radius();
}
inline void AOIInfo::_internal_set_aoi_radius(float value) {
  
  aoi_radius_ = value;
}
inline void AOIInfo::set_aoi_radius(float value) {
  _internal_set_aoi_radius(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.AOIInfo.aoi_radius)
}

// -------------------------------------------------------------------

// Vector3d

// double x = 1;
inline void Vector3d::clear_x() {
  x_ = 0;
}
inline double Vector3d::_internal_x() const {
  return x_;
}
inline double Vector3d::x() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Vector3d.x)
  return _internal_x();
}
inline void Vector3d::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vector3d::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Vector3d.x)
}

// double y = 2;
inline void Vector3d::clear_y() {
  y_ = 0;
}
inline double Vector3d::_internal_y() const {
  return y_;
}
inline double Vector3d::y() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Vector3d.y)
  return _internal_y();
}
inline void Vector3d::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vector3d::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Vector3d.y)
}

// double z = 3;
inline void Vector3d::clear_z() {
  z_ = 0;
}
inline double Vector3d::_internal_z() const {
  return z_;
}
inline double Vector3d::z() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Vector3d.z)
  return _internal_z();
}
inline void Vector3d::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Vector3d::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Vector3d.z)
}

// -------------------------------------------------------------------

// RLSL

// string road_id = 1;
inline void RLSL::clear_road_id() {
  road_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RLSL::road_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RLSL.road_id)
  return _internal_road_id();
}
inline void RLSL::set_road_id(const std::string& value) {
  _internal_set_road_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RLSL.road_id)
}
inline std::string* RLSL::mutable_road_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.RLSL.road_id)
  return _internal_mutable_road_id();
}
inline const std::string& RLSL::_internal_road_id() const {
  return road_id_.GetNoArena();
}
inline void RLSL::_internal_set_road_id(const std::string& value) {
  
  road_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RLSL::set_road_id(std::string&& value) {
  
  road_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.RLSL.road_id)
}
inline void RLSL::set_road_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  road_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.RLSL.road_id)
}
inline void RLSL::set_road_id(const char* value, size_t size) {
  
  road_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.RLSL.road_id)
}
inline std::string* RLSL::_internal_mutable_road_id() {
  
  return road_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RLSL::release_road_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.RLSL.road_id)
  
  return road_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RLSL::set_allocated_road_id(std::string* road_id) {
  if (road_id != nullptr) {
    
  } else {
    
  }
  road_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), road_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.RLSL.road_id)
}

// int32 lane_id = 2;
inline void RLSL::clear_lane_id() {
  lane_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RLSL::_internal_lane_id() const {
  return lane_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RLSL::lane_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RLSL.lane_id)
  return _internal_lane_id();
}
inline void RLSL::_internal_set_lane_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lane_id_ = value;
}
inline void RLSL::set_lane_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lane_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RLSL.lane_id)
}

// double s = 3;
inline void RLSL::clear_s() {
  s_ = 0;
}
inline double RLSL::_internal_s() const {
  return s_;
}
inline double RLSL::s() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RLSL.s)
  return _internal_s();
}
inline void RLSL::_internal_set_s(double value) {
  
  s_ = value;
}
inline void RLSL::set_s(double value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RLSL.s)
}

// double l = 4;
inline void RLSL::clear_l() {
  l_ = 0;
}
inline double RLSL::_internal_l() const {
  return l_;
}
inline double RLSL::l() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RLSL.l)
  return _internal_l();
}
inline void RLSL::_internal_set_l(double value) {
  
  l_ = value;
}
inline void RLSL::set_l(double value) {
  _internal_set_l(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RLSL.l)
}

// double z = 5;
inline void RLSL::clear_z() {
  z_ = 0;
}
inline double RLSL::_internal_z() const {
  return z_;
}
inline double RLSL::z() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RLSL.z)
  return _internal_z();
}
inline void RLSL::_internal_set_z(double value) {
  
  z_ = value;
}
inline void RLSL::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RLSL.z)
}

// -------------------------------------------------------------------

// QuaternionF

// float x = 1;
inline void QuaternionF::clear_x() {
  x_ = 0;
}
inline float QuaternionF::_internal_x() const {
  return x_;
}
inline float QuaternionF::x() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.QuaternionF.x)
  return _internal_x();
}
inline void QuaternionF::_internal_set_x(float value) {
  
  x_ = value;
}
inline void QuaternionF::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.QuaternionF.x)
}

// float y = 2;
inline void QuaternionF::clear_y() {
  y_ = 0;
}
inline float QuaternionF::_internal_y() const {
  return y_;
}
inline float QuaternionF::y() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.QuaternionF.y)
  return _internal_y();
}
inline void QuaternionF::_internal_set_y(float value) {
  
  y_ = value;
}
inline void QuaternionF::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.QuaternionF.y)
}

// float z = 3;
inline void QuaternionF::clear_z() {
  z_ = 0;
}
inline float QuaternionF::_internal_z() const {
  return z_;
}
inline float QuaternionF::z() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.QuaternionF.z)
  return _internal_z();
}
inline void QuaternionF::_internal_set_z(float value) {
  
  z_ = value;
}
inline void QuaternionF::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.QuaternionF.z)
}

// float w = 4;
inline void QuaternionF::clear_w() {
  w_ = 0;
}
inline float QuaternionF::_internal_w() const {
  return w_;
}
inline float QuaternionF::w() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.QuaternionF.w)
  return _internal_w();
}
inline void QuaternionF::_internal_set_w(float value) {
  
  w_ = value;
}
inline void QuaternionF::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.QuaternionF.w)
}

// -------------------------------------------------------------------

// Vector3f

// float x = 1;
inline void Vector3f::clear_x() {
  x_ = 0;
}
inline float Vector3f::_internal_x() const {
  return x_;
}
inline float Vector3f::x() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Vector3f.x)
  return _internal_x();
}
inline void Vector3f::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vector3f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Vector3f.x)
}

// float y = 2;
inline void Vector3f::clear_y() {
  y_ = 0;
}
inline float Vector3f::_internal_y() const {
  return y_;
}
inline float Vector3f::y() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Vector3f.y)
  return _internal_y();
}
inline void Vector3f::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vector3f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Vector3f.y)
}

// float z = 3;
inline void Vector3f::clear_z() {
  z_ = 0;
}
inline float Vector3f::_internal_z() const {
  return z_;
}
inline float Vector3f::z() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Vector3f.z)
  return _internal_z();
}
inline void Vector3f::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vector3f::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Vector3f.z)
}

// -------------------------------------------------------------------

// ColliderBox

// .vts.protocol.main.Vector3d bottom_center = 1;
inline bool ColliderBox::_internal_has_bottom_center() const {
  return this != internal_default_instance() && bottom_center_ != nullptr;
}
inline bool ColliderBox::has_bottom_center() const {
  return _internal_has_bottom_center();
}
inline void ColliderBox::clear_bottom_center() {
  if (GetArenaNoVirtual() == nullptr && bottom_center_ != nullptr) {
    delete bottom_center_;
  }
  bottom_center_ = nullptr;
}
inline const ::vts::protocol::main::Vector3d& ColliderBox::_internal_bottom_center() const {
  const ::vts::protocol::main::Vector3d* p = bottom_center_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::Vector3d*>(
      &::vts::protocol::main::_Vector3d_default_instance_);
}
inline const ::vts::protocol::main::Vector3d& ColliderBox::bottom_center() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ColliderBox.bottom_center)
  return _internal_bottom_center();
}
inline ::vts::protocol::main::Vector3d* ColliderBox::release_bottom_center() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ColliderBox.bottom_center)
  
  ::vts::protocol::main::Vector3d* temp = bottom_center_;
  bottom_center_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::Vector3d* ColliderBox::_internal_mutable_bottom_center() {
  
  if (bottom_center_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::Vector3d>(GetArenaNoVirtual());
    bottom_center_ = p;
  }
  return bottom_center_;
}
inline ::vts::protocol::main::Vector3d* ColliderBox::mutable_bottom_center() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ColliderBox.bottom_center)
  return _internal_mutable_bottom_center();
}
inline void ColliderBox::set_allocated_bottom_center(::vts::protocol::main::Vector3d* bottom_center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bottom_center_;
  }
  if (bottom_center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bottom_center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bottom_center, submessage_arena);
    }
    
  } else {
    
  }
  bottom_center_ = bottom_center;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ColliderBox.bottom_center)
}

// .vts.protocol.main.Vector3f size = 2;
inline bool ColliderBox::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool ColliderBox::has_size() const {
  return _internal_has_size();
}
inline void ColliderBox::clear_size() {
  if (GetArenaNoVirtual() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::vts::protocol::main::Vector3f& ColliderBox::_internal_size() const {
  const ::vts::protocol::main::Vector3f* p = size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::Vector3f*>(
      &::vts::protocol::main::_Vector3f_default_instance_);
}
inline const ::vts::protocol::main::Vector3f& ColliderBox::size() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ColliderBox.size)
  return _internal_size();
}
inline ::vts::protocol::main::Vector3f* ColliderBox::release_size() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ColliderBox.size)
  
  ::vts::protocol::main::Vector3f* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::Vector3f* ColliderBox::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::Vector3f>(GetArenaNoVirtual());
    size_ = p;
  }
  return size_;
}
inline ::vts::protocol::main::Vector3f* ColliderBox::mutable_size() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ColliderBox.size)
  return _internal_mutable_size();
}
inline void ColliderBox::set_allocated_size(::vts::protocol::main::Vector3f* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ColliderBox.size)
}

// .vts.protocol.main.QuaternionF rotation = 3;
inline bool ColliderBox::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool ColliderBox::has_rotation() const {
  return _internal_has_rotation();
}
inline void ColliderBox::clear_rotation() {
  if (GetArenaNoVirtual() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::vts::protocol::main::QuaternionF& ColliderBox::_internal_rotation() const {
  const ::vts::protocol::main::QuaternionF* p = rotation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::QuaternionF*>(
      &::vts::protocol::main::_QuaternionF_default_instance_);
}
inline const ::vts::protocol::main::QuaternionF& ColliderBox::rotation() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ColliderBox.rotation)
  return _internal_rotation();
}
inline ::vts::protocol::main::QuaternionF* ColliderBox::release_rotation() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ColliderBox.rotation)
  
  ::vts::protocol::main::QuaternionF* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::QuaternionF* ColliderBox::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::QuaternionF>(GetArenaNoVirtual());
    rotation_ = p;
  }
  return rotation_;
}
inline ::vts::protocol::main::QuaternionF* ColliderBox::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ColliderBox.rotation)
  return _internal_mutable_rotation();
}
inline void ColliderBox::set_allocated_rotation(::vts::protocol::main::QuaternionF* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ColliderBox.rotation)
}

// -------------------------------------------------------------------

// SingleRole

// string id = 1;
inline void SingleRole::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SingleRole::id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.id)
  return _internal_id();
}
inline void SingleRole::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SingleRole.id)
}
inline std::string* SingleRole::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.id)
  return _internal_mutable_id();
}
inline const std::string& SingleRole::_internal_id() const {
  return id_.GetNoArena();
}
inline void SingleRole::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SingleRole::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SingleRole.id)
}
inline void SingleRole::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SingleRole.id)
}
inline void SingleRole::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SingleRole.id)
}
inline std::string* SingleRole::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SingleRole::release_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SingleRole::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.id)
}

// string name = 2;
inline void SingleRole::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SingleRole::name() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.name)
  return _internal_name();
}
inline void SingleRole::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SingleRole.name)
}
inline std::string* SingleRole::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.name)
  return _internal_mutable_name();
}
inline const std::string& SingleRole::_internal_name() const {
  return name_.GetNoArena();
}
inline void SingleRole::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SingleRole::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SingleRole.name)
}
inline void SingleRole::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SingleRole.name)
}
inline void SingleRole::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SingleRole.name)
}
inline std::string* SingleRole::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SingleRole::release_name() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SingleRole::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.name)
}

// .vts.protocol.main.RoleType type = 3;
inline void SingleRole::clear_type() {
  type_ = 0;
}
inline ::vts::protocol::main::RoleType SingleRole::_internal_type() const {
  return static_cast< ::vts::protocol::main::RoleType >(type_);
}
inline ::vts::protocol::main::RoleType SingleRole::type() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.type)
  return _internal_type();
}
inline void SingleRole::_internal_set_type(::vts::protocol::main::RoleType value) {
  
  type_ = value;
}
inline void SingleRole::set_type(::vts::protocol::main::RoleType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SingleRole.type)
}

// string subtype = 4;
inline void SingleRole::clear_subtype() {
  subtype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SingleRole::subtype() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.subtype)
  return _internal_subtype();
}
inline void SingleRole::set_subtype(const std::string& value) {
  _internal_set_subtype(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SingleRole.subtype)
}
inline std::string* SingleRole::mutable_subtype() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.subtype)
  return _internal_mutable_subtype();
}
inline const std::string& SingleRole::_internal_subtype() const {
  return subtype_.GetNoArena();
}
inline void SingleRole::_internal_set_subtype(const std::string& value) {
  
  subtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SingleRole::set_subtype(std::string&& value) {
  
  subtype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SingleRole.subtype)
}
inline void SingleRole::set_subtype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  subtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SingleRole.subtype)
}
inline void SingleRole::set_subtype(const char* value, size_t size) {
  
  subtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SingleRole.subtype)
}
inline std::string* SingleRole::_internal_mutable_subtype() {
  
  return subtype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SingleRole::release_subtype() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.subtype)
  
  return subtype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SingleRole::set_allocated_subtype(std::string* subtype) {
  if (subtype != nullptr) {
    
  } else {
    
  }
  subtype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subtype);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.subtype)
}

// .vts.protocol.main.ColliderBox box = 5;
inline bool SingleRole::_internal_has_box() const {
  return this != internal_default_instance() && box_ != nullptr;
}
inline bool SingleRole::has_box() const {
  return _internal_has_box();
}
inline void SingleRole::clear_box() {
  if (GetArenaNoVirtual() == nullptr && box_ != nullptr) {
    delete box_;
  }
  box_ = nullptr;
}
inline const ::vts::protocol::main::ColliderBox& SingleRole::_internal_box() const {
  const ::vts::protocol::main::ColliderBox* p = box_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::ColliderBox*>(
      &::vts::protocol::main::_ColliderBox_default_instance_);
}
inline const ::vts::protocol::main::ColliderBox& SingleRole::box() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.box)
  return _internal_box();
}
inline ::vts::protocol::main::ColliderBox* SingleRole::release_box() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.box)
  
  ::vts::protocol::main::ColliderBox* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::ColliderBox* SingleRole::_internal_mutable_box() {
  
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::ColliderBox>(GetArenaNoVirtual());
    box_ = p;
  }
  return box_;
}
inline ::vts::protocol::main::ColliderBox* SingleRole::mutable_box() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.box)
  return _internal_mutable_box();
}
inline void SingleRole::set_allocated_box(::vts::protocol::main::ColliderBox* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.box)
}

// .vts.protocol.main.RLSL rlsl = 6;
inline bool SingleRole::_internal_has_rlsl() const {
  return this != internal_default_instance() && rlsl_ != nullptr;
}
inline bool SingleRole::has_rlsl() const {
  return _internal_has_rlsl();
}
inline void SingleRole::clear_rlsl() {
  if (GetArenaNoVirtual() == nullptr && rlsl_ != nullptr) {
    delete rlsl_;
  }
  rlsl_ = nullptr;
}
inline const ::vts::protocol::main::RLSL& SingleRole::_internal_rlsl() const {
  const ::vts::protocol::main::RLSL* p = rlsl_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::RLSL*>(
      &::vts::protocol::main::_RLSL_default_instance_);
}
inline const ::vts::protocol::main::RLSL& SingleRole::rlsl() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.rlsl)
  return _internal_rlsl();
}
inline ::vts::protocol::main::RLSL* SingleRole::release_rlsl() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.rlsl)
  
  ::vts::protocol::main::RLSL* temp = rlsl_;
  rlsl_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::RLSL* SingleRole::_internal_mutable_rlsl() {
  
  if (rlsl_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::RLSL>(GetArenaNoVirtual());
    rlsl_ = p;
  }
  return rlsl_;
}
inline ::vts::protocol::main::RLSL* SingleRole::mutable_rlsl() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.rlsl)
  return _internal_mutable_rlsl();
}
inline void SingleRole::set_allocated_rlsl(::vts::protocol::main::RLSL* rlsl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rlsl_;
  }
  if (rlsl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rlsl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rlsl, submessage_arena);
    }
    
  } else {
    
  }
  rlsl_ = rlsl;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.rlsl)
}

// .vts.protocol.main.Vector3f linear_speed = 7;
inline bool SingleRole::_internal_has_linear_speed() const {
  return this != internal_default_instance() && linear_speed_ != nullptr;
}
inline bool SingleRole::has_linear_speed() const {
  return _internal_has_linear_speed();
}
inline void SingleRole::clear_linear_speed() {
  if (GetArenaNoVirtual() == nullptr && linear_speed_ != nullptr) {
    delete linear_speed_;
  }
  linear_speed_ = nullptr;
}
inline const ::vts::protocol::main::Vector3f& SingleRole::_internal_linear_speed() const {
  const ::vts::protocol::main::Vector3f* p = linear_speed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::Vector3f*>(
      &::vts::protocol::main::_Vector3f_default_instance_);
}
inline const ::vts::protocol::main::Vector3f& SingleRole::linear_speed() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.linear_speed)
  return _internal_linear_speed();
}
inline ::vts::protocol::main::Vector3f* SingleRole::release_linear_speed() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.linear_speed)
  
  ::vts::protocol::main::Vector3f* temp = linear_speed_;
  linear_speed_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::Vector3f* SingleRole::_internal_mutable_linear_speed() {
  
  if (linear_speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::Vector3f>(GetArenaNoVirtual());
    linear_speed_ = p;
  }
  return linear_speed_;
}
inline ::vts::protocol::main::Vector3f* SingleRole::mutable_linear_speed() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.linear_speed)
  return _internal_mutable_linear_speed();
}
inline void SingleRole::set_allocated_linear_speed(::vts::protocol::main::Vector3f* linear_speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete linear_speed_;
  }
  if (linear_speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      linear_speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_speed, submessage_arena);
    }
    
  } else {
    
  }
  linear_speed_ = linear_speed;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.linear_speed)
}

// .vts.protocol.main.Vector3f angular_speed = 8;
inline bool SingleRole::_internal_has_angular_speed() const {
  return this != internal_default_instance() && angular_speed_ != nullptr;
}
inline bool SingleRole::has_angular_speed() const {
  return _internal_has_angular_speed();
}
inline void SingleRole::clear_angular_speed() {
  if (GetArenaNoVirtual() == nullptr && angular_speed_ != nullptr) {
    delete angular_speed_;
  }
  angular_speed_ = nullptr;
}
inline const ::vts::protocol::main::Vector3f& SingleRole::_internal_angular_speed() const {
  const ::vts::protocol::main::Vector3f* p = angular_speed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::Vector3f*>(
      &::vts::protocol::main::_Vector3f_default_instance_);
}
inline const ::vts::protocol::main::Vector3f& SingleRole::angular_speed() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.angular_speed)
  return _internal_angular_speed();
}
inline ::vts::protocol::main::Vector3f* SingleRole::release_angular_speed() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.angular_speed)
  
  ::vts::protocol::main::Vector3f* temp = angular_speed_;
  angular_speed_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::Vector3f* SingleRole::_internal_mutable_angular_speed() {
  
  if (angular_speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::Vector3f>(GetArenaNoVirtual());
    angular_speed_ = p;
  }
  return angular_speed_;
}
inline ::vts::protocol::main::Vector3f* SingleRole::mutable_angular_speed() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.angular_speed)
  return _internal_mutable_angular_speed();
}
inline void SingleRole::set_allocated_angular_speed(::vts::protocol::main::Vector3f* angular_speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete angular_speed_;
  }
  if (angular_speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      angular_speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_speed, submessage_arena);
    }
    
  } else {
    
  }
  angular_speed_ = angular_speed;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.angular_speed)
}

// .vts.protocol.main.Vector3f linear_acceleration = 9;
inline bool SingleRole::_internal_has_linear_acceleration() const {
  return this != internal_default_instance() && linear_acceleration_ != nullptr;
}
inline bool SingleRole::has_linear_acceleration() const {
  return _internal_has_linear_acceleration();
}
inline void SingleRole::clear_linear_acceleration() {
  if (GetArenaNoVirtual() == nullptr && linear_acceleration_ != nullptr) {
    delete linear_acceleration_;
  }
  linear_acceleration_ = nullptr;
}
inline const ::vts::protocol::main::Vector3f& SingleRole::_internal_linear_acceleration() const {
  const ::vts::protocol::main::Vector3f* p = linear_acceleration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::Vector3f*>(
      &::vts::protocol::main::_Vector3f_default_instance_);
}
inline const ::vts::protocol::main::Vector3f& SingleRole::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.linear_acceleration)
  return _internal_linear_acceleration();
}
inline ::vts::protocol::main::Vector3f* SingleRole::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.linear_acceleration)
  
  ::vts::protocol::main::Vector3f* temp = linear_acceleration_;
  linear_acceleration_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::Vector3f* SingleRole::_internal_mutable_linear_acceleration() {
  
  if (linear_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::Vector3f>(GetArenaNoVirtual());
    linear_acceleration_ = p;
  }
  return linear_acceleration_;
}
inline ::vts::protocol::main::Vector3f* SingleRole::mutable_linear_acceleration() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.linear_acceleration)
  return _internal_mutable_linear_acceleration();
}
inline void SingleRole::set_allocated_linear_acceleration(::vts::protocol::main::Vector3f* linear_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete linear_acceleration_;
  }
  if (linear_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      linear_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_acceleration, submessage_arena);
    }
    
  } else {
    
  }
  linear_acceleration_ = linear_acceleration;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.linear_acceleration)
}

// .vts.protocol.main.Vector3f angular_acceleration = 10;
inline bool SingleRole::_internal_has_angular_acceleration() const {
  return this != internal_default_instance() && angular_acceleration_ != nullptr;
}
inline bool SingleRole::has_angular_acceleration() const {
  return _internal_has_angular_acceleration();
}
inline void SingleRole::clear_angular_acceleration() {
  if (GetArenaNoVirtual() == nullptr && angular_acceleration_ != nullptr) {
    delete angular_acceleration_;
  }
  angular_acceleration_ = nullptr;
}
inline const ::vts::protocol::main::Vector3f& SingleRole::_internal_angular_acceleration() const {
  const ::vts::protocol::main::Vector3f* p = angular_acceleration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::Vector3f*>(
      &::vts::protocol::main::_Vector3f_default_instance_);
}
inline const ::vts::protocol::main::Vector3f& SingleRole::angular_acceleration() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.angular_acceleration)
  return _internal_angular_acceleration();
}
inline ::vts::protocol::main::Vector3f* SingleRole::release_angular_acceleration() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SingleRole.angular_acceleration)
  
  ::vts::protocol::main::Vector3f* temp = angular_acceleration_;
  angular_acceleration_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::Vector3f* SingleRole::_internal_mutable_angular_acceleration() {
  
  if (angular_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::Vector3f>(GetArenaNoVirtual());
    angular_acceleration_ = p;
  }
  return angular_acceleration_;
}
inline ::vts::protocol::main::Vector3f* SingleRole::mutable_angular_acceleration() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.angular_acceleration)
  return _internal_mutable_angular_acceleration();
}
inline void SingleRole::set_allocated_angular_acceleration(::vts::protocol::main::Vector3f* angular_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete angular_acceleration_;
  }
  if (angular_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      angular_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_acceleration, submessage_arena);
    }
    
  } else {
    
  }
  angular_acceleration_ = angular_acceleration;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SingleRole.angular_acceleration)
}

// repeated float f_status = 11;
inline int SingleRole::_internal_f_status_size() const {
  return f_status_.size();
}
inline int SingleRole::f_status_size() const {
  return _internal_f_status_size();
}
inline void SingleRole::clear_f_status() {
  f_status_.Clear();
}
inline float SingleRole::_internal_f_status(int index) const {
  return f_status_.Get(index);
}
inline float SingleRole::f_status(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.f_status)
  return _internal_f_status(index);
}
inline void SingleRole::set_f_status(int index, float value) {
  f_status_.Set(index, value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SingleRole.f_status)
}
inline void SingleRole::_internal_add_f_status(float value) {
  f_status_.Add(value);
}
inline void SingleRole::add_f_status(float value) {
  _internal_add_f_status(value);
  // @@protoc_insertion_point(field_add:vts.protocol.main.SingleRole.f_status)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SingleRole::_internal_f_status() const {
  return f_status_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SingleRole::f_status() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.SingleRole.f_status)
  return _internal_f_status();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SingleRole::_internal_mutable_f_status() {
  return &f_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SingleRole::mutable_f_status() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.SingleRole.f_status)
  return _internal_mutable_f_status();
}

// repeated string s_status = 12;
inline int SingleRole::_internal_s_status_size() const {
  return s_status_.size();
}
inline int SingleRole::s_status_size() const {
  return _internal_s_status_size();
}
inline void SingleRole::clear_s_status() {
  s_status_.Clear();
}
inline std::string* SingleRole::add_s_status() {
  // @@protoc_insertion_point(field_add_mutable:vts.protocol.main.SingleRole.s_status)
  return _internal_add_s_status();
}
inline const std::string& SingleRole::_internal_s_status(int index) const {
  return s_status_.Get(index);
}
inline const std::string& SingleRole::s_status(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.s_status)
  return _internal_s_status(index);
}
inline std::string* SingleRole::mutable_s_status(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SingleRole.s_status)
  return s_status_.Mutable(index);
}
inline void SingleRole::set_s_status(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vts.protocol.main.SingleRole.s_status)
  s_status_.Mutable(index)->assign(value);
}
inline void SingleRole::set_s_status(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vts.protocol.main.SingleRole.s_status)
  s_status_.Mutable(index)->assign(std::move(value));
}
inline void SingleRole::set_s_status(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  s_status_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SingleRole.s_status)
}
inline void SingleRole::set_s_status(int index, const char* value, size_t size) {
  s_status_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SingleRole.s_status)
}
inline std::string* SingleRole::_internal_add_s_status() {
  return s_status_.Add();
}
inline void SingleRole::add_s_status(const std::string& value) {
  s_status_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vts.protocol.main.SingleRole.s_status)
}
inline void SingleRole::add_s_status(std::string&& value) {
  s_status_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vts.protocol.main.SingleRole.s_status)
}
inline void SingleRole::add_s_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  s_status_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vts.protocol.main.SingleRole.s_status)
}
inline void SingleRole::add_s_status(const char* value, size_t size) {
  s_status_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vts.protocol.main.SingleRole.s_status)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SingleRole::s_status() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.SingleRole.s_status)
  return s_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SingleRole::mutable_s_status() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.SingleRole.s_status)
  return &s_status_;
}

// int64 report_ts = 13;
inline void SingleRole::clear_report_ts() {
  report_ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SingleRole::_internal_report_ts() const {
  return report_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SingleRole::report_ts() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SingleRole.report_ts)
  return _internal_report_ts();
}
inline void SingleRole::_internal_set_report_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  report_ts_ = value;
}
inline void SingleRole::set_report_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_report_ts(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SingleRole.report_ts)
}

// -------------------------------------------------------------------

// CompoundRole

// string id = 1;
inline void CompoundRole::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CompoundRole::id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.CompoundRole.id)
  return _internal_id();
}
inline void CompoundRole::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.CompoundRole.id)
}
inline std::string* CompoundRole::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.CompoundRole.id)
  return _internal_mutable_id();
}
inline const std::string& CompoundRole::_internal_id() const {
  return id_.GetNoArena();
}
inline void CompoundRole::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CompoundRole::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.CompoundRole.id)
}
inline void CompoundRole::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.CompoundRole.id)
}
inline void CompoundRole::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.CompoundRole.id)
}
inline std::string* CompoundRole::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CompoundRole::release_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.CompoundRole.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CompoundRole::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.CompoundRole.id)
}

// .vts.protocol.main.RoleType type = 2;
inline void CompoundRole::clear_type() {
  type_ = 0;
}
inline ::vts::protocol::main::RoleType CompoundRole::_internal_type() const {
  return static_cast< ::vts::protocol::main::RoleType >(type_);
}
inline ::vts::protocol::main::RoleType CompoundRole::type() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.CompoundRole.type)
  return _internal_type();
}
inline void CompoundRole::_internal_set_type(::vts::protocol::main::RoleType value) {
  
  type_ = value;
}
inline void CompoundRole::set_type(::vts::protocol::main::RoleType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.CompoundRole.type)
}

// string subtype = 3;
inline void CompoundRole::clear_subtype() {
  subtype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CompoundRole::subtype() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.CompoundRole.subtype)
  return _internal_subtype();
}
inline void CompoundRole::set_subtype(const std::string& value) {
  _internal_set_subtype(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.CompoundRole.subtype)
}
inline std::string* CompoundRole::mutable_subtype() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.CompoundRole.subtype)
  return _internal_mutable_subtype();
}
inline const std::string& CompoundRole::_internal_subtype() const {
  return subtype_.GetNoArena();
}
inline void CompoundRole::_internal_set_subtype(const std::string& value) {
  
  subtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CompoundRole::set_subtype(std::string&& value) {
  
  subtype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.CompoundRole.subtype)
}
inline void CompoundRole::set_subtype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  subtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.CompoundRole.subtype)
}
inline void CompoundRole::set_subtype(const char* value, size_t size) {
  
  subtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.CompoundRole.subtype)
}
inline std::string* CompoundRole::_internal_mutable_subtype() {
  
  return subtype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CompoundRole::release_subtype() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.CompoundRole.subtype)
  
  return subtype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CompoundRole::set_allocated_subtype(std::string* subtype) {
  if (subtype != nullptr) {
    
  } else {
    
  }
  subtype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subtype);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.CompoundRole.subtype)
}

// repeated .vts.protocol.main.SingleRole single_roles = 4;
inline int CompoundRole::_internal_single_roles_size() const {
  return single_roles_.size();
}
inline int CompoundRole::single_roles_size() const {
  return _internal_single_roles_size();
}
inline void CompoundRole::clear_single_roles() {
  single_roles_.Clear();
}
inline ::vts::protocol::main::SingleRole* CompoundRole::mutable_single_roles(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.CompoundRole.single_roles)
  return single_roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole >*
CompoundRole::mutable_single_roles() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.CompoundRole.single_roles)
  return &single_roles_;
}
inline const ::vts::protocol::main::SingleRole& CompoundRole::_internal_single_roles(int index) const {
  return single_roles_.Get(index);
}
inline const ::vts::protocol::main::SingleRole& CompoundRole::single_roles(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.CompoundRole.single_roles)
  return _internal_single_roles(index);
}
inline ::vts::protocol::main::SingleRole* CompoundRole::_internal_add_single_roles() {
  return single_roles_.Add();
}
inline ::vts::protocol::main::SingleRole* CompoundRole::add_single_roles() {
  // @@protoc_insertion_point(field_add:vts.protocol.main.CompoundRole.single_roles)
  return _internal_add_single_roles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole >&
CompoundRole::single_roles() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.CompoundRole.single_roles)
  return single_roles_;
}

// -------------------------------------------------------------------

// ArchiveInfo

// string id = 1;
inline void ArchiveInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ArchiveInfo::id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ArchiveInfo.id)
  return _internal_id();
}
inline void ArchiveInfo::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ArchiveInfo.id)
}
inline std::string* ArchiveInfo::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ArchiveInfo.id)
  return _internal_mutable_id();
}
inline const std::string& ArchiveInfo::_internal_id() const {
  return id_.GetNoArena();
}
inline void ArchiveInfo::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ArchiveInfo::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.ArchiveInfo.id)
}
inline void ArchiveInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.ArchiveInfo.id)
}
inline void ArchiveInfo::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.ArchiveInfo.id)
}
inline std::string* ArchiveInfo::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ArchiveInfo::release_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ArchiveInfo.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ArchiveInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ArchiveInfo.id)
}

// string url = 2;
inline void ArchiveInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ArchiveInfo::url() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ArchiveInfo.url)
  return _internal_url();
}
inline void ArchiveInfo::set_url(const std::string& value) {
  _internal_set_url(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ArchiveInfo.url)
}
inline std::string* ArchiveInfo::mutable_url() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ArchiveInfo.url)
  return _internal_mutable_url();
}
inline const std::string& ArchiveInfo::_internal_url() const {
  return url_.GetNoArena();
}
inline void ArchiveInfo::_internal_set_url(const std::string& value) {
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ArchiveInfo::set_url(std::string&& value) {
  
  url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.ArchiveInfo.url)
}
inline void ArchiveInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.ArchiveInfo.url)
}
inline void ArchiveInfo::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.ArchiveInfo.url)
}
inline std::string* ArchiveInfo::_internal_mutable_url() {
  
  return url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ArchiveInfo::release_url() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ArchiveInfo.url)
  
  return url_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ArchiveInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ArchiveInfo.url)
}

// .vts.protocol.main.ArchiveType type = 3;
inline void ArchiveInfo::clear_type() {
  type_ = 0;
}
inline ::vts::protocol::main::ArchiveType ArchiveInfo::_internal_type() const {
  return static_cast< ::vts::protocol::main::ArchiveType >(type_);
}
inline ::vts::protocol::main::ArchiveType ArchiveInfo::type() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ArchiveInfo.type)
  return _internal_type();
}
inline void ArchiveInfo::_internal_set_type(::vts::protocol::main::ArchiveType value) {
  
  type_ = value;
}
inline void ArchiveInfo::set_type(::vts::protocol::main::ArchiveType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ArchiveInfo.type)
}

// int64 modify_ts = 4;
inline void ArchiveInfo::clear_modify_ts() {
  modify_ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ArchiveInfo::_internal_modify_ts() const {
  return modify_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ArchiveInfo::modify_ts() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ArchiveInfo.modify_ts)
  return _internal_modify_ts();
}
inline void ArchiveInfo::_internal_set_modify_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  modify_ts_ = value;
}
inline void ArchiveInfo::set_modify_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_modify_ts(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ArchiveInfo.modify_ts)
}

// string meta_data = 5;
inline void ArchiveInfo::clear_meta_data() {
  meta_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ArchiveInfo::meta_data() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ArchiveInfo.meta_data)
  return _internal_meta_data();
}
inline void ArchiveInfo::set_meta_data(const std::string& value) {
  _internal_set_meta_data(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ArchiveInfo.meta_data)
}
inline std::string* ArchiveInfo::mutable_meta_data() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ArchiveInfo.meta_data)
  return _internal_mutable_meta_data();
}
inline const std::string& ArchiveInfo::_internal_meta_data() const {
  return meta_data_.GetNoArena();
}
inline void ArchiveInfo::_internal_set_meta_data(const std::string& value) {
  
  meta_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ArchiveInfo::set_meta_data(std::string&& value) {
  
  meta_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.ArchiveInfo.meta_data)
}
inline void ArchiveInfo::set_meta_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  meta_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.ArchiveInfo.meta_data)
}
inline void ArchiveInfo::set_meta_data(const char* value, size_t size) {
  
  meta_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.ArchiveInfo.meta_data)
}
inline std::string* ArchiveInfo::_internal_mutable_meta_data() {
  
  return meta_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ArchiveInfo::release_meta_data() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ArchiveInfo.meta_data)
  
  return meta_data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ArchiveInfo::set_allocated_meta_data(std::string* meta_data) {
  if (meta_data != nullptr) {
    
  } else {
    
  }
  meta_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meta_data);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ArchiveInfo.meta_data)
}

// -------------------------------------------------------------------

// RoleContainerInfo

// .vts.protocol.main.RoleContainerType type = 1;
inline void RoleContainerInfo::clear_type() {
  type_ = 0;
}
inline ::vts::protocol::main::RoleContainerType RoleContainerInfo::_internal_type() const {
  return static_cast< ::vts::protocol::main::RoleContainerType >(type_);
}
inline ::vts::protocol::main::RoleContainerType RoleContainerInfo::type() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RoleContainerInfo.type)
  return _internal_type();
}
inline void RoleContainerInfo::_internal_set_type(::vts::protocol::main::RoleContainerType value) {
  
  type_ = value;
}
inline void RoleContainerInfo::set_type(::vts::protocol::main::RoleContainerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RoleContainerInfo.type)
}

// uint32 role_num = 2;
inline void RoleContainerInfo::clear_role_num() {
  role_num_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RoleContainerInfo::_internal_role_num() const {
  return role_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RoleContainerInfo::role_num() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RoleContainerInfo.role_num)
  return _internal_role_num();
}
inline void RoleContainerInfo::_internal_set_role_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  role_num_ = value;
}
inline void RoleContainerInfo::set_role_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_role_num(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RoleContainerInfo.role_num)
}

// string address = 3;
inline void RoleContainerInfo::clear_address() {
  address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RoleContainerInfo::address() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RoleContainerInfo.address)
  return _internal_address();
}
inline void RoleContainerInfo::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RoleContainerInfo.address)
}
inline std::string* RoleContainerInfo::mutable_address() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.RoleContainerInfo.address)
  return _internal_mutable_address();
}
inline const std::string& RoleContainerInfo::_internal_address() const {
  return address_.GetNoArena();
}
inline void RoleContainerInfo::_internal_set_address(const std::string& value) {
  
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RoleContainerInfo::set_address(std::string&& value) {
  
  address_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.RoleContainerInfo.address)
}
inline void RoleContainerInfo::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.RoleContainerInfo.address)
}
inline void RoleContainerInfo::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.RoleContainerInfo.address)
}
inline std::string* RoleContainerInfo::_internal_mutable_address() {
  
  return address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoleContainerInfo::release_address() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.RoleContainerInfo.address)
  
  return address_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoleContainerInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.RoleContainerInfo.address)
}

// bool is_alive = 4;
inline void RoleContainerInfo::clear_is_alive() {
  is_alive_ = false;
}
inline bool RoleContainerInfo::_internal_is_alive() const {
  return is_alive_;
}
inline bool RoleContainerInfo::is_alive() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RoleContainerInfo.is_alive)
  return _internal_is_alive();
}
inline void RoleContainerInfo::_internal_set_is_alive(bool value) {
  
  is_alive_ = value;
}
inline void RoleContainerInfo::set_is_alive(bool value) {
  _internal_set_is_alive(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RoleContainerInfo.is_alive)
}

// int64 last_alive_ts = 5;
inline void RoleContainerInfo::clear_last_alive_ts() {
  last_alive_ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RoleContainerInfo::_internal_last_alive_ts() const {
  return last_alive_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RoleContainerInfo::last_alive_ts() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.RoleContainerInfo.last_alive_ts)
  return _internal_last_alive_ts();
}
inline void RoleContainerInfo::_internal_set_last_alive_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  last_alive_ts_ = value;
}
inline void RoleContainerInfo::set_last_alive_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_last_alive_ts(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.RoleContainerInfo.last_alive_ts)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace main
}  // namespace protocol
}  // namespace vts

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fields_2eproto
