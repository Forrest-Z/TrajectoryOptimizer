// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chassis_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chassis_5fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chassis_5fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "chassis_enums.pb.h"
#include "fields.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chassis_5fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chassis_5fmessages_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chassis_5fmessages_2eproto;
namespace vts {
namespace protocol {
namespace chassis {
class BodyControlModule;
class BodyControlModuleDefaultTypeInternal;
extern BodyControlModuleDefaultTypeInternal _BodyControlModule_default_instance_;
class BodyControlModuleFeedback;
class BodyControlModuleFeedbackDefaultTypeInternal;
extern BodyControlModuleFeedbackDefaultTypeInternal _BodyControlModuleFeedback_default_instance_;
class BrakeControl;
class BrakeControlDefaultTypeInternal;
extern BrakeControlDefaultTypeInternal _BrakeControl_default_instance_;
class BrakeFeedback;
class BrakeFeedbackDefaultTypeInternal;
extern BrakeFeedbackDefaultTypeInternal _BrakeFeedback_default_instance_;
class DrivingControl;
class DrivingControlDefaultTypeInternal;
extern DrivingControlDefaultTypeInternal _DrivingControl_default_instance_;
class DrivingFeedback;
class DrivingFeedbackDefaultTypeInternal;
extern DrivingFeedbackDefaultTypeInternal _DrivingFeedback_default_instance_;
class GearControl;
class GearControlDefaultTypeInternal;
extern GearControlDefaultTypeInternal _GearControl_default_instance_;
class GearFeedback;
class GearFeedbackDefaultTypeInternal;
extern GearFeedbackDefaultTypeInternal _GearFeedback_default_instance_;
class SteeringControl;
class SteeringControlDefaultTypeInternal;
extern SteeringControlDefaultTypeInternal _SteeringControl_default_instance_;
class SteeringFeedback;
class SteeringFeedbackDefaultTypeInternal;
extern SteeringFeedbackDefaultTypeInternal _SteeringFeedback_default_instance_;
class VehicleControl;
class VehicleControlDefaultTypeInternal;
extern VehicleControlDefaultTypeInternal _VehicleControl_default_instance_;
class VehicleFeedback;
class VehicleFeedbackDefaultTypeInternal;
extern VehicleFeedbackDefaultTypeInternal _VehicleFeedback_default_instance_;
class VehicleQuit;
class VehicleQuitDefaultTypeInternal;
extern VehicleQuitDefaultTypeInternal _VehicleQuit_default_instance_;
class VehicleRegister;
class VehicleRegisterDefaultTypeInternal;
extern VehicleRegisterDefaultTypeInternal _VehicleRegister_default_instance_;
}  // namespace chassis
}  // namespace protocol
}  // namespace vts
PROTOBUF_NAMESPACE_OPEN
template<> ::vts::protocol::chassis::BodyControlModule* Arena::CreateMaybeMessage<::vts::protocol::chassis::BodyControlModule>(Arena*);
template<> ::vts::protocol::chassis::BodyControlModuleFeedback* Arena::CreateMaybeMessage<::vts::protocol::chassis::BodyControlModuleFeedback>(Arena*);
template<> ::vts::protocol::chassis::BrakeControl* Arena::CreateMaybeMessage<::vts::protocol::chassis::BrakeControl>(Arena*);
template<> ::vts::protocol::chassis::BrakeFeedback* Arena::CreateMaybeMessage<::vts::protocol::chassis::BrakeFeedback>(Arena*);
template<> ::vts::protocol::chassis::DrivingControl* Arena::CreateMaybeMessage<::vts::protocol::chassis::DrivingControl>(Arena*);
template<> ::vts::protocol::chassis::DrivingFeedback* Arena::CreateMaybeMessage<::vts::protocol::chassis::DrivingFeedback>(Arena*);
template<> ::vts::protocol::chassis::GearControl* Arena::CreateMaybeMessage<::vts::protocol::chassis::GearControl>(Arena*);
template<> ::vts::protocol::chassis::GearFeedback* Arena::CreateMaybeMessage<::vts::protocol::chassis::GearFeedback>(Arena*);
template<> ::vts::protocol::chassis::SteeringControl* Arena::CreateMaybeMessage<::vts::protocol::chassis::SteeringControl>(Arena*);
template<> ::vts::protocol::chassis::SteeringFeedback* Arena::CreateMaybeMessage<::vts::protocol::chassis::SteeringFeedback>(Arena*);
template<> ::vts::protocol::chassis::VehicleControl* Arena::CreateMaybeMessage<::vts::protocol::chassis::VehicleControl>(Arena*);
template<> ::vts::protocol::chassis::VehicleFeedback* Arena::CreateMaybeMessage<::vts::protocol::chassis::VehicleFeedback>(Arena*);
template<> ::vts::protocol::chassis::VehicleQuit* Arena::CreateMaybeMessage<::vts::protocol::chassis::VehicleQuit>(Arena*);
template<> ::vts::protocol::chassis::VehicleRegister* Arena::CreateMaybeMessage<::vts::protocol::chassis::VehicleRegister>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vts {
namespace protocol {
namespace chassis {

// ===================================================================

class SteeringControl :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.SteeringControl) */ {
 public:
  SteeringControl();
  virtual ~SteeringControl();

  SteeringControl(const SteeringControl& from);
  SteeringControl(SteeringControl&& from) noexcept
    : SteeringControl() {
    *this = ::std::move(from);
  }

  inline SteeringControl& operator=(const SteeringControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline SteeringControl& operator=(SteeringControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SteeringControl& default_instance();

  enum CmdValueCase {
    kTargetSteeringWheelAngle = 1,
    kActualSteeringWheelAngle = 2,
    kTargetSteeringWheelTorque = 3,
    kTargetDirectiveWheelAngle = 4,
    CMD_VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SteeringControl* internal_default_instance() {
    return reinterpret_cast<const SteeringControl*>(
               &_SteeringControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SteeringControl& a, SteeringControl& b) {
    a.Swap(&b);
  }
  inline void Swap(SteeringControl* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SteeringControl* New() const final {
    return CreateMaybeMessage<SteeringControl>(nullptr);
  }

  SteeringControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SteeringControl>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SteeringControl& from);
  void MergeFrom(const SteeringControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SteeringControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.SteeringControl";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetSteeringWheelAngleFieldNumber = 1,
    kActualSteeringWheelAngleFieldNumber = 2,
    kTargetSteeringWheelTorqueFieldNumber = 3,
    kTargetDirectiveWheelAngleFieldNumber = 4,
  };
  // float target_steering_wheel_angle = 1;
  private:
  bool _internal_has_target_steering_wheel_angle() const;
  public:
  void clear_target_steering_wheel_angle();
  float target_steering_wheel_angle() const;
  void set_target_steering_wheel_angle(float value);
  private:
  float _internal_target_steering_wheel_angle() const;
  void _internal_set_target_steering_wheel_angle(float value);
  public:

  // float actual_steering_wheel_angle = 2;
  private:
  bool _internal_has_actual_steering_wheel_angle() const;
  public:
  void clear_actual_steering_wheel_angle();
  float actual_steering_wheel_angle() const;
  void set_actual_steering_wheel_angle(float value);
  private:
  float _internal_actual_steering_wheel_angle() const;
  void _internal_set_actual_steering_wheel_angle(float value);
  public:

  // float target_steering_wheel_torque = 3;
  private:
  bool _internal_has_target_steering_wheel_torque() const;
  public:
  void clear_target_steering_wheel_torque();
  float target_steering_wheel_torque() const;
  void set_target_steering_wheel_torque(float value);
  private:
  float _internal_target_steering_wheel_torque() const;
  void _internal_set_target_steering_wheel_torque(float value);
  public:

  // float target_directive_wheel_angle = 4;
  private:
  bool _internal_has_target_directive_wheel_angle() const;
  public:
  void clear_target_directive_wheel_angle();
  float target_directive_wheel_angle() const;
  void set_target_directive_wheel_angle(float value);
  private:
  float _internal_target_directive_wheel_angle() const;
  void _internal_set_target_directive_wheel_angle(float value);
  public:

  void clear_cmd_value();
  CmdValueCase cmd_value_case() const;
  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.SteeringControl)
 private:
  class _Internal;
  void set_has_target_steering_wheel_angle();
  void set_has_actual_steering_wheel_angle();
  void set_has_target_steering_wheel_torque();
  void set_has_target_directive_wheel_angle();

  inline bool has_cmd_value() const;
  inline void clear_has_cmd_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union CmdValueUnion {
    CmdValueUnion() {}
    float target_steering_wheel_angle_;
    float actual_steering_wheel_angle_;
    float target_steering_wheel_torque_;
    float target_directive_wheel_angle_;
  } cmd_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class SteeringFeedback :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.SteeringFeedback) */ {
 public:
  SteeringFeedback();
  virtual ~SteeringFeedback();

  SteeringFeedback(const SteeringFeedback& from);
  SteeringFeedback(SteeringFeedback&& from) noexcept
    : SteeringFeedback() {
    *this = ::std::move(from);
  }

  inline SteeringFeedback& operator=(const SteeringFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SteeringFeedback& operator=(SteeringFeedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SteeringFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SteeringFeedback* internal_default_instance() {
    return reinterpret_cast<const SteeringFeedback*>(
               &_SteeringFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SteeringFeedback& a, SteeringFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(SteeringFeedback* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SteeringFeedback* New() const final {
    return CreateMaybeMessage<SteeringFeedback>(nullptr);
  }

  SteeringFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SteeringFeedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SteeringFeedback& from);
  void MergeFrom(const SteeringFeedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SteeringFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.SteeringFeedback";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteeringWheelAngleFieldNumber = 1,
    kSteeringWheelSpeedFieldNumber = 2,
    kLeftDirectiveWheelAngleFieldNumber = 3,
    kRightDirectiveWheelAngleFieldNumber = 4,
  };
  // float steering_wheel_angle = 1;
  void clear_steering_wheel_angle();
  float steering_wheel_angle() const;
  void set_steering_wheel_angle(float value);
  private:
  float _internal_steering_wheel_angle() const;
  void _internal_set_steering_wheel_angle(float value);
  public:

  // float steering_wheel_speed = 2;
  void clear_steering_wheel_speed();
  float steering_wheel_speed() const;
  void set_steering_wheel_speed(float value);
  private:
  float _internal_steering_wheel_speed() const;
  void _internal_set_steering_wheel_speed(float value);
  public:

  // float left_directive_wheel_angle = 3;
  void clear_left_directive_wheel_angle();
  float left_directive_wheel_angle() const;
  void set_left_directive_wheel_angle(float value);
  private:
  float _internal_left_directive_wheel_angle() const;
  void _internal_set_left_directive_wheel_angle(float value);
  public:

  // float right_directive_wheel_angle = 4;
  void clear_right_directive_wheel_angle();
  float right_directive_wheel_angle() const;
  void set_right_directive_wheel_angle(float value);
  private:
  float _internal_right_directive_wheel_angle() const;
  void _internal_set_right_directive_wheel_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.SteeringFeedback)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float steering_wheel_angle_;
  float steering_wheel_speed_;
  float left_directive_wheel_angle_;
  float right_directive_wheel_angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class GearControl :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.GearControl) */ {
 public:
  GearControl();
  virtual ~GearControl();

  GearControl(const GearControl& from);
  GearControl(GearControl&& from) noexcept
    : GearControl() {
    *this = ::std::move(from);
  }

  inline GearControl& operator=(const GearControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline GearControl& operator=(GearControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GearControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GearControl* internal_default_instance() {
    return reinterpret_cast<const GearControl*>(
               &_GearControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GearControl& a, GearControl& b) {
    a.Swap(&b);
  }
  inline void Swap(GearControl* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GearControl* New() const final {
    return CreateMaybeMessage<GearControl>(nullptr);
  }

  GearControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GearControl>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GearControl& from);
  void MergeFrom(const GearControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GearControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.GearControl";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGearModeFieldNumber = 1,
    kTargetGearPositionFieldNumber = 2,
    kParkingFieldNumber = 3,
    kClutchPedalAngleFieldNumber = 4,
  };
  // .vts.protocol.chassis.GearControlMode gear_mode = 1;
  void clear_gear_mode();
  ::vts::protocol::chassis::GearControlMode gear_mode() const;
  void set_gear_mode(::vts::protocol::chassis::GearControlMode value);
  private:
  ::vts::protocol::chassis::GearControlMode _internal_gear_mode() const;
  void _internal_set_gear_mode(::vts::protocol::chassis::GearControlMode value);
  public:

  // int32 target_gear_position = 2;
  void clear_target_gear_position();
  ::PROTOBUF_NAMESPACE_ID::int32 target_gear_position() const;
  void set_target_gear_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_target_gear_position() const;
  void _internal_set_target_gear_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool parking = 3;
  void clear_parking();
  bool parking() const;
  void set_parking(bool value);
  private:
  bool _internal_parking() const;
  void _internal_set_parking(bool value);
  public:

  // float clutch_pedal_angle = 4;
  void clear_clutch_pedal_angle();
  float clutch_pedal_angle() const;
  void set_clutch_pedal_angle(float value);
  private:
  float _internal_clutch_pedal_angle() const;
  void _internal_set_clutch_pedal_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.GearControl)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int gear_mode_;
  ::PROTOBUF_NAMESPACE_ID::int32 target_gear_position_;
  bool parking_;
  float clutch_pedal_angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class GearFeedback :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.GearFeedback) */ {
 public:
  GearFeedback();
  virtual ~GearFeedback();

  GearFeedback(const GearFeedback& from);
  GearFeedback(GearFeedback&& from) noexcept
    : GearFeedback() {
    *this = ::std::move(from);
  }

  inline GearFeedback& operator=(const GearFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline GearFeedback& operator=(GearFeedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GearFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GearFeedback* internal_default_instance() {
    return reinterpret_cast<const GearFeedback*>(
               &_GearFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GearFeedback& a, GearFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(GearFeedback* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GearFeedback* New() const final {
    return CreateMaybeMessage<GearFeedback>(nullptr);
  }

  GearFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GearFeedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GearFeedback& from);
  void MergeFrom(const GearFeedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GearFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.GearFeedback";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGearModeFieldNumber = 1,
    kCurrentGearPositionFieldNumber = 2,
    kHandBrakeFieldNumber = 3,
  };
  // .vts.protocol.chassis.GearControlMode gear_mode = 1;
  void clear_gear_mode();
  ::vts::protocol::chassis::GearControlMode gear_mode() const;
  void set_gear_mode(::vts::protocol::chassis::GearControlMode value);
  private:
  ::vts::protocol::chassis::GearControlMode _internal_gear_mode() const;
  void _internal_set_gear_mode(::vts::protocol::chassis::GearControlMode value);
  public:

  // int32 current_gear_position = 2;
  void clear_current_gear_position();
  ::PROTOBUF_NAMESPACE_ID::int32 current_gear_position() const;
  void set_current_gear_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_current_gear_position() const;
  void _internal_set_current_gear_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool hand_brake = 3;
  void clear_hand_brake();
  bool hand_brake() const;
  void set_hand_brake(bool value);
  private:
  bool _internal_hand_brake() const;
  void _internal_set_hand_brake(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.GearFeedback)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int gear_mode_;
  ::PROTOBUF_NAMESPACE_ID::int32 current_gear_position_;
  bool hand_brake_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class DrivingControl :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.DrivingControl) */ {
 public:
  DrivingControl();
  virtual ~DrivingControl();

  DrivingControl(const DrivingControl& from);
  DrivingControl(DrivingControl&& from) noexcept
    : DrivingControl() {
    *this = ::std::move(from);
  }

  inline DrivingControl& operator=(const DrivingControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrivingControl& operator=(DrivingControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DrivingControl& default_instance();

  enum CmdValueCase {
    kTargetAcceleratorPedalPosition = 1,
    kActualAcceleratorPedalPosition = 2,
    CMD_VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DrivingControl* internal_default_instance() {
    return reinterpret_cast<const DrivingControl*>(
               &_DrivingControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DrivingControl& a, DrivingControl& b) {
    a.Swap(&b);
  }
  inline void Swap(DrivingControl* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DrivingControl* New() const final {
    return CreateMaybeMessage<DrivingControl>(nullptr);
  }

  DrivingControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DrivingControl>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DrivingControl& from);
  void MergeFrom(const DrivingControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrivingControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.DrivingControl";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGearControlFieldNumber = 7,
    kTargetAcceleratorPedalPositionFieldNumber = 1,
    kActualAcceleratorPedalPositionFieldNumber = 2,
  };
  // .vts.protocol.chassis.GearControl gear_control = 7;
  bool has_gear_control() const;
  private:
  bool _internal_has_gear_control() const;
  public:
  void clear_gear_control();
  const ::vts::protocol::chassis::GearControl& gear_control() const;
  ::vts::protocol::chassis::GearControl* release_gear_control();
  ::vts::protocol::chassis::GearControl* mutable_gear_control();
  void set_allocated_gear_control(::vts::protocol::chassis::GearControl* gear_control);
  private:
  const ::vts::protocol::chassis::GearControl& _internal_gear_control() const;
  ::vts::protocol::chassis::GearControl* _internal_mutable_gear_control();
  public:

  // float target_accelerator_pedal_position = 1;
  private:
  bool _internal_has_target_accelerator_pedal_position() const;
  public:
  void clear_target_accelerator_pedal_position();
  float target_accelerator_pedal_position() const;
  void set_target_accelerator_pedal_position(float value);
  private:
  float _internal_target_accelerator_pedal_position() const;
  void _internal_set_target_accelerator_pedal_position(float value);
  public:

  // float actual_accelerator_pedal_position = 2;
  private:
  bool _internal_has_actual_accelerator_pedal_position() const;
  public:
  void clear_actual_accelerator_pedal_position();
  float actual_accelerator_pedal_position() const;
  void set_actual_accelerator_pedal_position(float value);
  private:
  float _internal_actual_accelerator_pedal_position() const;
  void _internal_set_actual_accelerator_pedal_position(float value);
  public:

  void clear_cmd_value();
  CmdValueCase cmd_value_case() const;
  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.DrivingControl)
 private:
  class _Internal;
  void set_has_target_accelerator_pedal_position();
  void set_has_actual_accelerator_pedal_position();

  inline bool has_cmd_value() const;
  inline void clear_has_cmd_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::vts::protocol::chassis::GearControl* gear_control_;
  union CmdValueUnion {
    CmdValueUnion() {}
    float target_accelerator_pedal_position_;
    float actual_accelerator_pedal_position_;
  } cmd_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class DrivingFeedback :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.DrivingFeedback) */ {
 public:
  DrivingFeedback();
  virtual ~DrivingFeedback();

  DrivingFeedback(const DrivingFeedback& from);
  DrivingFeedback(DrivingFeedback&& from) noexcept
    : DrivingFeedback() {
    *this = ::std::move(from);
  }

  inline DrivingFeedback& operator=(const DrivingFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrivingFeedback& operator=(DrivingFeedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DrivingFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DrivingFeedback* internal_default_instance() {
    return reinterpret_cast<const DrivingFeedback*>(
               &_DrivingFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DrivingFeedback& a, DrivingFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(DrivingFeedback* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DrivingFeedback* New() const final {
    return CreateMaybeMessage<DrivingFeedback>(nullptr);
  }

  DrivingFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DrivingFeedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DrivingFeedback& from);
  void MergeFrom(const DrivingFeedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrivingFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.DrivingFeedback";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrivingModeFieldNumber = 1,
    kAcceleratorPedalPositionFieldNumber = 2,
    kEngineRpmFieldNumber = 3,
  };
  // .vts.protocol.chassis.DrivingMode driving_Mode = 1;
  void clear_driving_mode();
  ::vts::protocol::chassis::DrivingMode driving_mode() const;
  void set_driving_mode(::vts::protocol::chassis::DrivingMode value);
  private:
  ::vts::protocol::chassis::DrivingMode _internal_driving_mode() const;
  void _internal_set_driving_mode(::vts::protocol::chassis::DrivingMode value);
  public:

  // float accelerator_pedal_position = 2;
  void clear_accelerator_pedal_position();
  float accelerator_pedal_position() const;
  void set_accelerator_pedal_position(float value);
  private:
  float _internal_accelerator_pedal_position() const;
  void _internal_set_accelerator_pedal_position(float value);
  public:

  // float engine_rpm = 3;
  void clear_engine_rpm();
  float engine_rpm() const;
  void set_engine_rpm(float value);
  private:
  float _internal_engine_rpm() const;
  void _internal_set_engine_rpm(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.DrivingFeedback)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int driving_mode_;
  float accelerator_pedal_position_;
  float engine_rpm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class BrakeControl :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.BrakeControl) */ {
 public:
  BrakeControl();
  virtual ~BrakeControl();

  BrakeControl(const BrakeControl& from);
  BrakeControl(BrakeControl&& from) noexcept
    : BrakeControl() {
    *this = ::std::move(from);
  }

  inline BrakeControl& operator=(const BrakeControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrakeControl& operator=(BrakeControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BrakeControl& default_instance();

  enum CmdValueCase {
    kTargetBrakePedalPosition = 1,
    kActualBrakePedalPosition = 2,
    CMD_VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BrakeControl* internal_default_instance() {
    return reinterpret_cast<const BrakeControl*>(
               &_BrakeControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BrakeControl& a, BrakeControl& b) {
    a.Swap(&b);
  }
  inline void Swap(BrakeControl* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BrakeControl* New() const final {
    return CreateMaybeMessage<BrakeControl>(nullptr);
  }

  BrakeControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BrakeControl>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BrakeControl& from);
  void MergeFrom(const BrakeControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrakeControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.BrakeControl";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetBrakePedalPositionFieldNumber = 1,
    kActualBrakePedalPositionFieldNumber = 2,
  };
  // float target_brake_pedal_position = 1;
  private:
  bool _internal_has_target_brake_pedal_position() const;
  public:
  void clear_target_brake_pedal_position();
  float target_brake_pedal_position() const;
  void set_target_brake_pedal_position(float value);
  private:
  float _internal_target_brake_pedal_position() const;
  void _internal_set_target_brake_pedal_position(float value);
  public:

  // float actual_brake_pedal_position = 2;
  private:
  bool _internal_has_actual_brake_pedal_position() const;
  public:
  void clear_actual_brake_pedal_position();
  float actual_brake_pedal_position() const;
  void set_actual_brake_pedal_position(float value);
  private:
  float _internal_actual_brake_pedal_position() const;
  void _internal_set_actual_brake_pedal_position(float value);
  public:

  void clear_cmd_value();
  CmdValueCase cmd_value_case() const;
  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.BrakeControl)
 private:
  class _Internal;
  void set_has_target_brake_pedal_position();
  void set_has_actual_brake_pedal_position();

  inline bool has_cmd_value() const;
  inline void clear_has_cmd_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union CmdValueUnion {
    CmdValueUnion() {}
    float target_brake_pedal_position_;
    float actual_brake_pedal_position_;
  } cmd_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class BrakeFeedback :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.BrakeFeedback) */ {
 public:
  BrakeFeedback();
  virtual ~BrakeFeedback();

  BrakeFeedback(const BrakeFeedback& from);
  BrakeFeedback(BrakeFeedback&& from) noexcept
    : BrakeFeedback() {
    *this = ::std::move(from);
  }

  inline BrakeFeedback& operator=(const BrakeFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrakeFeedback& operator=(BrakeFeedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BrakeFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BrakeFeedback* internal_default_instance() {
    return reinterpret_cast<const BrakeFeedback*>(
               &_BrakeFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BrakeFeedback& a, BrakeFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(BrakeFeedback* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BrakeFeedback* New() const final {
    return CreateMaybeMessage<BrakeFeedback>(nullptr);
  }

  BrakeFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BrakeFeedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BrakeFeedback& from);
  void MergeFrom(const BrakeFeedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrakeFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.BrakeFeedback";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrivingModeFieldNumber = 1,
    kBrakePedalPositionFieldNumber = 2,
  };
  // .vts.protocol.chassis.DrivingMode driving_mode = 1;
  void clear_driving_mode();
  ::vts::protocol::chassis::DrivingMode driving_mode() const;
  void set_driving_mode(::vts::protocol::chassis::DrivingMode value);
  private:
  ::vts::protocol::chassis::DrivingMode _internal_driving_mode() const;
  void _internal_set_driving_mode(::vts::protocol::chassis::DrivingMode value);
  public:

  // float brake_pedal_position = 2;
  void clear_brake_pedal_position();
  float brake_pedal_position() const;
  void set_brake_pedal_position(float value);
  private:
  float _internal_brake_pedal_position() const;
  void _internal_set_brake_pedal_position(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.BrakeFeedback)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int driving_mode_;
  float brake_pedal_position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class BodyControlModule :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.BodyControlModule) */ {
 public:
  BodyControlModule();
  virtual ~BodyControlModule();

  BodyControlModule(const BodyControlModule& from);
  BodyControlModule(BodyControlModule&& from) noexcept
    : BodyControlModule() {
    *this = ::std::move(from);
  }

  inline BodyControlModule& operator=(const BodyControlModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline BodyControlModule& operator=(BodyControlModule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BodyControlModule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BodyControlModule* internal_default_instance() {
    return reinterpret_cast<const BodyControlModule*>(
               &_BodyControlModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BodyControlModule& a, BodyControlModule& b) {
    a.Swap(&b);
  }
  inline void Swap(BodyControlModule* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BodyControlModule* New() const final {
    return CreateMaybeMessage<BodyControlModule>(nullptr);
  }

  BodyControlModule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BodyControlModule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BodyControlModule& from);
  void MergeFrom(const BodyControlModule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BodyControlModule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.BodyControlModule";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftTurnLightFieldNumber = 1,
    kRightTurnLightFieldNumber = 2,
    kLowBeamFieldNumber = 3,
    kHighBeamFieldNumber = 4,
    kFrontFogLightFieldNumber = 5,
    kRearFogLightFieldNumber = 6,
    kHazardWarningLightFieldNumber = 7,
    kHornFieldNumber = 9,
    kWiperFieldNumber = 8,
    kAutoBeamFieldNumber = 10,
    kAutoWiperFieldNumber = 11,
    kEndOutlineMarkerLampsFieldNumber = 12,
  };
  // bool left_turn_light = 1;
  void clear_left_turn_light();
  bool left_turn_light() const;
  void set_left_turn_light(bool value);
  private:
  bool _internal_left_turn_light() const;
  void _internal_set_left_turn_light(bool value);
  public:

  // bool right_turn_light = 2;
  void clear_right_turn_light();
  bool right_turn_light() const;
  void set_right_turn_light(bool value);
  private:
  bool _internal_right_turn_light() const;
  void _internal_set_right_turn_light(bool value);
  public:

  // bool low_beam = 3;
  void clear_low_beam();
  bool low_beam() const;
  void set_low_beam(bool value);
  private:
  bool _internal_low_beam() const;
  void _internal_set_low_beam(bool value);
  public:

  // bool high_beam = 4;
  void clear_high_beam();
  bool high_beam() const;
  void set_high_beam(bool value);
  private:
  bool _internal_high_beam() const;
  void _internal_set_high_beam(bool value);
  public:

  // bool front_fog_light = 5;
  void clear_front_fog_light();
  bool front_fog_light() const;
  void set_front_fog_light(bool value);
  private:
  bool _internal_front_fog_light() const;
  void _internal_set_front_fog_light(bool value);
  public:

  // bool rear_fog_light = 6;
  void clear_rear_fog_light();
  bool rear_fog_light() const;
  void set_rear_fog_light(bool value);
  private:
  bool _internal_rear_fog_light() const;
  void _internal_set_rear_fog_light(bool value);
  public:

  // bool hazard_warning_light = 7;
  void clear_hazard_warning_light();
  bool hazard_warning_light() const;
  void set_hazard_warning_light(bool value);
  private:
  bool _internal_hazard_warning_light() const;
  void _internal_set_hazard_warning_light(bool value);
  public:

  // bool horn = 9;
  void clear_horn();
  bool horn() const;
  void set_horn(bool value);
  private:
  bool _internal_horn() const;
  void _internal_set_horn(bool value);
  public:

  // int32 wiper = 8;
  void clear_wiper();
  ::PROTOBUF_NAMESPACE_ID::int32 wiper() const;
  void set_wiper(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wiper() const;
  void _internal_set_wiper(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool auto_beam = 10;
  void clear_auto_beam();
  bool auto_beam() const;
  void set_auto_beam(bool value);
  private:
  bool _internal_auto_beam() const;
  void _internal_set_auto_beam(bool value);
  public:

  // bool auto_wiper = 11;
  void clear_auto_wiper();
  bool auto_wiper() const;
  void set_auto_wiper(bool value);
  private:
  bool _internal_auto_wiper() const;
  void _internal_set_auto_wiper(bool value);
  public:

  // bool end_outline_marker_lamps = 12;
  void clear_end_outline_marker_lamps();
  bool end_outline_marker_lamps() const;
  void set_end_outline_marker_lamps(bool value);
  private:
  bool _internal_end_outline_marker_lamps() const;
  void _internal_set_end_outline_marker_lamps(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.BodyControlModule)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool left_turn_light_;
  bool right_turn_light_;
  bool low_beam_;
  bool high_beam_;
  bool front_fog_light_;
  bool rear_fog_light_;
  bool hazard_warning_light_;
  bool horn_;
  ::PROTOBUF_NAMESPACE_ID::int32 wiper_;
  bool auto_beam_;
  bool auto_wiper_;
  bool end_outline_marker_lamps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class BodyControlModuleFeedback :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.BodyControlModuleFeedback) */ {
 public:
  BodyControlModuleFeedback();
  virtual ~BodyControlModuleFeedback();

  BodyControlModuleFeedback(const BodyControlModuleFeedback& from);
  BodyControlModuleFeedback(BodyControlModuleFeedback&& from) noexcept
    : BodyControlModuleFeedback() {
    *this = ::std::move(from);
  }

  inline BodyControlModuleFeedback& operator=(const BodyControlModuleFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline BodyControlModuleFeedback& operator=(BodyControlModuleFeedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BodyControlModuleFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BodyControlModuleFeedback* internal_default_instance() {
    return reinterpret_cast<const BodyControlModuleFeedback*>(
               &_BodyControlModuleFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BodyControlModuleFeedback& a, BodyControlModuleFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(BodyControlModuleFeedback* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BodyControlModuleFeedback* New() const final {
    return CreateMaybeMessage<BodyControlModuleFeedback>(nullptr);
  }

  BodyControlModuleFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BodyControlModuleFeedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BodyControlModuleFeedback& from);
  void MergeFrom(const BodyControlModuleFeedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BodyControlModuleFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.BodyControlModuleFeedback";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudinalAccelerationFieldNumber = 1,
    kVehicleSpeedFieldNumber = 2,
    kFrontLeftWheelSpeedFieldNumber = 3,
    kFronRightWheelSpeedFieldNumber = 4,
    kRearLeftWheelSpeedFieldNumber = 5,
    kRearRightWheelSpeedFieldNumber = 6,
    kLeftTurnLightStateFieldNumber = 7,
    kRightTurnLightStateFieldNumber = 8,
    kLowBeamStateFieldNumber = 9,
    kHighBeamStateFieldNumber = 10,
    kFrontFogLightStateFieldNumber = 11,
    kRearFogLightStateFieldNumber = 12,
    kHazardWarnningLightStateFieldNumber = 13,
    kHornStateFieldNumber = 15,
    kWiperStateFieldNumber = 14,
    kAutoBeamStateFieldNumber = 16,
    kAutoWiperStateFieldNumber = 17,
    kBrakeLightStateFieldNumber = 18,
    kEndOutlineMarkerLampsStateFieldNumber = 19,
    kStopLampsStateFieldNumber = 20,
    kReversingLampsStateFieldNumber = 21,
    kFrontLeftDoorAngleFieldNumber = 22,
    kFrontRightDoorAngleFieldNumber = 23,
    kRearLeftDoorAngleFieldNumber = 24,
    kRearRightDoorAngleFieldNumber = 25,
    kVehicleBootAngleFieldNumber = 26,
    kVehicleBonnetAngleFieldNumber = 27,
  };
  // float longitudinal_acceleration = 1;
  void clear_longitudinal_acceleration();
  float longitudinal_acceleration() const;
  void set_longitudinal_acceleration(float value);
  private:
  float _internal_longitudinal_acceleration() const;
  void _internal_set_longitudinal_acceleration(float value);
  public:

  // float vehicle_speed = 2;
  void clear_vehicle_speed();
  float vehicle_speed() const;
  void set_vehicle_speed(float value);
  private:
  float _internal_vehicle_speed() const;
  void _internal_set_vehicle_speed(float value);
  public:

  // float front_left_wheel_speed = 3;
  void clear_front_left_wheel_speed();
  float front_left_wheel_speed() const;
  void set_front_left_wheel_speed(float value);
  private:
  float _internal_front_left_wheel_speed() const;
  void _internal_set_front_left_wheel_speed(float value);
  public:

  // float fron_right_wheel_speed = 4;
  void clear_fron_right_wheel_speed();
  float fron_right_wheel_speed() const;
  void set_fron_right_wheel_speed(float value);
  private:
  float _internal_fron_right_wheel_speed() const;
  void _internal_set_fron_right_wheel_speed(float value);
  public:

  // float rear_left_wheel_speed = 5;
  void clear_rear_left_wheel_speed();
  float rear_left_wheel_speed() const;
  void set_rear_left_wheel_speed(float value);
  private:
  float _internal_rear_left_wheel_speed() const;
  void _internal_set_rear_left_wheel_speed(float value);
  public:

  // float rear_right_wheel_speed = 6;
  void clear_rear_right_wheel_speed();
  float rear_right_wheel_speed() const;
  void set_rear_right_wheel_speed(float value);
  private:
  float _internal_rear_right_wheel_speed() const;
  void _internal_set_rear_right_wheel_speed(float value);
  public:

  // bool left_turn_light_state = 7;
  void clear_left_turn_light_state();
  bool left_turn_light_state() const;
  void set_left_turn_light_state(bool value);
  private:
  bool _internal_left_turn_light_state() const;
  void _internal_set_left_turn_light_state(bool value);
  public:

  // bool right_turn_light_state = 8;
  void clear_right_turn_light_state();
  bool right_turn_light_state() const;
  void set_right_turn_light_state(bool value);
  private:
  bool _internal_right_turn_light_state() const;
  void _internal_set_right_turn_light_state(bool value);
  public:

  // bool low_beam_state = 9;
  void clear_low_beam_state();
  bool low_beam_state() const;
  void set_low_beam_state(bool value);
  private:
  bool _internal_low_beam_state() const;
  void _internal_set_low_beam_state(bool value);
  public:

  // bool high_beam_state = 10;
  void clear_high_beam_state();
  bool high_beam_state() const;
  void set_high_beam_state(bool value);
  private:
  bool _internal_high_beam_state() const;
  void _internal_set_high_beam_state(bool value);
  public:

  // bool front_fog_light_state = 11;
  void clear_front_fog_light_state();
  bool front_fog_light_state() const;
  void set_front_fog_light_state(bool value);
  private:
  bool _internal_front_fog_light_state() const;
  void _internal_set_front_fog_light_state(bool value);
  public:

  // bool rear_fog_light_state = 12;
  void clear_rear_fog_light_state();
  bool rear_fog_light_state() const;
  void set_rear_fog_light_state(bool value);
  private:
  bool _internal_rear_fog_light_state() const;
  void _internal_set_rear_fog_light_state(bool value);
  public:

  // bool hazard_warnning_light_state = 13;
  void clear_hazard_warnning_light_state();
  bool hazard_warnning_light_state() const;
  void set_hazard_warnning_light_state(bool value);
  private:
  bool _internal_hazard_warnning_light_state() const;
  void _internal_set_hazard_warnning_light_state(bool value);
  public:

  // bool horn_state = 15;
  void clear_horn_state();
  bool horn_state() const;
  void set_horn_state(bool value);
  private:
  bool _internal_horn_state() const;
  void _internal_set_horn_state(bool value);
  public:

  // int32 wiper_state = 14;
  void clear_wiper_state();
  ::PROTOBUF_NAMESPACE_ID::int32 wiper_state() const;
  void set_wiper_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wiper_state() const;
  void _internal_set_wiper_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool auto_beam_state = 16;
  void clear_auto_beam_state();
  bool auto_beam_state() const;
  void set_auto_beam_state(bool value);
  private:
  bool _internal_auto_beam_state() const;
  void _internal_set_auto_beam_state(bool value);
  public:

  // bool auto_wiper_state = 17;
  void clear_auto_wiper_state();
  bool auto_wiper_state() const;
  void set_auto_wiper_state(bool value);
  private:
  bool _internal_auto_wiper_state() const;
  void _internal_set_auto_wiper_state(bool value);
  public:

  // bool brake_light_state = 18;
  void clear_brake_light_state();
  bool brake_light_state() const;
  void set_brake_light_state(bool value);
  private:
  bool _internal_brake_light_state() const;
  void _internal_set_brake_light_state(bool value);
  public:

  // bool end_outline_marker_lamps_state = 19;
  void clear_end_outline_marker_lamps_state();
  bool end_outline_marker_lamps_state() const;
  void set_end_outline_marker_lamps_state(bool value);
  private:
  bool _internal_end_outline_marker_lamps_state() const;
  void _internal_set_end_outline_marker_lamps_state(bool value);
  public:

  // bool stop_lamps_state = 20;
  void clear_stop_lamps_state();
  bool stop_lamps_state() const;
  void set_stop_lamps_state(bool value);
  private:
  bool _internal_stop_lamps_state() const;
  void _internal_set_stop_lamps_state(bool value);
  public:

  // bool reversing_lamps_state = 21;
  void clear_reversing_lamps_state();
  bool reversing_lamps_state() const;
  void set_reversing_lamps_state(bool value);
  private:
  bool _internal_reversing_lamps_state() const;
  void _internal_set_reversing_lamps_state(bool value);
  public:

  // float front_left_door_angle = 22;
  void clear_front_left_door_angle();
  float front_left_door_angle() const;
  void set_front_left_door_angle(float value);
  private:
  float _internal_front_left_door_angle() const;
  void _internal_set_front_left_door_angle(float value);
  public:

  // float front_right_door_angle = 23;
  void clear_front_right_door_angle();
  float front_right_door_angle() const;
  void set_front_right_door_angle(float value);
  private:
  float _internal_front_right_door_angle() const;
  void _internal_set_front_right_door_angle(float value);
  public:

  // float rear_left_door_angle = 24;
  void clear_rear_left_door_angle();
  float rear_left_door_angle() const;
  void set_rear_left_door_angle(float value);
  private:
  float _internal_rear_left_door_angle() const;
  void _internal_set_rear_left_door_angle(float value);
  public:

  // float rear_right_door_angle = 25;
  void clear_rear_right_door_angle();
  float rear_right_door_angle() const;
  void set_rear_right_door_angle(float value);
  private:
  float _internal_rear_right_door_angle() const;
  void _internal_set_rear_right_door_angle(float value);
  public:

  // float vehicle_boot_angle = 26;
  void clear_vehicle_boot_angle();
  float vehicle_boot_angle() const;
  void set_vehicle_boot_angle(float value);
  private:
  float _internal_vehicle_boot_angle() const;
  void _internal_set_vehicle_boot_angle(float value);
  public:

  // float vehicle_bonnet_angle = 27;
  void clear_vehicle_bonnet_angle();
  float vehicle_bonnet_angle() const;
  void set_vehicle_bonnet_angle(float value);
  private:
  float _internal_vehicle_bonnet_angle() const;
  void _internal_set_vehicle_bonnet_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.BodyControlModuleFeedback)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float longitudinal_acceleration_;
  float vehicle_speed_;
  float front_left_wheel_speed_;
  float fron_right_wheel_speed_;
  float rear_left_wheel_speed_;
  float rear_right_wheel_speed_;
  bool left_turn_light_state_;
  bool right_turn_light_state_;
  bool low_beam_state_;
  bool high_beam_state_;
  bool front_fog_light_state_;
  bool rear_fog_light_state_;
  bool hazard_warnning_light_state_;
  bool horn_state_;
  ::PROTOBUF_NAMESPACE_ID::int32 wiper_state_;
  bool auto_beam_state_;
  bool auto_wiper_state_;
  bool brake_light_state_;
  bool end_outline_marker_lamps_state_;
  bool stop_lamps_state_;
  bool reversing_lamps_state_;
  float front_left_door_angle_;
  float front_right_door_angle_;
  float rear_left_door_angle_;
  float rear_right_door_angle_;
  float vehicle_boot_angle_;
  float vehicle_bonnet_angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class VehicleControl :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.VehicleControl) */ {
 public:
  VehicleControl();
  virtual ~VehicleControl();

  VehicleControl(const VehicleControl& from);
  VehicleControl(VehicleControl&& from) noexcept
    : VehicleControl() {
    *this = ::std::move(from);
  }

  inline VehicleControl& operator=(const VehicleControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleControl& operator=(VehicleControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleControl* internal_default_instance() {
    return reinterpret_cast<const VehicleControl*>(
               &_VehicleControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VehicleControl& a, VehicleControl& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleControl* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleControl* New() const final {
    return CreateMaybeMessage<VehicleControl>(nullptr);
  }

  VehicleControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleControl>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleControl& from);
  void MergeFrom(const VehicleControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.VehicleControl";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSteeringControlFieldNumber = 2,
    kDrivingControlFieldNumber = 3,
    kBrakeControlFieldNumber = 4,
    kBcmFieldNumber = 5,
  };
  // .vts.protocol.main.SimHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::vts::protocol::main::SimHeader& header() const;
  ::vts::protocol::main::SimHeader* release_header();
  ::vts::protocol::main::SimHeader* mutable_header();
  void set_allocated_header(::vts::protocol::main::SimHeader* header);
  private:
  const ::vts::protocol::main::SimHeader& _internal_header() const;
  ::vts::protocol::main::SimHeader* _internal_mutable_header();
  public:

  // .vts.protocol.chassis.SteeringControl steering_control = 2;
  bool has_steering_control() const;
  private:
  bool _internal_has_steering_control() const;
  public:
  void clear_steering_control();
  const ::vts::protocol::chassis::SteeringControl& steering_control() const;
  ::vts::protocol::chassis::SteeringControl* release_steering_control();
  ::vts::protocol::chassis::SteeringControl* mutable_steering_control();
  void set_allocated_steering_control(::vts::protocol::chassis::SteeringControl* steering_control);
  private:
  const ::vts::protocol::chassis::SteeringControl& _internal_steering_control() const;
  ::vts::protocol::chassis::SteeringControl* _internal_mutable_steering_control();
  public:

  // .vts.protocol.chassis.DrivingControl driving_control = 3;
  bool has_driving_control() const;
  private:
  bool _internal_has_driving_control() const;
  public:
  void clear_driving_control();
  const ::vts::protocol::chassis::DrivingControl& driving_control() const;
  ::vts::protocol::chassis::DrivingControl* release_driving_control();
  ::vts::protocol::chassis::DrivingControl* mutable_driving_control();
  void set_allocated_driving_control(::vts::protocol::chassis::DrivingControl* driving_control);
  private:
  const ::vts::protocol::chassis::DrivingControl& _internal_driving_control() const;
  ::vts::protocol::chassis::DrivingControl* _internal_mutable_driving_control();
  public:

  // .vts.protocol.chassis.BrakeControl brake_control = 4;
  bool has_brake_control() const;
  private:
  bool _internal_has_brake_control() const;
  public:
  void clear_brake_control();
  const ::vts::protocol::chassis::BrakeControl& brake_control() const;
  ::vts::protocol::chassis::BrakeControl* release_brake_control();
  ::vts::protocol::chassis::BrakeControl* mutable_brake_control();
  void set_allocated_brake_control(::vts::protocol::chassis::BrakeControl* brake_control);
  private:
  const ::vts::protocol::chassis::BrakeControl& _internal_brake_control() const;
  ::vts::protocol::chassis::BrakeControl* _internal_mutable_brake_control();
  public:

  // .vts.protocol.chassis.BodyControlModule bcm = 5;
  bool has_bcm() const;
  private:
  bool _internal_has_bcm() const;
  public:
  void clear_bcm();
  const ::vts::protocol::chassis::BodyControlModule& bcm() const;
  ::vts::protocol::chassis::BodyControlModule* release_bcm();
  ::vts::protocol::chassis::BodyControlModule* mutable_bcm();
  void set_allocated_bcm(::vts::protocol::chassis::BodyControlModule* bcm);
  private:
  const ::vts::protocol::chassis::BodyControlModule& _internal_bcm() const;
  ::vts::protocol::chassis::BodyControlModule* _internal_mutable_bcm();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.VehicleControl)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::vts::protocol::main::SimHeader* header_;
  ::vts::protocol::chassis::SteeringControl* steering_control_;
  ::vts::protocol::chassis::DrivingControl* driving_control_;
  ::vts::protocol::chassis::BrakeControl* brake_control_;
  ::vts::protocol::chassis::BodyControlModule* bcm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class VehicleFeedback :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.VehicleFeedback) */ {
 public:
  VehicleFeedback();
  virtual ~VehicleFeedback();

  VehicleFeedback(const VehicleFeedback& from);
  VehicleFeedback(VehicleFeedback&& from) noexcept
    : VehicleFeedback() {
    *this = ::std::move(from);
  }

  inline VehicleFeedback& operator=(const VehicleFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleFeedback& operator=(VehicleFeedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleFeedback* internal_default_instance() {
    return reinterpret_cast<const VehicleFeedback*>(
               &_VehicleFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VehicleFeedback& a, VehicleFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleFeedback* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleFeedback* New() const final {
    return CreateMaybeMessage<VehicleFeedback>(nullptr);
  }

  VehicleFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleFeedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleFeedback& from);
  void MergeFrom(const VehicleFeedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.VehicleFeedback";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSteeringFeedbackFieldNumber = 3,
    kDrivingFeedbackFieldNumber = 4,
    kBrakeFeedbackFieldNumber = 5,
    kGearFeedbackFieldNumber = 6,
    kBcmFeedbackFieldNumber = 7,
    kErrorFieldNumber = 2,
  };
  // .vts.protocol.main.SimHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::vts::protocol::main::SimHeader& header() const;
  ::vts::protocol::main::SimHeader* release_header();
  ::vts::protocol::main::SimHeader* mutable_header();
  void set_allocated_header(::vts::protocol::main::SimHeader* header);
  private:
  const ::vts::protocol::main::SimHeader& _internal_header() const;
  ::vts::protocol::main::SimHeader* _internal_mutable_header();
  public:

  // .vts.protocol.chassis.SteeringFeedback steering_feedback = 3;
  bool has_steering_feedback() const;
  private:
  bool _internal_has_steering_feedback() const;
  public:
  void clear_steering_feedback();
  const ::vts::protocol::chassis::SteeringFeedback& steering_feedback() const;
  ::vts::protocol::chassis::SteeringFeedback* release_steering_feedback();
  ::vts::protocol::chassis::SteeringFeedback* mutable_steering_feedback();
  void set_allocated_steering_feedback(::vts::protocol::chassis::SteeringFeedback* steering_feedback);
  private:
  const ::vts::protocol::chassis::SteeringFeedback& _internal_steering_feedback() const;
  ::vts::protocol::chassis::SteeringFeedback* _internal_mutable_steering_feedback();
  public:

  // .vts.protocol.chassis.DrivingFeedback driving_feedback = 4;
  bool has_driving_feedback() const;
  private:
  bool _internal_has_driving_feedback() const;
  public:
  void clear_driving_feedback();
  const ::vts::protocol::chassis::DrivingFeedback& driving_feedback() const;
  ::vts::protocol::chassis::DrivingFeedback* release_driving_feedback();
  ::vts::protocol::chassis::DrivingFeedback* mutable_driving_feedback();
  void set_allocated_driving_feedback(::vts::protocol::chassis::DrivingFeedback* driving_feedback);
  private:
  const ::vts::protocol::chassis::DrivingFeedback& _internal_driving_feedback() const;
  ::vts::protocol::chassis::DrivingFeedback* _internal_mutable_driving_feedback();
  public:

  // .vts.protocol.chassis.BrakeFeedback brake_feedback = 5;
  bool has_brake_feedback() const;
  private:
  bool _internal_has_brake_feedback() const;
  public:
  void clear_brake_feedback();
  const ::vts::protocol::chassis::BrakeFeedback& brake_feedback() const;
  ::vts::protocol::chassis::BrakeFeedback* release_brake_feedback();
  ::vts::protocol::chassis::BrakeFeedback* mutable_brake_feedback();
  void set_allocated_brake_feedback(::vts::protocol::chassis::BrakeFeedback* brake_feedback);
  private:
  const ::vts::protocol::chassis::BrakeFeedback& _internal_brake_feedback() const;
  ::vts::protocol::chassis::BrakeFeedback* _internal_mutable_brake_feedback();
  public:

  // .vts.protocol.chassis.GearFeedback gear_feedback = 6;
  bool has_gear_feedback() const;
  private:
  bool _internal_has_gear_feedback() const;
  public:
  void clear_gear_feedback();
  const ::vts::protocol::chassis::GearFeedback& gear_feedback() const;
  ::vts::protocol::chassis::GearFeedback* release_gear_feedback();
  ::vts::protocol::chassis::GearFeedback* mutable_gear_feedback();
  void set_allocated_gear_feedback(::vts::protocol::chassis::GearFeedback* gear_feedback);
  private:
  const ::vts::protocol::chassis::GearFeedback& _internal_gear_feedback() const;
  ::vts::protocol::chassis::GearFeedback* _internal_mutable_gear_feedback();
  public:

  // .vts.protocol.chassis.BodyControlModuleFeedback bcm_feedback = 7;
  bool has_bcm_feedback() const;
  private:
  bool _internal_has_bcm_feedback() const;
  public:
  void clear_bcm_feedback();
  const ::vts::protocol::chassis::BodyControlModuleFeedback& bcm_feedback() const;
  ::vts::protocol::chassis::BodyControlModuleFeedback* release_bcm_feedback();
  ::vts::protocol::chassis::BodyControlModuleFeedback* mutable_bcm_feedback();
  void set_allocated_bcm_feedback(::vts::protocol::chassis::BodyControlModuleFeedback* bcm_feedback);
  private:
  const ::vts::protocol::chassis::BodyControlModuleFeedback& _internal_bcm_feedback() const;
  ::vts::protocol::chassis::BodyControlModuleFeedback* _internal_mutable_bcm_feedback();
  public:

  // .vts.protocol.chassis.VehicleError error = 2;
  void clear_error();
  ::vts::protocol::chassis::VehicleError error() const;
  void set_error(::vts::protocol::chassis::VehicleError value);
  private:
  ::vts::protocol::chassis::VehicleError _internal_error() const;
  void _internal_set_error(::vts::protocol::chassis::VehicleError value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.VehicleFeedback)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::vts::protocol::main::SimHeader* header_;
  ::vts::protocol::chassis::SteeringFeedback* steering_feedback_;
  ::vts::protocol::chassis::DrivingFeedback* driving_feedback_;
  ::vts::protocol::chassis::BrakeFeedback* brake_feedback_;
  ::vts::protocol::chassis::GearFeedback* gear_feedback_;
  ::vts::protocol::chassis::BodyControlModuleFeedback* bcm_feedback_;
  int error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class VehicleRegister :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.VehicleRegister) */ {
 public:
  VehicleRegister();
  virtual ~VehicleRegister();

  VehicleRegister(const VehicleRegister& from);
  VehicleRegister(VehicleRegister&& from) noexcept
    : VehicleRegister() {
    *this = ::std::move(from);
  }

  inline VehicleRegister& operator=(const VehicleRegister& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleRegister& operator=(VehicleRegister&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleRegister& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleRegister* internal_default_instance() {
    return reinterpret_cast<const VehicleRegister*>(
               &_VehicleRegister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VehicleRegister& a, VehicleRegister& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleRegister* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleRegister* New() const final {
    return CreateMaybeMessage<VehicleRegister>(nullptr);
  }

  VehicleRegister* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleRegister>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleRegister& from);
  void MergeFrom(const VehicleRegister& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleRegister* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.VehicleRegister";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSteeringControlModeFieldNumber = 2,
    kDrivingControlModeFieldNumber = 3,
    kBrakeModeFieldNumber = 4,
  };
  // .vts.protocol.main.SimHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::vts::protocol::main::SimHeader& header() const;
  ::vts::protocol::main::SimHeader* release_header();
  ::vts::protocol::main::SimHeader* mutable_header();
  void set_allocated_header(::vts::protocol::main::SimHeader* header);
  private:
  const ::vts::protocol::main::SimHeader& _internal_header() const;
  ::vts::protocol::main::SimHeader* _internal_mutable_header();
  public:

  // .vts.protocol.chassis.SteeringControlMode steering_control_mode = 2;
  void clear_steering_control_mode();
  ::vts::protocol::chassis::SteeringControlMode steering_control_mode() const;
  void set_steering_control_mode(::vts::protocol::chassis::SteeringControlMode value);
  private:
  ::vts::protocol::chassis::SteeringControlMode _internal_steering_control_mode() const;
  void _internal_set_steering_control_mode(::vts::protocol::chassis::SteeringControlMode value);
  public:

  // .vts.protocol.chassis.DrivingControlMode driving_control_mode = 3;
  void clear_driving_control_mode();
  ::vts::protocol::chassis::DrivingControlMode driving_control_mode() const;
  void set_driving_control_mode(::vts::protocol::chassis::DrivingControlMode value);
  private:
  ::vts::protocol::chassis::DrivingControlMode _internal_driving_control_mode() const;
  void _internal_set_driving_control_mode(::vts::protocol::chassis::DrivingControlMode value);
  public:

  // .vts.protocol.chassis.BrakeControlMode brake_mode = 4;
  void clear_brake_mode();
  ::vts::protocol::chassis::BrakeControlMode brake_mode() const;
  void set_brake_mode(::vts::protocol::chassis::BrakeControlMode value);
  private:
  ::vts::protocol::chassis::BrakeControlMode _internal_brake_mode() const;
  void _internal_set_brake_mode(::vts::protocol::chassis::BrakeControlMode value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.VehicleRegister)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::vts::protocol::main::SimHeader* header_;
  int steering_control_mode_;
  int driving_control_mode_;
  int brake_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class VehicleQuit :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.chassis.VehicleQuit) */ {
 public:
  VehicleQuit();
  virtual ~VehicleQuit();

  VehicleQuit(const VehicleQuit& from);
  VehicleQuit(VehicleQuit&& from) noexcept
    : VehicleQuit() {
    *this = ::std::move(from);
  }

  inline VehicleQuit& operator=(const VehicleQuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleQuit& operator=(VehicleQuit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleQuit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleQuit* internal_default_instance() {
    return reinterpret_cast<const VehicleQuit*>(
               &_VehicleQuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VehicleQuit& a, VehicleQuit& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleQuit* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleQuit* New() const final {
    return CreateMaybeMessage<VehicleQuit>(nullptr);
  }

  VehicleQuit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleQuit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleQuit& from);
  void MergeFrom(const VehicleQuit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleQuit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.chassis.VehicleQuit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_chassis_5fmessages_2eproto);
    return ::descriptor_table_chassis_5fmessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .vts.protocol.main.SimHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::vts::protocol::main::SimHeader& header() const;
  ::vts::protocol::main::SimHeader* release_header();
  ::vts::protocol::main::SimHeader* mutable_header();
  void set_allocated_header(::vts::protocol::main::SimHeader* header);
  private:
  const ::vts::protocol::main::SimHeader& _internal_header() const;
  ::vts::protocol::main::SimHeader* _internal_mutable_header();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.chassis.VehicleQuit)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::vts::protocol::main::SimHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chassis_5fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SteeringControl

// float target_steering_wheel_angle = 1;
inline bool SteeringControl::_internal_has_target_steering_wheel_angle() const {
  return cmd_value_case() == kTargetSteeringWheelAngle;
}
inline void SteeringControl::set_has_target_steering_wheel_angle() {
  _oneof_case_[0] = kTargetSteeringWheelAngle;
}
inline void SteeringControl::clear_target_steering_wheel_angle() {
  if (_internal_has_target_steering_wheel_angle()) {
    cmd_value_.target_steering_wheel_angle_ = 0;
    clear_has_cmd_value();
  }
}
inline float SteeringControl::_internal_target_steering_wheel_angle() const {
  if (_internal_has_target_steering_wheel_angle()) {
    return cmd_value_.target_steering_wheel_angle_;
  }
  return 0;
}
inline void SteeringControl::_internal_set_target_steering_wheel_angle(float value) {
  if (!_internal_has_target_steering_wheel_angle()) {
    clear_cmd_value();
    set_has_target_steering_wheel_angle();
  }
  cmd_value_.target_steering_wheel_angle_ = value;
}
inline float SteeringControl::target_steering_wheel_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.SteeringControl.target_steering_wheel_angle)
  return _internal_target_steering_wheel_angle();
}
inline void SteeringControl::set_target_steering_wheel_angle(float value) {
  _internal_set_target_steering_wheel_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.SteeringControl.target_steering_wheel_angle)
}

// float actual_steering_wheel_angle = 2;
inline bool SteeringControl::_internal_has_actual_steering_wheel_angle() const {
  return cmd_value_case() == kActualSteeringWheelAngle;
}
inline void SteeringControl::set_has_actual_steering_wheel_angle() {
  _oneof_case_[0] = kActualSteeringWheelAngle;
}
inline void SteeringControl::clear_actual_steering_wheel_angle() {
  if (_internal_has_actual_steering_wheel_angle()) {
    cmd_value_.actual_steering_wheel_angle_ = 0;
    clear_has_cmd_value();
  }
}
inline float SteeringControl::_internal_actual_steering_wheel_angle() const {
  if (_internal_has_actual_steering_wheel_angle()) {
    return cmd_value_.actual_steering_wheel_angle_;
  }
  return 0;
}
inline void SteeringControl::_internal_set_actual_steering_wheel_angle(float value) {
  if (!_internal_has_actual_steering_wheel_angle()) {
    clear_cmd_value();
    set_has_actual_steering_wheel_angle();
  }
  cmd_value_.actual_steering_wheel_angle_ = value;
}
inline float SteeringControl::actual_steering_wheel_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.SteeringControl.actual_steering_wheel_angle)
  return _internal_actual_steering_wheel_angle();
}
inline void SteeringControl::set_actual_steering_wheel_angle(float value) {
  _internal_set_actual_steering_wheel_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.SteeringControl.actual_steering_wheel_angle)
}

// float target_steering_wheel_torque = 3;
inline bool SteeringControl::_internal_has_target_steering_wheel_torque() const {
  return cmd_value_case() == kTargetSteeringWheelTorque;
}
inline void SteeringControl::set_has_target_steering_wheel_torque() {
  _oneof_case_[0] = kTargetSteeringWheelTorque;
}
inline void SteeringControl::clear_target_steering_wheel_torque() {
  if (_internal_has_target_steering_wheel_torque()) {
    cmd_value_.target_steering_wheel_torque_ = 0;
    clear_has_cmd_value();
  }
}
inline float SteeringControl::_internal_target_steering_wheel_torque() const {
  if (_internal_has_target_steering_wheel_torque()) {
    return cmd_value_.target_steering_wheel_torque_;
  }
  return 0;
}
inline void SteeringControl::_internal_set_target_steering_wheel_torque(float value) {
  if (!_internal_has_target_steering_wheel_torque()) {
    clear_cmd_value();
    set_has_target_steering_wheel_torque();
  }
  cmd_value_.target_steering_wheel_torque_ = value;
}
inline float SteeringControl::target_steering_wheel_torque() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.SteeringControl.target_steering_wheel_torque)
  return _internal_target_steering_wheel_torque();
}
inline void SteeringControl::set_target_steering_wheel_torque(float value) {
  _internal_set_target_steering_wheel_torque(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.SteeringControl.target_steering_wheel_torque)
}

// float target_directive_wheel_angle = 4;
inline bool SteeringControl::_internal_has_target_directive_wheel_angle() const {
  return cmd_value_case() == kTargetDirectiveWheelAngle;
}
inline void SteeringControl::set_has_target_directive_wheel_angle() {
  _oneof_case_[0] = kTargetDirectiveWheelAngle;
}
inline void SteeringControl::clear_target_directive_wheel_angle() {
  if (_internal_has_target_directive_wheel_angle()) {
    cmd_value_.target_directive_wheel_angle_ = 0;
    clear_has_cmd_value();
  }
}
inline float SteeringControl::_internal_target_directive_wheel_angle() const {
  if (_internal_has_target_directive_wheel_angle()) {
    return cmd_value_.target_directive_wheel_angle_;
  }
  return 0;
}
inline void SteeringControl::_internal_set_target_directive_wheel_angle(float value) {
  if (!_internal_has_target_directive_wheel_angle()) {
    clear_cmd_value();
    set_has_target_directive_wheel_angle();
  }
  cmd_value_.target_directive_wheel_angle_ = value;
}
inline float SteeringControl::target_directive_wheel_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.SteeringControl.target_directive_wheel_angle)
  return _internal_target_directive_wheel_angle();
}
inline void SteeringControl::set_target_directive_wheel_angle(float value) {
  _internal_set_target_directive_wheel_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.SteeringControl.target_directive_wheel_angle)
}

inline bool SteeringControl::has_cmd_value() const {
  return cmd_value_case() != CMD_VALUE_NOT_SET;
}
inline void SteeringControl::clear_has_cmd_value() {
  _oneof_case_[0] = CMD_VALUE_NOT_SET;
}
inline SteeringControl::CmdValueCase SteeringControl::cmd_value_case() const {
  return SteeringControl::CmdValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SteeringFeedback

// float steering_wheel_angle = 1;
inline void SteeringFeedback::clear_steering_wheel_angle() {
  steering_wheel_angle_ = 0;
}
inline float SteeringFeedback::_internal_steering_wheel_angle() const {
  return steering_wheel_angle_;
}
inline float SteeringFeedback::steering_wheel_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.SteeringFeedback.steering_wheel_angle)
  return _internal_steering_wheel_angle();
}
inline void SteeringFeedback::_internal_set_steering_wheel_angle(float value) {
  
  steering_wheel_angle_ = value;
}
inline void SteeringFeedback::set_steering_wheel_angle(float value) {
  _internal_set_steering_wheel_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.SteeringFeedback.steering_wheel_angle)
}

// float steering_wheel_speed = 2;
inline void SteeringFeedback::clear_steering_wheel_speed() {
  steering_wheel_speed_ = 0;
}
inline float SteeringFeedback::_internal_steering_wheel_speed() const {
  return steering_wheel_speed_;
}
inline float SteeringFeedback::steering_wheel_speed() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.SteeringFeedback.steering_wheel_speed)
  return _internal_steering_wheel_speed();
}
inline void SteeringFeedback::_internal_set_steering_wheel_speed(float value) {
  
  steering_wheel_speed_ = value;
}
inline void SteeringFeedback::set_steering_wheel_speed(float value) {
  _internal_set_steering_wheel_speed(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.SteeringFeedback.steering_wheel_speed)
}

// float left_directive_wheel_angle = 3;
inline void SteeringFeedback::clear_left_directive_wheel_angle() {
  left_directive_wheel_angle_ = 0;
}
inline float SteeringFeedback::_internal_left_directive_wheel_angle() const {
  return left_directive_wheel_angle_;
}
inline float SteeringFeedback::left_directive_wheel_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.SteeringFeedback.left_directive_wheel_angle)
  return _internal_left_directive_wheel_angle();
}
inline void SteeringFeedback::_internal_set_left_directive_wheel_angle(float value) {
  
  left_directive_wheel_angle_ = value;
}
inline void SteeringFeedback::set_left_directive_wheel_angle(float value) {
  _internal_set_left_directive_wheel_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.SteeringFeedback.left_directive_wheel_angle)
}

// float right_directive_wheel_angle = 4;
inline void SteeringFeedback::clear_right_directive_wheel_angle() {
  right_directive_wheel_angle_ = 0;
}
inline float SteeringFeedback::_internal_right_directive_wheel_angle() const {
  return right_directive_wheel_angle_;
}
inline float SteeringFeedback::right_directive_wheel_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.SteeringFeedback.right_directive_wheel_angle)
  return _internal_right_directive_wheel_angle();
}
inline void SteeringFeedback::_internal_set_right_directive_wheel_angle(float value) {
  
  right_directive_wheel_angle_ = value;
}
inline void SteeringFeedback::set_right_directive_wheel_angle(float value) {
  _internal_set_right_directive_wheel_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.SteeringFeedback.right_directive_wheel_angle)
}

// -------------------------------------------------------------------

// GearControl

// .vts.protocol.chassis.GearControlMode gear_mode = 1;
inline void GearControl::clear_gear_mode() {
  gear_mode_ = 0;
}
inline ::vts::protocol::chassis::GearControlMode GearControl::_internal_gear_mode() const {
  return static_cast< ::vts::protocol::chassis::GearControlMode >(gear_mode_);
}
inline ::vts::protocol::chassis::GearControlMode GearControl::gear_mode() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.GearControl.gear_mode)
  return _internal_gear_mode();
}
inline void GearControl::_internal_set_gear_mode(::vts::protocol::chassis::GearControlMode value) {
  
  gear_mode_ = value;
}
inline void GearControl::set_gear_mode(::vts::protocol::chassis::GearControlMode value) {
  _internal_set_gear_mode(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.GearControl.gear_mode)
}

// int32 target_gear_position = 2;
inline void GearControl::clear_target_gear_position() {
  target_gear_position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GearControl::_internal_target_gear_position() const {
  return target_gear_position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GearControl::target_gear_position() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.GearControl.target_gear_position)
  return _internal_target_gear_position();
}
inline void GearControl::_internal_set_target_gear_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  target_gear_position_ = value;
}
inline void GearControl::set_target_gear_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_target_gear_position(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.GearControl.target_gear_position)
}

// bool parking = 3;
inline void GearControl::clear_parking() {
  parking_ = false;
}
inline bool GearControl::_internal_parking() const {
  return parking_;
}
inline bool GearControl::parking() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.GearControl.parking)
  return _internal_parking();
}
inline void GearControl::_internal_set_parking(bool value) {
  
  parking_ = value;
}
inline void GearControl::set_parking(bool value) {
  _internal_set_parking(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.GearControl.parking)
}

// float clutch_pedal_angle = 4;
inline void GearControl::clear_clutch_pedal_angle() {
  clutch_pedal_angle_ = 0;
}
inline float GearControl::_internal_clutch_pedal_angle() const {
  return clutch_pedal_angle_;
}
inline float GearControl::clutch_pedal_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.GearControl.clutch_pedal_angle)
  return _internal_clutch_pedal_angle();
}
inline void GearControl::_internal_set_clutch_pedal_angle(float value) {
  
  clutch_pedal_angle_ = value;
}
inline void GearControl::set_clutch_pedal_angle(float value) {
  _internal_set_clutch_pedal_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.GearControl.clutch_pedal_angle)
}

// -------------------------------------------------------------------

// GearFeedback

// .vts.protocol.chassis.GearControlMode gear_mode = 1;
inline void GearFeedback::clear_gear_mode() {
  gear_mode_ = 0;
}
inline ::vts::protocol::chassis::GearControlMode GearFeedback::_internal_gear_mode() const {
  return static_cast< ::vts::protocol::chassis::GearControlMode >(gear_mode_);
}
inline ::vts::protocol::chassis::GearControlMode GearFeedback::gear_mode() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.GearFeedback.gear_mode)
  return _internal_gear_mode();
}
inline void GearFeedback::_internal_set_gear_mode(::vts::protocol::chassis::GearControlMode value) {
  
  gear_mode_ = value;
}
inline void GearFeedback::set_gear_mode(::vts::protocol::chassis::GearControlMode value) {
  _internal_set_gear_mode(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.GearFeedback.gear_mode)
}

// int32 current_gear_position = 2;
inline void GearFeedback::clear_current_gear_position() {
  current_gear_position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GearFeedback::_internal_current_gear_position() const {
  return current_gear_position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GearFeedback::current_gear_position() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.GearFeedback.current_gear_position)
  return _internal_current_gear_position();
}
inline void GearFeedback::_internal_set_current_gear_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  current_gear_position_ = value;
}
inline void GearFeedback::set_current_gear_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_current_gear_position(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.GearFeedback.current_gear_position)
}

// bool hand_brake = 3;
inline void GearFeedback::clear_hand_brake() {
  hand_brake_ = false;
}
inline bool GearFeedback::_internal_hand_brake() const {
  return hand_brake_;
}
inline bool GearFeedback::hand_brake() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.GearFeedback.hand_brake)
  return _internal_hand_brake();
}
inline void GearFeedback::_internal_set_hand_brake(bool value) {
  
  hand_brake_ = value;
}
inline void GearFeedback::set_hand_brake(bool value) {
  _internal_set_hand_brake(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.GearFeedback.hand_brake)
}

// -------------------------------------------------------------------

// DrivingControl

// float target_accelerator_pedal_position = 1;
inline bool DrivingControl::_internal_has_target_accelerator_pedal_position() const {
  return cmd_value_case() == kTargetAcceleratorPedalPosition;
}
inline void DrivingControl::set_has_target_accelerator_pedal_position() {
  _oneof_case_[0] = kTargetAcceleratorPedalPosition;
}
inline void DrivingControl::clear_target_accelerator_pedal_position() {
  if (_internal_has_target_accelerator_pedal_position()) {
    cmd_value_.target_accelerator_pedal_position_ = 0;
    clear_has_cmd_value();
  }
}
inline float DrivingControl::_internal_target_accelerator_pedal_position() const {
  if (_internal_has_target_accelerator_pedal_position()) {
    return cmd_value_.target_accelerator_pedal_position_;
  }
  return 0;
}
inline void DrivingControl::_internal_set_target_accelerator_pedal_position(float value) {
  if (!_internal_has_target_accelerator_pedal_position()) {
    clear_cmd_value();
    set_has_target_accelerator_pedal_position();
  }
  cmd_value_.target_accelerator_pedal_position_ = value;
}
inline float DrivingControl::target_accelerator_pedal_position() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.DrivingControl.target_accelerator_pedal_position)
  return _internal_target_accelerator_pedal_position();
}
inline void DrivingControl::set_target_accelerator_pedal_position(float value) {
  _internal_set_target_accelerator_pedal_position(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.DrivingControl.target_accelerator_pedal_position)
}

// float actual_accelerator_pedal_position = 2;
inline bool DrivingControl::_internal_has_actual_accelerator_pedal_position() const {
  return cmd_value_case() == kActualAcceleratorPedalPosition;
}
inline void DrivingControl::set_has_actual_accelerator_pedal_position() {
  _oneof_case_[0] = kActualAcceleratorPedalPosition;
}
inline void DrivingControl::clear_actual_accelerator_pedal_position() {
  if (_internal_has_actual_accelerator_pedal_position()) {
    cmd_value_.actual_accelerator_pedal_position_ = 0;
    clear_has_cmd_value();
  }
}
inline float DrivingControl::_internal_actual_accelerator_pedal_position() const {
  if (_internal_has_actual_accelerator_pedal_position()) {
    return cmd_value_.actual_accelerator_pedal_position_;
  }
  return 0;
}
inline void DrivingControl::_internal_set_actual_accelerator_pedal_position(float value) {
  if (!_internal_has_actual_accelerator_pedal_position()) {
    clear_cmd_value();
    set_has_actual_accelerator_pedal_position();
  }
  cmd_value_.actual_accelerator_pedal_position_ = value;
}
inline float DrivingControl::actual_accelerator_pedal_position() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.DrivingControl.actual_accelerator_pedal_position)
  return _internal_actual_accelerator_pedal_position();
}
inline void DrivingControl::set_actual_accelerator_pedal_position(float value) {
  _internal_set_actual_accelerator_pedal_position(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.DrivingControl.actual_accelerator_pedal_position)
}

// .vts.protocol.chassis.GearControl gear_control = 7;
inline bool DrivingControl::_internal_has_gear_control() const {
  return this != internal_default_instance() && gear_control_ != nullptr;
}
inline bool DrivingControl::has_gear_control() const {
  return _internal_has_gear_control();
}
inline void DrivingControl::clear_gear_control() {
  if (GetArenaNoVirtual() == nullptr && gear_control_ != nullptr) {
    delete gear_control_;
  }
  gear_control_ = nullptr;
}
inline const ::vts::protocol::chassis::GearControl& DrivingControl::_internal_gear_control() const {
  const ::vts::protocol::chassis::GearControl* p = gear_control_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::GearControl*>(
      &::vts::protocol::chassis::_GearControl_default_instance_);
}
inline const ::vts::protocol::chassis::GearControl& DrivingControl::gear_control() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.DrivingControl.gear_control)
  return _internal_gear_control();
}
inline ::vts::protocol::chassis::GearControl* DrivingControl::release_gear_control() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.DrivingControl.gear_control)
  
  ::vts::protocol::chassis::GearControl* temp = gear_control_;
  gear_control_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::GearControl* DrivingControl::_internal_mutable_gear_control() {
  
  if (gear_control_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::GearControl>(GetArenaNoVirtual());
    gear_control_ = p;
  }
  return gear_control_;
}
inline ::vts::protocol::chassis::GearControl* DrivingControl::mutable_gear_control() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.DrivingControl.gear_control)
  return _internal_mutable_gear_control();
}
inline void DrivingControl::set_allocated_gear_control(::vts::protocol::chassis::GearControl* gear_control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gear_control_;
  }
  if (gear_control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gear_control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gear_control, submessage_arena);
    }
    
  } else {
    
  }
  gear_control_ = gear_control;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.DrivingControl.gear_control)
}

inline bool DrivingControl::has_cmd_value() const {
  return cmd_value_case() != CMD_VALUE_NOT_SET;
}
inline void DrivingControl::clear_has_cmd_value() {
  _oneof_case_[0] = CMD_VALUE_NOT_SET;
}
inline DrivingControl::CmdValueCase DrivingControl::cmd_value_case() const {
  return DrivingControl::CmdValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DrivingFeedback

// .vts.protocol.chassis.DrivingMode driving_Mode = 1;
inline void DrivingFeedback::clear_driving_mode() {
  driving_mode_ = 0;
}
inline ::vts::protocol::chassis::DrivingMode DrivingFeedback::_internal_driving_mode() const {
  return static_cast< ::vts::protocol::chassis::DrivingMode >(driving_mode_);
}
inline ::vts::protocol::chassis::DrivingMode DrivingFeedback::driving_mode() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.DrivingFeedback.driving_Mode)
  return _internal_driving_mode();
}
inline void DrivingFeedback::_internal_set_driving_mode(::vts::protocol::chassis::DrivingMode value) {
  
  driving_mode_ = value;
}
inline void DrivingFeedback::set_driving_mode(::vts::protocol::chassis::DrivingMode value) {
  _internal_set_driving_mode(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.DrivingFeedback.driving_Mode)
}

// float accelerator_pedal_position = 2;
inline void DrivingFeedback::clear_accelerator_pedal_position() {
  accelerator_pedal_position_ = 0;
}
inline float DrivingFeedback::_internal_accelerator_pedal_position() const {
  return accelerator_pedal_position_;
}
inline float DrivingFeedback::accelerator_pedal_position() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.DrivingFeedback.accelerator_pedal_position)
  return _internal_accelerator_pedal_position();
}
inline void DrivingFeedback::_internal_set_accelerator_pedal_position(float value) {
  
  accelerator_pedal_position_ = value;
}
inline void DrivingFeedback::set_accelerator_pedal_position(float value) {
  _internal_set_accelerator_pedal_position(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.DrivingFeedback.accelerator_pedal_position)
}

// float engine_rpm = 3;
inline void DrivingFeedback::clear_engine_rpm() {
  engine_rpm_ = 0;
}
inline float DrivingFeedback::_internal_engine_rpm() const {
  return engine_rpm_;
}
inline float DrivingFeedback::engine_rpm() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.DrivingFeedback.engine_rpm)
  return _internal_engine_rpm();
}
inline void DrivingFeedback::_internal_set_engine_rpm(float value) {
  
  engine_rpm_ = value;
}
inline void DrivingFeedback::set_engine_rpm(float value) {
  _internal_set_engine_rpm(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.DrivingFeedback.engine_rpm)
}

// -------------------------------------------------------------------

// BrakeControl

// float target_brake_pedal_position = 1;
inline bool BrakeControl::_internal_has_target_brake_pedal_position() const {
  return cmd_value_case() == kTargetBrakePedalPosition;
}
inline void BrakeControl::set_has_target_brake_pedal_position() {
  _oneof_case_[0] = kTargetBrakePedalPosition;
}
inline void BrakeControl::clear_target_brake_pedal_position() {
  if (_internal_has_target_brake_pedal_position()) {
    cmd_value_.target_brake_pedal_position_ = 0;
    clear_has_cmd_value();
  }
}
inline float BrakeControl::_internal_target_brake_pedal_position() const {
  if (_internal_has_target_brake_pedal_position()) {
    return cmd_value_.target_brake_pedal_position_;
  }
  return 0;
}
inline void BrakeControl::_internal_set_target_brake_pedal_position(float value) {
  if (!_internal_has_target_brake_pedal_position()) {
    clear_cmd_value();
    set_has_target_brake_pedal_position();
  }
  cmd_value_.target_brake_pedal_position_ = value;
}
inline float BrakeControl::target_brake_pedal_position() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BrakeControl.target_brake_pedal_position)
  return _internal_target_brake_pedal_position();
}
inline void BrakeControl::set_target_brake_pedal_position(float value) {
  _internal_set_target_brake_pedal_position(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BrakeControl.target_brake_pedal_position)
}

// float actual_brake_pedal_position = 2;
inline bool BrakeControl::_internal_has_actual_brake_pedal_position() const {
  return cmd_value_case() == kActualBrakePedalPosition;
}
inline void BrakeControl::set_has_actual_brake_pedal_position() {
  _oneof_case_[0] = kActualBrakePedalPosition;
}
inline void BrakeControl::clear_actual_brake_pedal_position() {
  if (_internal_has_actual_brake_pedal_position()) {
    cmd_value_.actual_brake_pedal_position_ = 0;
    clear_has_cmd_value();
  }
}
inline float BrakeControl::_internal_actual_brake_pedal_position() const {
  if (_internal_has_actual_brake_pedal_position()) {
    return cmd_value_.actual_brake_pedal_position_;
  }
  return 0;
}
inline void BrakeControl::_internal_set_actual_brake_pedal_position(float value) {
  if (!_internal_has_actual_brake_pedal_position()) {
    clear_cmd_value();
    set_has_actual_brake_pedal_position();
  }
  cmd_value_.actual_brake_pedal_position_ = value;
}
inline float BrakeControl::actual_brake_pedal_position() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BrakeControl.actual_brake_pedal_position)
  return _internal_actual_brake_pedal_position();
}
inline void BrakeControl::set_actual_brake_pedal_position(float value) {
  _internal_set_actual_brake_pedal_position(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BrakeControl.actual_brake_pedal_position)
}

inline bool BrakeControl::has_cmd_value() const {
  return cmd_value_case() != CMD_VALUE_NOT_SET;
}
inline void BrakeControl::clear_has_cmd_value() {
  _oneof_case_[0] = CMD_VALUE_NOT_SET;
}
inline BrakeControl::CmdValueCase BrakeControl::cmd_value_case() const {
  return BrakeControl::CmdValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BrakeFeedback

// .vts.protocol.chassis.DrivingMode driving_mode = 1;
inline void BrakeFeedback::clear_driving_mode() {
  driving_mode_ = 0;
}
inline ::vts::protocol::chassis::DrivingMode BrakeFeedback::_internal_driving_mode() const {
  return static_cast< ::vts::protocol::chassis::DrivingMode >(driving_mode_);
}
inline ::vts::protocol::chassis::DrivingMode BrakeFeedback::driving_mode() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BrakeFeedback.driving_mode)
  return _internal_driving_mode();
}
inline void BrakeFeedback::_internal_set_driving_mode(::vts::protocol::chassis::DrivingMode value) {
  
  driving_mode_ = value;
}
inline void BrakeFeedback::set_driving_mode(::vts::protocol::chassis::DrivingMode value) {
  _internal_set_driving_mode(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BrakeFeedback.driving_mode)
}

// float brake_pedal_position = 2;
inline void BrakeFeedback::clear_brake_pedal_position() {
  brake_pedal_position_ = 0;
}
inline float BrakeFeedback::_internal_brake_pedal_position() const {
  return brake_pedal_position_;
}
inline float BrakeFeedback::brake_pedal_position() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BrakeFeedback.brake_pedal_position)
  return _internal_brake_pedal_position();
}
inline void BrakeFeedback::_internal_set_brake_pedal_position(float value) {
  
  brake_pedal_position_ = value;
}
inline void BrakeFeedback::set_brake_pedal_position(float value) {
  _internal_set_brake_pedal_position(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BrakeFeedback.brake_pedal_position)
}

// -------------------------------------------------------------------

// BodyControlModule

// bool left_turn_light = 1;
inline void BodyControlModule::clear_left_turn_light() {
  left_turn_light_ = false;
}
inline bool BodyControlModule::_internal_left_turn_light() const {
  return left_turn_light_;
}
inline bool BodyControlModule::left_turn_light() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.left_turn_light)
  return _internal_left_turn_light();
}
inline void BodyControlModule::_internal_set_left_turn_light(bool value) {
  
  left_turn_light_ = value;
}
inline void BodyControlModule::set_left_turn_light(bool value) {
  _internal_set_left_turn_light(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.left_turn_light)
}

// bool right_turn_light = 2;
inline void BodyControlModule::clear_right_turn_light() {
  right_turn_light_ = false;
}
inline bool BodyControlModule::_internal_right_turn_light() const {
  return right_turn_light_;
}
inline bool BodyControlModule::right_turn_light() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.right_turn_light)
  return _internal_right_turn_light();
}
inline void BodyControlModule::_internal_set_right_turn_light(bool value) {
  
  right_turn_light_ = value;
}
inline void BodyControlModule::set_right_turn_light(bool value) {
  _internal_set_right_turn_light(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.right_turn_light)
}

// bool low_beam = 3;
inline void BodyControlModule::clear_low_beam() {
  low_beam_ = false;
}
inline bool BodyControlModule::_internal_low_beam() const {
  return low_beam_;
}
inline bool BodyControlModule::low_beam() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.low_beam)
  return _internal_low_beam();
}
inline void BodyControlModule::_internal_set_low_beam(bool value) {
  
  low_beam_ = value;
}
inline void BodyControlModule::set_low_beam(bool value) {
  _internal_set_low_beam(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.low_beam)
}

// bool high_beam = 4;
inline void BodyControlModule::clear_high_beam() {
  high_beam_ = false;
}
inline bool BodyControlModule::_internal_high_beam() const {
  return high_beam_;
}
inline bool BodyControlModule::high_beam() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.high_beam)
  return _internal_high_beam();
}
inline void BodyControlModule::_internal_set_high_beam(bool value) {
  
  high_beam_ = value;
}
inline void BodyControlModule::set_high_beam(bool value) {
  _internal_set_high_beam(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.high_beam)
}

// bool front_fog_light = 5;
inline void BodyControlModule::clear_front_fog_light() {
  front_fog_light_ = false;
}
inline bool BodyControlModule::_internal_front_fog_light() const {
  return front_fog_light_;
}
inline bool BodyControlModule::front_fog_light() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.front_fog_light)
  return _internal_front_fog_light();
}
inline void BodyControlModule::_internal_set_front_fog_light(bool value) {
  
  front_fog_light_ = value;
}
inline void BodyControlModule::set_front_fog_light(bool value) {
  _internal_set_front_fog_light(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.front_fog_light)
}

// bool rear_fog_light = 6;
inline void BodyControlModule::clear_rear_fog_light() {
  rear_fog_light_ = false;
}
inline bool BodyControlModule::_internal_rear_fog_light() const {
  return rear_fog_light_;
}
inline bool BodyControlModule::rear_fog_light() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.rear_fog_light)
  return _internal_rear_fog_light();
}
inline void BodyControlModule::_internal_set_rear_fog_light(bool value) {
  
  rear_fog_light_ = value;
}
inline void BodyControlModule::set_rear_fog_light(bool value) {
  _internal_set_rear_fog_light(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.rear_fog_light)
}

// bool hazard_warning_light = 7;
inline void BodyControlModule::clear_hazard_warning_light() {
  hazard_warning_light_ = false;
}
inline bool BodyControlModule::_internal_hazard_warning_light() const {
  return hazard_warning_light_;
}
inline bool BodyControlModule::hazard_warning_light() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.hazard_warning_light)
  return _internal_hazard_warning_light();
}
inline void BodyControlModule::_internal_set_hazard_warning_light(bool value) {
  
  hazard_warning_light_ = value;
}
inline void BodyControlModule::set_hazard_warning_light(bool value) {
  _internal_set_hazard_warning_light(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.hazard_warning_light)
}

// int32 wiper = 8;
inline void BodyControlModule::clear_wiper() {
  wiper_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BodyControlModule::_internal_wiper() const {
  return wiper_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BodyControlModule::wiper() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.wiper)
  return _internal_wiper();
}
inline void BodyControlModule::_internal_set_wiper(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  wiper_ = value;
}
inline void BodyControlModule::set_wiper(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wiper(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.wiper)
}

// bool horn = 9;
inline void BodyControlModule::clear_horn() {
  horn_ = false;
}
inline bool BodyControlModule::_internal_horn() const {
  return horn_;
}
inline bool BodyControlModule::horn() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.horn)
  return _internal_horn();
}
inline void BodyControlModule::_internal_set_horn(bool value) {
  
  horn_ = value;
}
inline void BodyControlModule::set_horn(bool value) {
  _internal_set_horn(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.horn)
}

// bool auto_beam = 10;
inline void BodyControlModule::clear_auto_beam() {
  auto_beam_ = false;
}
inline bool BodyControlModule::_internal_auto_beam() const {
  return auto_beam_;
}
inline bool BodyControlModule::auto_beam() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.auto_beam)
  return _internal_auto_beam();
}
inline void BodyControlModule::_internal_set_auto_beam(bool value) {
  
  auto_beam_ = value;
}
inline void BodyControlModule::set_auto_beam(bool value) {
  _internal_set_auto_beam(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.auto_beam)
}

// bool auto_wiper = 11;
inline void BodyControlModule::clear_auto_wiper() {
  auto_wiper_ = false;
}
inline bool BodyControlModule::_internal_auto_wiper() const {
  return auto_wiper_;
}
inline bool BodyControlModule::auto_wiper() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.auto_wiper)
  return _internal_auto_wiper();
}
inline void BodyControlModule::_internal_set_auto_wiper(bool value) {
  
  auto_wiper_ = value;
}
inline void BodyControlModule::set_auto_wiper(bool value) {
  _internal_set_auto_wiper(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.auto_wiper)
}

// bool end_outline_marker_lamps = 12;
inline void BodyControlModule::clear_end_outline_marker_lamps() {
  end_outline_marker_lamps_ = false;
}
inline bool BodyControlModule::_internal_end_outline_marker_lamps() const {
  return end_outline_marker_lamps_;
}
inline bool BodyControlModule::end_outline_marker_lamps() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModule.end_outline_marker_lamps)
  return _internal_end_outline_marker_lamps();
}
inline void BodyControlModule::_internal_set_end_outline_marker_lamps(bool value) {
  
  end_outline_marker_lamps_ = value;
}
inline void BodyControlModule::set_end_outline_marker_lamps(bool value) {
  _internal_set_end_outline_marker_lamps(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModule.end_outline_marker_lamps)
}

// -------------------------------------------------------------------

// BodyControlModuleFeedback

// float longitudinal_acceleration = 1;
inline void BodyControlModuleFeedback::clear_longitudinal_acceleration() {
  longitudinal_acceleration_ = 0;
}
inline float BodyControlModuleFeedback::_internal_longitudinal_acceleration() const {
  return longitudinal_acceleration_;
}
inline float BodyControlModuleFeedback::longitudinal_acceleration() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.longitudinal_acceleration)
  return _internal_longitudinal_acceleration();
}
inline void BodyControlModuleFeedback::_internal_set_longitudinal_acceleration(float value) {
  
  longitudinal_acceleration_ = value;
}
inline void BodyControlModuleFeedback::set_longitudinal_acceleration(float value) {
  _internal_set_longitudinal_acceleration(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.longitudinal_acceleration)
}

// float vehicle_speed = 2;
inline void BodyControlModuleFeedback::clear_vehicle_speed() {
  vehicle_speed_ = 0;
}
inline float BodyControlModuleFeedback::_internal_vehicle_speed() const {
  return vehicle_speed_;
}
inline float BodyControlModuleFeedback::vehicle_speed() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.vehicle_speed)
  return _internal_vehicle_speed();
}
inline void BodyControlModuleFeedback::_internal_set_vehicle_speed(float value) {
  
  vehicle_speed_ = value;
}
inline void BodyControlModuleFeedback::set_vehicle_speed(float value) {
  _internal_set_vehicle_speed(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.vehicle_speed)
}

// float front_left_wheel_speed = 3;
inline void BodyControlModuleFeedback::clear_front_left_wheel_speed() {
  front_left_wheel_speed_ = 0;
}
inline float BodyControlModuleFeedback::_internal_front_left_wheel_speed() const {
  return front_left_wheel_speed_;
}
inline float BodyControlModuleFeedback::front_left_wheel_speed() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.front_left_wheel_speed)
  return _internal_front_left_wheel_speed();
}
inline void BodyControlModuleFeedback::_internal_set_front_left_wheel_speed(float value) {
  
  front_left_wheel_speed_ = value;
}
inline void BodyControlModuleFeedback::set_front_left_wheel_speed(float value) {
  _internal_set_front_left_wheel_speed(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.front_left_wheel_speed)
}

// float fron_right_wheel_speed = 4;
inline void BodyControlModuleFeedback::clear_fron_right_wheel_speed() {
  fron_right_wheel_speed_ = 0;
}
inline float BodyControlModuleFeedback::_internal_fron_right_wheel_speed() const {
  return fron_right_wheel_speed_;
}
inline float BodyControlModuleFeedback::fron_right_wheel_speed() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.fron_right_wheel_speed)
  return _internal_fron_right_wheel_speed();
}
inline void BodyControlModuleFeedback::_internal_set_fron_right_wheel_speed(float value) {
  
  fron_right_wheel_speed_ = value;
}
inline void BodyControlModuleFeedback::set_fron_right_wheel_speed(float value) {
  _internal_set_fron_right_wheel_speed(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.fron_right_wheel_speed)
}

// float rear_left_wheel_speed = 5;
inline void BodyControlModuleFeedback::clear_rear_left_wheel_speed() {
  rear_left_wheel_speed_ = 0;
}
inline float BodyControlModuleFeedback::_internal_rear_left_wheel_speed() const {
  return rear_left_wheel_speed_;
}
inline float BodyControlModuleFeedback::rear_left_wheel_speed() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.rear_left_wheel_speed)
  return _internal_rear_left_wheel_speed();
}
inline void BodyControlModuleFeedback::_internal_set_rear_left_wheel_speed(float value) {
  
  rear_left_wheel_speed_ = value;
}
inline void BodyControlModuleFeedback::set_rear_left_wheel_speed(float value) {
  _internal_set_rear_left_wheel_speed(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.rear_left_wheel_speed)
}

// float rear_right_wheel_speed = 6;
inline void BodyControlModuleFeedback::clear_rear_right_wheel_speed() {
  rear_right_wheel_speed_ = 0;
}
inline float BodyControlModuleFeedback::_internal_rear_right_wheel_speed() const {
  return rear_right_wheel_speed_;
}
inline float BodyControlModuleFeedback::rear_right_wheel_speed() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.rear_right_wheel_speed)
  return _internal_rear_right_wheel_speed();
}
inline void BodyControlModuleFeedback::_internal_set_rear_right_wheel_speed(float value) {
  
  rear_right_wheel_speed_ = value;
}
inline void BodyControlModuleFeedback::set_rear_right_wheel_speed(float value) {
  _internal_set_rear_right_wheel_speed(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.rear_right_wheel_speed)
}

// bool left_turn_light_state = 7;
inline void BodyControlModuleFeedback::clear_left_turn_light_state() {
  left_turn_light_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_left_turn_light_state() const {
  return left_turn_light_state_;
}
inline bool BodyControlModuleFeedback::left_turn_light_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.left_turn_light_state)
  return _internal_left_turn_light_state();
}
inline void BodyControlModuleFeedback::_internal_set_left_turn_light_state(bool value) {
  
  left_turn_light_state_ = value;
}
inline void BodyControlModuleFeedback::set_left_turn_light_state(bool value) {
  _internal_set_left_turn_light_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.left_turn_light_state)
}

// bool right_turn_light_state = 8;
inline void BodyControlModuleFeedback::clear_right_turn_light_state() {
  right_turn_light_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_right_turn_light_state() const {
  return right_turn_light_state_;
}
inline bool BodyControlModuleFeedback::right_turn_light_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.right_turn_light_state)
  return _internal_right_turn_light_state();
}
inline void BodyControlModuleFeedback::_internal_set_right_turn_light_state(bool value) {
  
  right_turn_light_state_ = value;
}
inline void BodyControlModuleFeedback::set_right_turn_light_state(bool value) {
  _internal_set_right_turn_light_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.right_turn_light_state)
}

// bool low_beam_state = 9;
inline void BodyControlModuleFeedback::clear_low_beam_state() {
  low_beam_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_low_beam_state() const {
  return low_beam_state_;
}
inline bool BodyControlModuleFeedback::low_beam_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.low_beam_state)
  return _internal_low_beam_state();
}
inline void BodyControlModuleFeedback::_internal_set_low_beam_state(bool value) {
  
  low_beam_state_ = value;
}
inline void BodyControlModuleFeedback::set_low_beam_state(bool value) {
  _internal_set_low_beam_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.low_beam_state)
}

// bool high_beam_state = 10;
inline void BodyControlModuleFeedback::clear_high_beam_state() {
  high_beam_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_high_beam_state() const {
  return high_beam_state_;
}
inline bool BodyControlModuleFeedback::high_beam_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.high_beam_state)
  return _internal_high_beam_state();
}
inline void BodyControlModuleFeedback::_internal_set_high_beam_state(bool value) {
  
  high_beam_state_ = value;
}
inline void BodyControlModuleFeedback::set_high_beam_state(bool value) {
  _internal_set_high_beam_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.high_beam_state)
}

// bool front_fog_light_state = 11;
inline void BodyControlModuleFeedback::clear_front_fog_light_state() {
  front_fog_light_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_front_fog_light_state() const {
  return front_fog_light_state_;
}
inline bool BodyControlModuleFeedback::front_fog_light_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.front_fog_light_state)
  return _internal_front_fog_light_state();
}
inline void BodyControlModuleFeedback::_internal_set_front_fog_light_state(bool value) {
  
  front_fog_light_state_ = value;
}
inline void BodyControlModuleFeedback::set_front_fog_light_state(bool value) {
  _internal_set_front_fog_light_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.front_fog_light_state)
}

// bool rear_fog_light_state = 12;
inline void BodyControlModuleFeedback::clear_rear_fog_light_state() {
  rear_fog_light_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_rear_fog_light_state() const {
  return rear_fog_light_state_;
}
inline bool BodyControlModuleFeedback::rear_fog_light_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.rear_fog_light_state)
  return _internal_rear_fog_light_state();
}
inline void BodyControlModuleFeedback::_internal_set_rear_fog_light_state(bool value) {
  
  rear_fog_light_state_ = value;
}
inline void BodyControlModuleFeedback::set_rear_fog_light_state(bool value) {
  _internal_set_rear_fog_light_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.rear_fog_light_state)
}

// bool hazard_warnning_light_state = 13;
inline void BodyControlModuleFeedback::clear_hazard_warnning_light_state() {
  hazard_warnning_light_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_hazard_warnning_light_state() const {
  return hazard_warnning_light_state_;
}
inline bool BodyControlModuleFeedback::hazard_warnning_light_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.hazard_warnning_light_state)
  return _internal_hazard_warnning_light_state();
}
inline void BodyControlModuleFeedback::_internal_set_hazard_warnning_light_state(bool value) {
  
  hazard_warnning_light_state_ = value;
}
inline void BodyControlModuleFeedback::set_hazard_warnning_light_state(bool value) {
  _internal_set_hazard_warnning_light_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.hazard_warnning_light_state)
}

// int32 wiper_state = 14;
inline void BodyControlModuleFeedback::clear_wiper_state() {
  wiper_state_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BodyControlModuleFeedback::_internal_wiper_state() const {
  return wiper_state_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BodyControlModuleFeedback::wiper_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.wiper_state)
  return _internal_wiper_state();
}
inline void BodyControlModuleFeedback::_internal_set_wiper_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  wiper_state_ = value;
}
inline void BodyControlModuleFeedback::set_wiper_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wiper_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.wiper_state)
}

// bool horn_state = 15;
inline void BodyControlModuleFeedback::clear_horn_state() {
  horn_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_horn_state() const {
  return horn_state_;
}
inline bool BodyControlModuleFeedback::horn_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.horn_state)
  return _internal_horn_state();
}
inline void BodyControlModuleFeedback::_internal_set_horn_state(bool value) {
  
  horn_state_ = value;
}
inline void BodyControlModuleFeedback::set_horn_state(bool value) {
  _internal_set_horn_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.horn_state)
}

// bool auto_beam_state = 16;
inline void BodyControlModuleFeedback::clear_auto_beam_state() {
  auto_beam_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_auto_beam_state() const {
  return auto_beam_state_;
}
inline bool BodyControlModuleFeedback::auto_beam_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.auto_beam_state)
  return _internal_auto_beam_state();
}
inline void BodyControlModuleFeedback::_internal_set_auto_beam_state(bool value) {
  
  auto_beam_state_ = value;
}
inline void BodyControlModuleFeedback::set_auto_beam_state(bool value) {
  _internal_set_auto_beam_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.auto_beam_state)
}

// bool auto_wiper_state = 17;
inline void BodyControlModuleFeedback::clear_auto_wiper_state() {
  auto_wiper_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_auto_wiper_state() const {
  return auto_wiper_state_;
}
inline bool BodyControlModuleFeedback::auto_wiper_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.auto_wiper_state)
  return _internal_auto_wiper_state();
}
inline void BodyControlModuleFeedback::_internal_set_auto_wiper_state(bool value) {
  
  auto_wiper_state_ = value;
}
inline void BodyControlModuleFeedback::set_auto_wiper_state(bool value) {
  _internal_set_auto_wiper_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.auto_wiper_state)
}

// bool brake_light_state = 18;
inline void BodyControlModuleFeedback::clear_brake_light_state() {
  brake_light_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_brake_light_state() const {
  return brake_light_state_;
}
inline bool BodyControlModuleFeedback::brake_light_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.brake_light_state)
  return _internal_brake_light_state();
}
inline void BodyControlModuleFeedback::_internal_set_brake_light_state(bool value) {
  
  brake_light_state_ = value;
}
inline void BodyControlModuleFeedback::set_brake_light_state(bool value) {
  _internal_set_brake_light_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.brake_light_state)
}

// bool end_outline_marker_lamps_state = 19;
inline void BodyControlModuleFeedback::clear_end_outline_marker_lamps_state() {
  end_outline_marker_lamps_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_end_outline_marker_lamps_state() const {
  return end_outline_marker_lamps_state_;
}
inline bool BodyControlModuleFeedback::end_outline_marker_lamps_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.end_outline_marker_lamps_state)
  return _internal_end_outline_marker_lamps_state();
}
inline void BodyControlModuleFeedback::_internal_set_end_outline_marker_lamps_state(bool value) {
  
  end_outline_marker_lamps_state_ = value;
}
inline void BodyControlModuleFeedback::set_end_outline_marker_lamps_state(bool value) {
  _internal_set_end_outline_marker_lamps_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.end_outline_marker_lamps_state)
}

// bool stop_lamps_state = 20;
inline void BodyControlModuleFeedback::clear_stop_lamps_state() {
  stop_lamps_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_stop_lamps_state() const {
  return stop_lamps_state_;
}
inline bool BodyControlModuleFeedback::stop_lamps_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.stop_lamps_state)
  return _internal_stop_lamps_state();
}
inline void BodyControlModuleFeedback::_internal_set_stop_lamps_state(bool value) {
  
  stop_lamps_state_ = value;
}
inline void BodyControlModuleFeedback::set_stop_lamps_state(bool value) {
  _internal_set_stop_lamps_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.stop_lamps_state)
}

// bool reversing_lamps_state = 21;
inline void BodyControlModuleFeedback::clear_reversing_lamps_state() {
  reversing_lamps_state_ = false;
}
inline bool BodyControlModuleFeedback::_internal_reversing_lamps_state() const {
  return reversing_lamps_state_;
}
inline bool BodyControlModuleFeedback::reversing_lamps_state() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.reversing_lamps_state)
  return _internal_reversing_lamps_state();
}
inline void BodyControlModuleFeedback::_internal_set_reversing_lamps_state(bool value) {
  
  reversing_lamps_state_ = value;
}
inline void BodyControlModuleFeedback::set_reversing_lamps_state(bool value) {
  _internal_set_reversing_lamps_state(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.reversing_lamps_state)
}

// float front_left_door_angle = 22;
inline void BodyControlModuleFeedback::clear_front_left_door_angle() {
  front_left_door_angle_ = 0;
}
inline float BodyControlModuleFeedback::_internal_front_left_door_angle() const {
  return front_left_door_angle_;
}
inline float BodyControlModuleFeedback::front_left_door_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.front_left_door_angle)
  return _internal_front_left_door_angle();
}
inline void BodyControlModuleFeedback::_internal_set_front_left_door_angle(float value) {
  
  front_left_door_angle_ = value;
}
inline void BodyControlModuleFeedback::set_front_left_door_angle(float value) {
  _internal_set_front_left_door_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.front_left_door_angle)
}

// float front_right_door_angle = 23;
inline void BodyControlModuleFeedback::clear_front_right_door_angle() {
  front_right_door_angle_ = 0;
}
inline float BodyControlModuleFeedback::_internal_front_right_door_angle() const {
  return front_right_door_angle_;
}
inline float BodyControlModuleFeedback::front_right_door_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.front_right_door_angle)
  return _internal_front_right_door_angle();
}
inline void BodyControlModuleFeedback::_internal_set_front_right_door_angle(float value) {
  
  front_right_door_angle_ = value;
}
inline void BodyControlModuleFeedback::set_front_right_door_angle(float value) {
  _internal_set_front_right_door_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.front_right_door_angle)
}

// float rear_left_door_angle = 24;
inline void BodyControlModuleFeedback::clear_rear_left_door_angle() {
  rear_left_door_angle_ = 0;
}
inline float BodyControlModuleFeedback::_internal_rear_left_door_angle() const {
  return rear_left_door_angle_;
}
inline float BodyControlModuleFeedback::rear_left_door_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.rear_left_door_angle)
  return _internal_rear_left_door_angle();
}
inline void BodyControlModuleFeedback::_internal_set_rear_left_door_angle(float value) {
  
  rear_left_door_angle_ = value;
}
inline void BodyControlModuleFeedback::set_rear_left_door_angle(float value) {
  _internal_set_rear_left_door_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.rear_left_door_angle)
}

// float rear_right_door_angle = 25;
inline void BodyControlModuleFeedback::clear_rear_right_door_angle() {
  rear_right_door_angle_ = 0;
}
inline float BodyControlModuleFeedback::_internal_rear_right_door_angle() const {
  return rear_right_door_angle_;
}
inline float BodyControlModuleFeedback::rear_right_door_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.rear_right_door_angle)
  return _internal_rear_right_door_angle();
}
inline void BodyControlModuleFeedback::_internal_set_rear_right_door_angle(float value) {
  
  rear_right_door_angle_ = value;
}
inline void BodyControlModuleFeedback::set_rear_right_door_angle(float value) {
  _internal_set_rear_right_door_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.rear_right_door_angle)
}

// float vehicle_boot_angle = 26;
inline void BodyControlModuleFeedback::clear_vehicle_boot_angle() {
  vehicle_boot_angle_ = 0;
}
inline float BodyControlModuleFeedback::_internal_vehicle_boot_angle() const {
  return vehicle_boot_angle_;
}
inline float BodyControlModuleFeedback::vehicle_boot_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.vehicle_boot_angle)
  return _internal_vehicle_boot_angle();
}
inline void BodyControlModuleFeedback::_internal_set_vehicle_boot_angle(float value) {
  
  vehicle_boot_angle_ = value;
}
inline void BodyControlModuleFeedback::set_vehicle_boot_angle(float value) {
  _internal_set_vehicle_boot_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.vehicle_boot_angle)
}

// float vehicle_bonnet_angle = 27;
inline void BodyControlModuleFeedback::clear_vehicle_bonnet_angle() {
  vehicle_bonnet_angle_ = 0;
}
inline float BodyControlModuleFeedback::_internal_vehicle_bonnet_angle() const {
  return vehicle_bonnet_angle_;
}
inline float BodyControlModuleFeedback::vehicle_bonnet_angle() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.BodyControlModuleFeedback.vehicle_bonnet_angle)
  return _internal_vehicle_bonnet_angle();
}
inline void BodyControlModuleFeedback::_internal_set_vehicle_bonnet_angle(float value) {
  
  vehicle_bonnet_angle_ = value;
}
inline void BodyControlModuleFeedback::set_vehicle_bonnet_angle(float value) {
  _internal_set_vehicle_bonnet_angle(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.BodyControlModuleFeedback.vehicle_bonnet_angle)
}

// -------------------------------------------------------------------

// VehicleControl

// .vts.protocol.main.SimHeader header = 1;
inline bool VehicleControl::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool VehicleControl::has_header() const {
  return _internal_has_header();
}
inline const ::vts::protocol::main::SimHeader& VehicleControl::_internal_header() const {
  const ::vts::protocol::main::SimHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::SimHeader*>(
      &::vts::protocol::main::_SimHeader_default_instance_);
}
inline const ::vts::protocol::main::SimHeader& VehicleControl::header() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleControl.header)
  return _internal_header();
}
inline ::vts::protocol::main::SimHeader* VehicleControl::release_header() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleControl.header)
  
  ::vts::protocol::main::SimHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::SimHeader* VehicleControl::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::SimHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::vts::protocol::main::SimHeader* VehicleControl::mutable_header() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleControl.header)
  return _internal_mutable_header();
}
inline void VehicleControl::set_allocated_header(::vts::protocol::main::SimHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleControl.header)
}

// .vts.protocol.chassis.SteeringControl steering_control = 2;
inline bool VehicleControl::_internal_has_steering_control() const {
  return this != internal_default_instance() && steering_control_ != nullptr;
}
inline bool VehicleControl::has_steering_control() const {
  return _internal_has_steering_control();
}
inline void VehicleControl::clear_steering_control() {
  if (GetArenaNoVirtual() == nullptr && steering_control_ != nullptr) {
    delete steering_control_;
  }
  steering_control_ = nullptr;
}
inline const ::vts::protocol::chassis::SteeringControl& VehicleControl::_internal_steering_control() const {
  const ::vts::protocol::chassis::SteeringControl* p = steering_control_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::SteeringControl*>(
      &::vts::protocol::chassis::_SteeringControl_default_instance_);
}
inline const ::vts::protocol::chassis::SteeringControl& VehicleControl::steering_control() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleControl.steering_control)
  return _internal_steering_control();
}
inline ::vts::protocol::chassis::SteeringControl* VehicleControl::release_steering_control() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleControl.steering_control)
  
  ::vts::protocol::chassis::SteeringControl* temp = steering_control_;
  steering_control_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::SteeringControl* VehicleControl::_internal_mutable_steering_control() {
  
  if (steering_control_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::SteeringControl>(GetArenaNoVirtual());
    steering_control_ = p;
  }
  return steering_control_;
}
inline ::vts::protocol::chassis::SteeringControl* VehicleControl::mutable_steering_control() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleControl.steering_control)
  return _internal_mutable_steering_control();
}
inline void VehicleControl::set_allocated_steering_control(::vts::protocol::chassis::SteeringControl* steering_control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_control_;
  }
  if (steering_control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_control, submessage_arena);
    }
    
  } else {
    
  }
  steering_control_ = steering_control;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleControl.steering_control)
}

// .vts.protocol.chassis.DrivingControl driving_control = 3;
inline bool VehicleControl::_internal_has_driving_control() const {
  return this != internal_default_instance() && driving_control_ != nullptr;
}
inline bool VehicleControl::has_driving_control() const {
  return _internal_has_driving_control();
}
inline void VehicleControl::clear_driving_control() {
  if (GetArenaNoVirtual() == nullptr && driving_control_ != nullptr) {
    delete driving_control_;
  }
  driving_control_ = nullptr;
}
inline const ::vts::protocol::chassis::DrivingControl& VehicleControl::_internal_driving_control() const {
  const ::vts::protocol::chassis::DrivingControl* p = driving_control_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::DrivingControl*>(
      &::vts::protocol::chassis::_DrivingControl_default_instance_);
}
inline const ::vts::protocol::chassis::DrivingControl& VehicleControl::driving_control() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleControl.driving_control)
  return _internal_driving_control();
}
inline ::vts::protocol::chassis::DrivingControl* VehicleControl::release_driving_control() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleControl.driving_control)
  
  ::vts::protocol::chassis::DrivingControl* temp = driving_control_;
  driving_control_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::DrivingControl* VehicleControl::_internal_mutable_driving_control() {
  
  if (driving_control_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::DrivingControl>(GetArenaNoVirtual());
    driving_control_ = p;
  }
  return driving_control_;
}
inline ::vts::protocol::chassis::DrivingControl* VehicleControl::mutable_driving_control() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleControl.driving_control)
  return _internal_mutable_driving_control();
}
inline void VehicleControl::set_allocated_driving_control(::vts::protocol::chassis::DrivingControl* driving_control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete driving_control_;
  }
  if (driving_control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      driving_control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, driving_control, submessage_arena);
    }
    
  } else {
    
  }
  driving_control_ = driving_control;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleControl.driving_control)
}

// .vts.protocol.chassis.BrakeControl brake_control = 4;
inline bool VehicleControl::_internal_has_brake_control() const {
  return this != internal_default_instance() && brake_control_ != nullptr;
}
inline bool VehicleControl::has_brake_control() const {
  return _internal_has_brake_control();
}
inline void VehicleControl::clear_brake_control() {
  if (GetArenaNoVirtual() == nullptr && brake_control_ != nullptr) {
    delete brake_control_;
  }
  brake_control_ = nullptr;
}
inline const ::vts::protocol::chassis::BrakeControl& VehicleControl::_internal_brake_control() const {
  const ::vts::protocol::chassis::BrakeControl* p = brake_control_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::BrakeControl*>(
      &::vts::protocol::chassis::_BrakeControl_default_instance_);
}
inline const ::vts::protocol::chassis::BrakeControl& VehicleControl::brake_control() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleControl.brake_control)
  return _internal_brake_control();
}
inline ::vts::protocol::chassis::BrakeControl* VehicleControl::release_brake_control() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleControl.brake_control)
  
  ::vts::protocol::chassis::BrakeControl* temp = brake_control_;
  brake_control_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::BrakeControl* VehicleControl::_internal_mutable_brake_control() {
  
  if (brake_control_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::BrakeControl>(GetArenaNoVirtual());
    brake_control_ = p;
  }
  return brake_control_;
}
inline ::vts::protocol::chassis::BrakeControl* VehicleControl::mutable_brake_control() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleControl.brake_control)
  return _internal_mutable_brake_control();
}
inline void VehicleControl::set_allocated_brake_control(::vts::protocol::chassis::BrakeControl* brake_control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_control_;
  }
  if (brake_control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake_control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake_control, submessage_arena);
    }
    
  } else {
    
  }
  brake_control_ = brake_control;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleControl.brake_control)
}

// .vts.protocol.chassis.BodyControlModule bcm = 5;
inline bool VehicleControl::_internal_has_bcm() const {
  return this != internal_default_instance() && bcm_ != nullptr;
}
inline bool VehicleControl::has_bcm() const {
  return _internal_has_bcm();
}
inline void VehicleControl::clear_bcm() {
  if (GetArenaNoVirtual() == nullptr && bcm_ != nullptr) {
    delete bcm_;
  }
  bcm_ = nullptr;
}
inline const ::vts::protocol::chassis::BodyControlModule& VehicleControl::_internal_bcm() const {
  const ::vts::protocol::chassis::BodyControlModule* p = bcm_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::BodyControlModule*>(
      &::vts::protocol::chassis::_BodyControlModule_default_instance_);
}
inline const ::vts::protocol::chassis::BodyControlModule& VehicleControl::bcm() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleControl.bcm)
  return _internal_bcm();
}
inline ::vts::protocol::chassis::BodyControlModule* VehicleControl::release_bcm() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleControl.bcm)
  
  ::vts::protocol::chassis::BodyControlModule* temp = bcm_;
  bcm_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::BodyControlModule* VehicleControl::_internal_mutable_bcm() {
  
  if (bcm_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::BodyControlModule>(GetArenaNoVirtual());
    bcm_ = p;
  }
  return bcm_;
}
inline ::vts::protocol::chassis::BodyControlModule* VehicleControl::mutable_bcm() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleControl.bcm)
  return _internal_mutable_bcm();
}
inline void VehicleControl::set_allocated_bcm(::vts::protocol::chassis::BodyControlModule* bcm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bcm_;
  }
  if (bcm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bcm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bcm, submessage_arena);
    }
    
  } else {
    
  }
  bcm_ = bcm;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleControl.bcm)
}

// -------------------------------------------------------------------

// VehicleFeedback

// .vts.protocol.main.SimHeader header = 1;
inline bool VehicleFeedback::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool VehicleFeedback::has_header() const {
  return _internal_has_header();
}
inline const ::vts::protocol::main::SimHeader& VehicleFeedback::_internal_header() const {
  const ::vts::protocol::main::SimHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::SimHeader*>(
      &::vts::protocol::main::_SimHeader_default_instance_);
}
inline const ::vts::protocol::main::SimHeader& VehicleFeedback::header() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleFeedback.header)
  return _internal_header();
}
inline ::vts::protocol::main::SimHeader* VehicleFeedback::release_header() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleFeedback.header)
  
  ::vts::protocol::main::SimHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::SimHeader* VehicleFeedback::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::SimHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::vts::protocol::main::SimHeader* VehicleFeedback::mutable_header() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleFeedback.header)
  return _internal_mutable_header();
}
inline void VehicleFeedback::set_allocated_header(::vts::protocol::main::SimHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleFeedback.header)
}

// .vts.protocol.chassis.VehicleError error = 2;
inline void VehicleFeedback::clear_error() {
  error_ = 0;
}
inline ::vts::protocol::chassis::VehicleError VehicleFeedback::_internal_error() const {
  return static_cast< ::vts::protocol::chassis::VehicleError >(error_);
}
inline ::vts::protocol::chassis::VehicleError VehicleFeedback::error() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleFeedback.error)
  return _internal_error();
}
inline void VehicleFeedback::_internal_set_error(::vts::protocol::chassis::VehicleError value) {
  
  error_ = value;
}
inline void VehicleFeedback::set_error(::vts::protocol::chassis::VehicleError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.VehicleFeedback.error)
}

// .vts.protocol.chassis.SteeringFeedback steering_feedback = 3;
inline bool VehicleFeedback::_internal_has_steering_feedback() const {
  return this != internal_default_instance() && steering_feedback_ != nullptr;
}
inline bool VehicleFeedback::has_steering_feedback() const {
  return _internal_has_steering_feedback();
}
inline void VehicleFeedback::clear_steering_feedback() {
  if (GetArenaNoVirtual() == nullptr && steering_feedback_ != nullptr) {
    delete steering_feedback_;
  }
  steering_feedback_ = nullptr;
}
inline const ::vts::protocol::chassis::SteeringFeedback& VehicleFeedback::_internal_steering_feedback() const {
  const ::vts::protocol::chassis::SteeringFeedback* p = steering_feedback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::SteeringFeedback*>(
      &::vts::protocol::chassis::_SteeringFeedback_default_instance_);
}
inline const ::vts::protocol::chassis::SteeringFeedback& VehicleFeedback::steering_feedback() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleFeedback.steering_feedback)
  return _internal_steering_feedback();
}
inline ::vts::protocol::chassis::SteeringFeedback* VehicleFeedback::release_steering_feedback() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleFeedback.steering_feedback)
  
  ::vts::protocol::chassis::SteeringFeedback* temp = steering_feedback_;
  steering_feedback_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::SteeringFeedback* VehicleFeedback::_internal_mutable_steering_feedback() {
  
  if (steering_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::SteeringFeedback>(GetArenaNoVirtual());
    steering_feedback_ = p;
  }
  return steering_feedback_;
}
inline ::vts::protocol::chassis::SteeringFeedback* VehicleFeedback::mutable_steering_feedback() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleFeedback.steering_feedback)
  return _internal_mutable_steering_feedback();
}
inline void VehicleFeedback::set_allocated_steering_feedback(::vts::protocol::chassis::SteeringFeedback* steering_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_feedback_;
  }
  if (steering_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_feedback, submessage_arena);
    }
    
  } else {
    
  }
  steering_feedback_ = steering_feedback;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleFeedback.steering_feedback)
}

// .vts.protocol.chassis.DrivingFeedback driving_feedback = 4;
inline bool VehicleFeedback::_internal_has_driving_feedback() const {
  return this != internal_default_instance() && driving_feedback_ != nullptr;
}
inline bool VehicleFeedback::has_driving_feedback() const {
  return _internal_has_driving_feedback();
}
inline void VehicleFeedback::clear_driving_feedback() {
  if (GetArenaNoVirtual() == nullptr && driving_feedback_ != nullptr) {
    delete driving_feedback_;
  }
  driving_feedback_ = nullptr;
}
inline const ::vts::protocol::chassis::DrivingFeedback& VehicleFeedback::_internal_driving_feedback() const {
  const ::vts::protocol::chassis::DrivingFeedback* p = driving_feedback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::DrivingFeedback*>(
      &::vts::protocol::chassis::_DrivingFeedback_default_instance_);
}
inline const ::vts::protocol::chassis::DrivingFeedback& VehicleFeedback::driving_feedback() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleFeedback.driving_feedback)
  return _internal_driving_feedback();
}
inline ::vts::protocol::chassis::DrivingFeedback* VehicleFeedback::release_driving_feedback() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleFeedback.driving_feedback)
  
  ::vts::protocol::chassis::DrivingFeedback* temp = driving_feedback_;
  driving_feedback_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::DrivingFeedback* VehicleFeedback::_internal_mutable_driving_feedback() {
  
  if (driving_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::DrivingFeedback>(GetArenaNoVirtual());
    driving_feedback_ = p;
  }
  return driving_feedback_;
}
inline ::vts::protocol::chassis::DrivingFeedback* VehicleFeedback::mutable_driving_feedback() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleFeedback.driving_feedback)
  return _internal_mutable_driving_feedback();
}
inline void VehicleFeedback::set_allocated_driving_feedback(::vts::protocol::chassis::DrivingFeedback* driving_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete driving_feedback_;
  }
  if (driving_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      driving_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, driving_feedback, submessage_arena);
    }
    
  } else {
    
  }
  driving_feedback_ = driving_feedback;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleFeedback.driving_feedback)
}

// .vts.protocol.chassis.BrakeFeedback brake_feedback = 5;
inline bool VehicleFeedback::_internal_has_brake_feedback() const {
  return this != internal_default_instance() && brake_feedback_ != nullptr;
}
inline bool VehicleFeedback::has_brake_feedback() const {
  return _internal_has_brake_feedback();
}
inline void VehicleFeedback::clear_brake_feedback() {
  if (GetArenaNoVirtual() == nullptr && brake_feedback_ != nullptr) {
    delete brake_feedback_;
  }
  brake_feedback_ = nullptr;
}
inline const ::vts::protocol::chassis::BrakeFeedback& VehicleFeedback::_internal_brake_feedback() const {
  const ::vts::protocol::chassis::BrakeFeedback* p = brake_feedback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::BrakeFeedback*>(
      &::vts::protocol::chassis::_BrakeFeedback_default_instance_);
}
inline const ::vts::protocol::chassis::BrakeFeedback& VehicleFeedback::brake_feedback() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleFeedback.brake_feedback)
  return _internal_brake_feedback();
}
inline ::vts::protocol::chassis::BrakeFeedback* VehicleFeedback::release_brake_feedback() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleFeedback.brake_feedback)
  
  ::vts::protocol::chassis::BrakeFeedback* temp = brake_feedback_;
  brake_feedback_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::BrakeFeedback* VehicleFeedback::_internal_mutable_brake_feedback() {
  
  if (brake_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::BrakeFeedback>(GetArenaNoVirtual());
    brake_feedback_ = p;
  }
  return brake_feedback_;
}
inline ::vts::protocol::chassis::BrakeFeedback* VehicleFeedback::mutable_brake_feedback() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleFeedback.brake_feedback)
  return _internal_mutable_brake_feedback();
}
inline void VehicleFeedback::set_allocated_brake_feedback(::vts::protocol::chassis::BrakeFeedback* brake_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_feedback_;
  }
  if (brake_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake_feedback, submessage_arena);
    }
    
  } else {
    
  }
  brake_feedback_ = brake_feedback;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleFeedback.brake_feedback)
}

// .vts.protocol.chassis.GearFeedback gear_feedback = 6;
inline bool VehicleFeedback::_internal_has_gear_feedback() const {
  return this != internal_default_instance() && gear_feedback_ != nullptr;
}
inline bool VehicleFeedback::has_gear_feedback() const {
  return _internal_has_gear_feedback();
}
inline void VehicleFeedback::clear_gear_feedback() {
  if (GetArenaNoVirtual() == nullptr && gear_feedback_ != nullptr) {
    delete gear_feedback_;
  }
  gear_feedback_ = nullptr;
}
inline const ::vts::protocol::chassis::GearFeedback& VehicleFeedback::_internal_gear_feedback() const {
  const ::vts::protocol::chassis::GearFeedback* p = gear_feedback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::GearFeedback*>(
      &::vts::protocol::chassis::_GearFeedback_default_instance_);
}
inline const ::vts::protocol::chassis::GearFeedback& VehicleFeedback::gear_feedback() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleFeedback.gear_feedback)
  return _internal_gear_feedback();
}
inline ::vts::protocol::chassis::GearFeedback* VehicleFeedback::release_gear_feedback() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleFeedback.gear_feedback)
  
  ::vts::protocol::chassis::GearFeedback* temp = gear_feedback_;
  gear_feedback_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::GearFeedback* VehicleFeedback::_internal_mutable_gear_feedback() {
  
  if (gear_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::GearFeedback>(GetArenaNoVirtual());
    gear_feedback_ = p;
  }
  return gear_feedback_;
}
inline ::vts::protocol::chassis::GearFeedback* VehicleFeedback::mutable_gear_feedback() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleFeedback.gear_feedback)
  return _internal_mutable_gear_feedback();
}
inline void VehicleFeedback::set_allocated_gear_feedback(::vts::protocol::chassis::GearFeedback* gear_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gear_feedback_;
  }
  if (gear_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gear_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gear_feedback, submessage_arena);
    }
    
  } else {
    
  }
  gear_feedback_ = gear_feedback;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleFeedback.gear_feedback)
}

// .vts.protocol.chassis.BodyControlModuleFeedback bcm_feedback = 7;
inline bool VehicleFeedback::_internal_has_bcm_feedback() const {
  return this != internal_default_instance() && bcm_feedback_ != nullptr;
}
inline bool VehicleFeedback::has_bcm_feedback() const {
  return _internal_has_bcm_feedback();
}
inline void VehicleFeedback::clear_bcm_feedback() {
  if (GetArenaNoVirtual() == nullptr && bcm_feedback_ != nullptr) {
    delete bcm_feedback_;
  }
  bcm_feedback_ = nullptr;
}
inline const ::vts::protocol::chassis::BodyControlModuleFeedback& VehicleFeedback::_internal_bcm_feedback() const {
  const ::vts::protocol::chassis::BodyControlModuleFeedback* p = bcm_feedback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::chassis::BodyControlModuleFeedback*>(
      &::vts::protocol::chassis::_BodyControlModuleFeedback_default_instance_);
}
inline const ::vts::protocol::chassis::BodyControlModuleFeedback& VehicleFeedback::bcm_feedback() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleFeedback.bcm_feedback)
  return _internal_bcm_feedback();
}
inline ::vts::protocol::chassis::BodyControlModuleFeedback* VehicleFeedback::release_bcm_feedback() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleFeedback.bcm_feedback)
  
  ::vts::protocol::chassis::BodyControlModuleFeedback* temp = bcm_feedback_;
  bcm_feedback_ = nullptr;
  return temp;
}
inline ::vts::protocol::chassis::BodyControlModuleFeedback* VehicleFeedback::_internal_mutable_bcm_feedback() {
  
  if (bcm_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::chassis::BodyControlModuleFeedback>(GetArenaNoVirtual());
    bcm_feedback_ = p;
  }
  return bcm_feedback_;
}
inline ::vts::protocol::chassis::BodyControlModuleFeedback* VehicleFeedback::mutable_bcm_feedback() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleFeedback.bcm_feedback)
  return _internal_mutable_bcm_feedback();
}
inline void VehicleFeedback::set_allocated_bcm_feedback(::vts::protocol::chassis::BodyControlModuleFeedback* bcm_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bcm_feedback_;
  }
  if (bcm_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bcm_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bcm_feedback, submessage_arena);
    }
    
  } else {
    
  }
  bcm_feedback_ = bcm_feedback;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleFeedback.bcm_feedback)
}

// -------------------------------------------------------------------

// VehicleRegister

// .vts.protocol.main.SimHeader header = 1;
inline bool VehicleRegister::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool VehicleRegister::has_header() const {
  return _internal_has_header();
}
inline const ::vts::protocol::main::SimHeader& VehicleRegister::_internal_header() const {
  const ::vts::protocol::main::SimHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::SimHeader*>(
      &::vts::protocol::main::_SimHeader_default_instance_);
}
inline const ::vts::protocol::main::SimHeader& VehicleRegister::header() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleRegister.header)
  return _internal_header();
}
inline ::vts::protocol::main::SimHeader* VehicleRegister::release_header() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleRegister.header)
  
  ::vts::protocol::main::SimHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::SimHeader* VehicleRegister::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::SimHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::vts::protocol::main::SimHeader* VehicleRegister::mutable_header() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleRegister.header)
  return _internal_mutable_header();
}
inline void VehicleRegister::set_allocated_header(::vts::protocol::main::SimHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleRegister.header)
}

// .vts.protocol.chassis.SteeringControlMode steering_control_mode = 2;
inline void VehicleRegister::clear_steering_control_mode() {
  steering_control_mode_ = 0;
}
inline ::vts::protocol::chassis::SteeringControlMode VehicleRegister::_internal_steering_control_mode() const {
  return static_cast< ::vts::protocol::chassis::SteeringControlMode >(steering_control_mode_);
}
inline ::vts::protocol::chassis::SteeringControlMode VehicleRegister::steering_control_mode() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleRegister.steering_control_mode)
  return _internal_steering_control_mode();
}
inline void VehicleRegister::_internal_set_steering_control_mode(::vts::protocol::chassis::SteeringControlMode value) {
  
  steering_control_mode_ = value;
}
inline void VehicleRegister::set_steering_control_mode(::vts::protocol::chassis::SteeringControlMode value) {
  _internal_set_steering_control_mode(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.VehicleRegister.steering_control_mode)
}

// .vts.protocol.chassis.DrivingControlMode driving_control_mode = 3;
inline void VehicleRegister::clear_driving_control_mode() {
  driving_control_mode_ = 0;
}
inline ::vts::protocol::chassis::DrivingControlMode VehicleRegister::_internal_driving_control_mode() const {
  return static_cast< ::vts::protocol::chassis::DrivingControlMode >(driving_control_mode_);
}
inline ::vts::protocol::chassis::DrivingControlMode VehicleRegister::driving_control_mode() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleRegister.driving_control_mode)
  return _internal_driving_control_mode();
}
inline void VehicleRegister::_internal_set_driving_control_mode(::vts::protocol::chassis::DrivingControlMode value) {
  
  driving_control_mode_ = value;
}
inline void VehicleRegister::set_driving_control_mode(::vts::protocol::chassis::DrivingControlMode value) {
  _internal_set_driving_control_mode(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.VehicleRegister.driving_control_mode)
}

// .vts.protocol.chassis.BrakeControlMode brake_mode = 4;
inline void VehicleRegister::clear_brake_mode() {
  brake_mode_ = 0;
}
inline ::vts::protocol::chassis::BrakeControlMode VehicleRegister::_internal_brake_mode() const {
  return static_cast< ::vts::protocol::chassis::BrakeControlMode >(brake_mode_);
}
inline ::vts::protocol::chassis::BrakeControlMode VehicleRegister::brake_mode() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleRegister.brake_mode)
  return _internal_brake_mode();
}
inline void VehicleRegister::_internal_set_brake_mode(::vts::protocol::chassis::BrakeControlMode value) {
  
  brake_mode_ = value;
}
inline void VehicleRegister::set_brake_mode(::vts::protocol::chassis::BrakeControlMode value) {
  _internal_set_brake_mode(value);
  // @@protoc_insertion_point(field_set:vts.protocol.chassis.VehicleRegister.brake_mode)
}

// -------------------------------------------------------------------

// VehicleQuit

// .vts.protocol.main.SimHeader header = 1;
inline bool VehicleQuit::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool VehicleQuit::has_header() const {
  return _internal_has_header();
}
inline const ::vts::protocol::main::SimHeader& VehicleQuit::_internal_header() const {
  const ::vts::protocol::main::SimHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::SimHeader*>(
      &::vts::protocol::main::_SimHeader_default_instance_);
}
inline const ::vts::protocol::main::SimHeader& VehicleQuit::header() const {
  // @@protoc_insertion_point(field_get:vts.protocol.chassis.VehicleQuit.header)
  return _internal_header();
}
inline ::vts::protocol::main::SimHeader* VehicleQuit::release_header() {
  // @@protoc_insertion_point(field_release:vts.protocol.chassis.VehicleQuit.header)
  
  ::vts::protocol::main::SimHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::SimHeader* VehicleQuit::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::SimHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::vts::protocol::main::SimHeader* VehicleQuit::mutable_header() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.chassis.VehicleQuit.header)
  return _internal_mutable_header();
}
inline void VehicleQuit::set_allocated_header(::vts::protocol::main::SimHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.chassis.VehicleQuit.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chassis
}  // namespace protocol
}  // namespace vts

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chassis_5fmessages_2eproto
