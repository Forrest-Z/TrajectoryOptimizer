// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "fields.pb.h"
#include "enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
namespace vts {
namespace protocol {
namespace main {
class AccountResult;
class AccountResultDefaultTypeInternal;
extern AccountResultDefaultTypeInternal _AccountResult_default_instance_;
class ActorPrepare;
class ActorPrepareDefaultTypeInternal;
extern ActorPrepareDefaultTypeInternal _ActorPrepare_default_instance_;
class ActorPrepareResult;
class ActorPrepareResultDefaultTypeInternal;
extern ActorPrepareResultDefaultTypeInternal _ActorPrepareResult_default_instance_;
class ArchiveInfoList;
class ArchiveInfoListDefaultTypeInternal;
extern ArchiveInfoListDefaultTypeInternal _ArchiveInfoList_default_instance_;
class DebugSession;
class DebugSessionDefaultTypeInternal;
extern DebugSessionDefaultTypeInternal _DebugSession_default_instance_;
class DebugSessionResult;
class DebugSessionResultDefaultTypeInternal;
extern DebugSessionResultDefaultTypeInternal _DebugSessionResult_default_instance_;
class FetchSessionTestResult;
class FetchSessionTestResultDefaultTypeInternal;
extern FetchSessionTestResultDefaultTypeInternal _FetchSessionTestResult_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Logout;
class LogoutDefaultTypeInternal;
extern LogoutDefaultTypeInternal _Logout_default_instance_;
class Notify;
class NotifyDefaultTypeInternal;
extern NotifyDefaultTypeInternal _Notify_default_instance_;
class PubRole;
class PubRoleDefaultTypeInternal;
extern PubRoleDefaultTypeInternal _PubRole_default_instance_;
class QueryArchiveInfo;
class QueryArchiveInfoDefaultTypeInternal;
extern QueryArchiveInfoDefaultTypeInternal _QueryArchiveInfo_default_instance_;
class Register;
class RegisterDefaultTypeInternal;
extern RegisterDefaultTypeInternal _Register_default_instance_;
class SessionInfo;
class SessionInfoDefaultTypeInternal;
extern SessionInfoDefaultTypeInternal _SessionInfo_default_instance_;
class SessionTestResult;
class SessionTestResultDefaultTypeInternal;
extern SessionTestResultDefaultTypeInternal _SessionTestResult_default_instance_;
class SubRole;
class SubRoleDefaultTypeInternal;
extern SubRoleDefaultTypeInternal _SubRole_default_instance_;
class SubRoleResult;
class SubRoleResultDefaultTypeInternal;
extern SubRoleResultDefaultTypeInternal _SubRoleResult_default_instance_;
class TryReplay;
class TryReplayDefaultTypeInternal;
extern TryReplayDefaultTypeInternal _TryReplay_default_instance_;
class TryResult;
class TryResultDefaultTypeInternal;
extern TryResultDefaultTypeInternal _TryResult_default_instance_;
class TryTest;
class TryTestDefaultTypeInternal;
extern TryTestDefaultTypeInternal _TryTest_default_instance_;
}  // namespace main
}  // namespace protocol
}  // namespace vts
PROTOBUF_NAMESPACE_OPEN
template<> ::vts::protocol::main::AccountResult* Arena::CreateMaybeMessage<::vts::protocol::main::AccountResult>(Arena*);
template<> ::vts::protocol::main::ActorPrepare* Arena::CreateMaybeMessage<::vts::protocol::main::ActorPrepare>(Arena*);
template<> ::vts::protocol::main::ActorPrepareResult* Arena::CreateMaybeMessage<::vts::protocol::main::ActorPrepareResult>(Arena*);
template<> ::vts::protocol::main::ArchiveInfoList* Arena::CreateMaybeMessage<::vts::protocol::main::ArchiveInfoList>(Arena*);
template<> ::vts::protocol::main::DebugSession* Arena::CreateMaybeMessage<::vts::protocol::main::DebugSession>(Arena*);
template<> ::vts::protocol::main::DebugSessionResult* Arena::CreateMaybeMessage<::vts::protocol::main::DebugSessionResult>(Arena*);
template<> ::vts::protocol::main::FetchSessionTestResult* Arena::CreateMaybeMessage<::vts::protocol::main::FetchSessionTestResult>(Arena*);
template<> ::vts::protocol::main::Login* Arena::CreateMaybeMessage<::vts::protocol::main::Login>(Arena*);
template<> ::vts::protocol::main::Logout* Arena::CreateMaybeMessage<::vts::protocol::main::Logout>(Arena*);
template<> ::vts::protocol::main::Notify* Arena::CreateMaybeMessage<::vts::protocol::main::Notify>(Arena*);
template<> ::vts::protocol::main::PubRole* Arena::CreateMaybeMessage<::vts::protocol::main::PubRole>(Arena*);
template<> ::vts::protocol::main::QueryArchiveInfo* Arena::CreateMaybeMessage<::vts::protocol::main::QueryArchiveInfo>(Arena*);
template<> ::vts::protocol::main::Register* Arena::CreateMaybeMessage<::vts::protocol::main::Register>(Arena*);
template<> ::vts::protocol::main::SessionInfo* Arena::CreateMaybeMessage<::vts::protocol::main::SessionInfo>(Arena*);
template<> ::vts::protocol::main::SessionTestResult* Arena::CreateMaybeMessage<::vts::protocol::main::SessionTestResult>(Arena*);
template<> ::vts::protocol::main::SubRole* Arena::CreateMaybeMessage<::vts::protocol::main::SubRole>(Arena*);
template<> ::vts::protocol::main::SubRoleResult* Arena::CreateMaybeMessage<::vts::protocol::main::SubRoleResult>(Arena*);
template<> ::vts::protocol::main::TryReplay* Arena::CreateMaybeMessage<::vts::protocol::main::TryReplay>(Arena*);
template<> ::vts::protocol::main::TryResult* Arena::CreateMaybeMessage<::vts::protocol::main::TryResult>(Arena*);
template<> ::vts::protocol::main::TryTest* Arena::CreateMaybeMessage<::vts::protocol::main::TryTest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vts {
namespace protocol {
namespace main {

// ===================================================================

class Register :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.Register) */ {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);
  Register(Register&& from) noexcept
    : Register() {
    *this = ::std::move(from);
  }

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline Register& operator=(Register&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Register& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Register* internal_default_instance() {
    return reinterpret_cast<const Register*>(
               &_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Register& a, Register& b) {
    a.Swap(&b);
  }
  inline void Swap(Register* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Register* New() const final {
    return CreateMaybeMessage<Register>(nullptr);
  }

  Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Register>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Register* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.Register";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string account = 1;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.Register)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Login :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }
  inline void Swap(Login* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const final {
    return CreateMaybeMessage<Login>(nullptr);
  }

  Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.Login";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string account = 1;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .vts.protocol.main.RoleContainerType type = 3;
  void clear_type();
  ::vts::protocol::main::RoleContainerType type() const;
  void set_type(::vts::protocol::main::RoleContainerType value);
  private:
  ::vts::protocol::main::RoleContainerType _internal_type() const;
  void _internal_set_type(::vts::protocol::main::RoleContainerType value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.Login)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Logout :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.Logout) */ {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);
  Logout(Logout&& from) noexcept
    : Logout() {
    *this = ::std::move(from);
  }

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logout& operator=(Logout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Logout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logout* internal_default_instance() {
    return reinterpret_cast<const Logout*>(
               &_Logout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Logout& a, Logout& b) {
    a.Swap(&b);
  }
  inline void Swap(Logout* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Logout* New() const final {
    return CreateMaybeMessage<Logout>(nullptr);
  }

  Logout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Logout>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logout* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.Logout";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // string reason = 1;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.Logout)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class AccountResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.AccountResult) */ {
 public:
  AccountResult();
  virtual ~AccountResult();

  AccountResult(const AccountResult& from);
  AccountResult(AccountResult&& from) noexcept
    : AccountResult() {
    *this = ::std::move(from);
  }

  inline AccountResult& operator=(const AccountResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountResult& operator=(AccountResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccountResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountResult* internal_default_instance() {
    return reinterpret_cast<const AccountResult*>(
               &_AccountResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccountResult& a, AccountResult& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountResult* New() const final {
    return CreateMaybeMessage<AccountResult>(nullptr);
  }

  AccountResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccountResult& from);
  void MergeFrom(const AccountResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.AccountResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 3,
    kReasonFieldNumber = 4,
    kOpFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string version = 3;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string reason = 4;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // .vts.protocol.main.AccountOPType op = 1;
  void clear_op();
  ::vts::protocol::main::AccountOPType op() const;
  void set_op(::vts::protocol::main::AccountOPType value);
  private:
  ::vts::protocol::main::AccountOPType _internal_op() const;
  void _internal_set_op(::vts::protocol::main::AccountOPType value);
  public:

  // bool result = 2;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.AccountResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  int op_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class TryTest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.TryTest) */ {
 public:
  TryTest();
  virtual ~TryTest();

  TryTest(const TryTest& from);
  TryTest(TryTest&& from) noexcept
    : TryTest() {
    *this = ::std::move(from);
  }

  inline TryTest& operator=(const TryTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryTest& operator=(TryTest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TryTest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TryTest* internal_default_instance() {
    return reinterpret_cast<const TryTest*>(
               &_TryTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TryTest& a, TryTest& b) {
    a.Swap(&b);
  }
  inline void Swap(TryTest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TryTest* New() const final {
    return CreateMaybeMessage<TryTest>(nullptr);
  }

  TryTest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TryTest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TryTest& from);
  void MergeFrom(const TryTest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryTest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.TryTest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaseFileIdFieldNumber = 1,
  };
  // string case_file_id = 1;
  void clear_case_file_id();
  const std::string& case_file_id() const;
  void set_case_file_id(const std::string& value);
  void set_case_file_id(std::string&& value);
  void set_case_file_id(const char* value);
  void set_case_file_id(const char* value, size_t size);
  std::string* mutable_case_file_id();
  std::string* release_case_file_id();
  void set_allocated_case_file_id(std::string* case_file_id);
  private:
  const std::string& _internal_case_file_id() const;
  void _internal_set_case_file_id(const std::string& value);
  std::string* _internal_mutable_case_file_id();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.TryTest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr case_file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class TryReplay :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.TryReplay) */ {
 public:
  TryReplay();
  virtual ~TryReplay();

  TryReplay(const TryReplay& from);
  TryReplay(TryReplay&& from) noexcept
    : TryReplay() {
    *this = ::std::move(from);
  }

  inline TryReplay& operator=(const TryReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryReplay& operator=(TryReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TryReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TryReplay* internal_default_instance() {
    return reinterpret_cast<const TryReplay*>(
               &_TryReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TryReplay& a, TryReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(TryReplay* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TryReplay* New() const final {
    return CreateMaybeMessage<TryReplay>(nullptr);
  }

  TryReplay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TryReplay>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TryReplay& from);
  void MergeFrom(const TryReplay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryReplay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.TryReplay";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestRecordIdFieldNumber = 1,
  };
  // string test_record_id = 1;
  void clear_test_record_id();
  const std::string& test_record_id() const;
  void set_test_record_id(const std::string& value);
  void set_test_record_id(std::string&& value);
  void set_test_record_id(const char* value);
  void set_test_record_id(const char* value, size_t size);
  std::string* mutable_test_record_id();
  std::string* release_test_record_id();
  void set_allocated_test_record_id(std::string* test_record_id);
  private:
  const std::string& _internal_test_record_id() const;
  void _internal_set_test_record_id(const std::string& value);
  std::string* _internal_mutable_test_record_id();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.TryReplay)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_record_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class TryResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.TryResult) */ {
 public:
  TryResult();
  virtual ~TryResult();

  TryResult(const TryResult& from);
  TryResult(TryResult&& from) noexcept
    : TryResult() {
    *this = ::std::move(from);
  }

  inline TryResult& operator=(const TryResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryResult& operator=(TryResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TryResult& default_instance();

  enum ArchiveIdCase {
    kCaseFileId = 6,
    kTestRecordId = 7,
    ARCHIVE_ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TryResult* internal_default_instance() {
    return reinterpret_cast<const TryResult*>(
               &_TryResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TryResult& a, TryResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TryResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TryResult* New() const final {
    return CreateMaybeMessage<TryResult>(nullptr);
  }

  TryResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TryResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TryResult& from);
  void MergeFrom(const TryResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.TryResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kReasonFieldNumber = 5,
    kResultFieldNumber = 2,
    kProgressFieldNumber = 3,
    kWaitSecondFieldNumber = 4,
    kCaseFileIdFieldNumber = 6,
    kTestRecordIdFieldNumber = 7,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string reason = 5;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // bool result = 2;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // int32 progress = 3;
  void clear_progress();
  ::PROTOBUF_NAMESPACE_ID::int32 progress() const;
  void set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_progress() const;
  void _internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 wait_second = 4;
  void clear_wait_second();
  ::PROTOBUF_NAMESPACE_ID::int32 wait_second() const;
  void set_wait_second(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wait_second() const;
  void _internal_set_wait_second(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // string case_file_id = 6;
  private:
  bool _internal_has_case_file_id() const;
  public:
  void clear_case_file_id();
  const std::string& case_file_id() const;
  void set_case_file_id(const std::string& value);
  void set_case_file_id(std::string&& value);
  void set_case_file_id(const char* value);
  void set_case_file_id(const char* value, size_t size);
  std::string* mutable_case_file_id();
  std::string* release_case_file_id();
  void set_allocated_case_file_id(std::string* case_file_id);
  private:
  const std::string& _internal_case_file_id() const;
  void _internal_set_case_file_id(const std::string& value);
  std::string* _internal_mutable_case_file_id();
  public:

  // string test_record_id = 7;
  private:
  bool _internal_has_test_record_id() const;
  public:
  void clear_test_record_id();
  const std::string& test_record_id() const;
  void set_test_record_id(const std::string& value);
  void set_test_record_id(std::string&& value);
  void set_test_record_id(const char* value);
  void set_test_record_id(const char* value, size_t size);
  std::string* mutable_test_record_id();
  std::string* release_test_record_id();
  void set_allocated_test_record_id(std::string* test_record_id);
  private:
  const std::string& _internal_test_record_id() const;
  void _internal_set_test_record_id(const std::string& value);
  std::string* _internal_mutable_test_record_id();
  public:

  void clear_archive_id();
  ArchiveIdCase archive_id_case() const;
  // @@protoc_insertion_point(class_scope:vts.protocol.main.TryResult)
 private:
  class _Internal;
  void set_has_case_file_id();
  void set_has_test_record_id();

  inline bool has_archive_id() const;
  inline void clear_has_archive_id();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  bool result_;
  ::PROTOBUF_NAMESPACE_ID::int32 progress_;
  ::PROTOBUF_NAMESPACE_ID::int32 wait_second_;
  union ArchiveIdUnion {
    ArchiveIdUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr case_file_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_record_id_;
  } archive_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SessionInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.SessionInfo) */ {
 public:
  SessionInfo();
  virtual ~SessionInfo();

  SessionInfo(const SessionInfo& from);
  SessionInfo(SessionInfo&& from) noexcept
    : SessionInfo() {
    *this = ::std::move(from);
  }

  inline SessionInfo& operator=(const SessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionInfo& operator=(SessionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionInfo* internal_default_instance() {
    return reinterpret_cast<const SessionInfo*>(
               &_SessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SessionInfo& a, SessionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionInfo* New() const final {
    return CreateMaybeMessage<SessionInfo>(nullptr);
  }

  SessionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionInfo& from);
  void MergeFrom(const SessionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.SessionInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 5,
    kSessionIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kSessionTimeFieldNumber = 4,
    kPercentFieldNumber = 3,
  };
  // repeated .vts.protocol.main.RoleContainerInfo clients = 5;
  int clients_size() const;
  private:
  int _internal_clients_size() const;
  public:
  void clear_clients();
  ::vts::protocol::main::RoleContainerInfo* mutable_clients(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::RoleContainerInfo >*
      mutable_clients();
  private:
  const ::vts::protocol::main::RoleContainerInfo& _internal_clients(int index) const;
  ::vts::protocol::main::RoleContainerInfo* _internal_add_clients();
  public:
  const ::vts::protocol::main::RoleContainerInfo& clients(int index) const;
  ::vts::protocol::main::RoleContainerInfo* add_clients();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::RoleContainerInfo >&
      clients() const;

  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .vts.protocol.main.SimHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::vts::protocol::main::SimHeader& header() const;
  ::vts::protocol::main::SimHeader* release_header();
  ::vts::protocol::main::SimHeader* mutable_header();
  void set_allocated_header(::vts::protocol::main::SimHeader* header);
  private:
  const ::vts::protocol::main::SimHeader& _internal_header() const;
  ::vts::protocol::main::SimHeader* _internal_mutable_header();
  public:

  // int64 session_time = 4;
  void clear_session_time();
  ::PROTOBUF_NAMESPACE_ID::int64 session_time() const;
  void set_session_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_session_time() const;
  void _internal_set_session_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // float percent = 3;
  void clear_percent();
  float percent() const;
  void set_percent(float value);
  private:
  float _internal_percent() const;
  void _internal_set_percent(float value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.SessionInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::RoleContainerInfo > clients_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::vts::protocol::main::SimHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int64 session_time_;
  float percent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FetchSessionTestResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.FetchSessionTestResult) */ {
 public:
  FetchSessionTestResult();
  virtual ~FetchSessionTestResult();

  FetchSessionTestResult(const FetchSessionTestResult& from);
  FetchSessionTestResult(FetchSessionTestResult&& from) noexcept
    : FetchSessionTestResult() {
    *this = ::std::move(from);
  }

  inline FetchSessionTestResult& operator=(const FetchSessionTestResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchSessionTestResult& operator=(FetchSessionTestResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FetchSessionTestResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FetchSessionTestResult* internal_default_instance() {
    return reinterpret_cast<const FetchSessionTestResult*>(
               &_FetchSessionTestResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FetchSessionTestResult& a, FetchSessionTestResult& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchSessionTestResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchSessionTestResult* New() const final {
    return CreateMaybeMessage<FetchSessionTestResult>(nullptr);
  }

  FetchSessionTestResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchSessionTestResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FetchSessionTestResult& from);
  void MergeFrom(const FetchSessionTestResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchSessionTestResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.FetchSessionTestResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.FetchSessionTestResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SessionTestResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.SessionTestResult) */ {
 public:
  SessionTestResult();
  virtual ~SessionTestResult();

  SessionTestResult(const SessionTestResult& from);
  SessionTestResult(SessionTestResult&& from) noexcept
    : SessionTestResult() {
    *this = ::std::move(from);
  }

  inline SessionTestResult& operator=(const SessionTestResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionTestResult& operator=(SessionTestResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionTestResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionTestResult* internal_default_instance() {
    return reinterpret_cast<const SessionTestResult*>(
               &_SessionTestResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SessionTestResult& a, SessionTestResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionTestResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionTestResult* New() const final {
    return CreateMaybeMessage<SessionTestResult>(nullptr);
  }

  SessionTestResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionTestResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionTestResult& from);
  void MergeFrom(const SessionTestResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionTestResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.SessionTestResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 2,
    kTestRecordIdFieldNumber = 3,
    kResultUrlFieldNumber = 4,
    kHeaderFieldNumber = 1,
  };
  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string test_record_id = 3;
  void clear_test_record_id();
  const std::string& test_record_id() const;
  void set_test_record_id(const std::string& value);
  void set_test_record_id(std::string&& value);
  void set_test_record_id(const char* value);
  void set_test_record_id(const char* value, size_t size);
  std::string* mutable_test_record_id();
  std::string* release_test_record_id();
  void set_allocated_test_record_id(std::string* test_record_id);
  private:
  const std::string& _internal_test_record_id() const;
  void _internal_set_test_record_id(const std::string& value);
  std::string* _internal_mutable_test_record_id();
  public:

  // string result_url = 4;
  void clear_result_url();
  const std::string& result_url() const;
  void set_result_url(const std::string& value);
  void set_result_url(std::string&& value);
  void set_result_url(const char* value);
  void set_result_url(const char* value, size_t size);
  std::string* mutable_result_url();
  std::string* release_result_url();
  void set_allocated_result_url(std::string* result_url);
  private:
  const std::string& _internal_result_url() const;
  void _internal_set_result_url(const std::string& value);
  std::string* _internal_mutable_result_url();
  public:

  // .vts.protocol.main.SimHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::vts::protocol::main::SimHeader& header() const;
  ::vts::protocol::main::SimHeader* release_header();
  ::vts::protocol::main::SimHeader* mutable_header();
  void set_allocated_header(::vts::protocol::main::SimHeader* header);
  private:
  const ::vts::protocol::main::SimHeader& _internal_header() const;
  ::vts::protocol::main::SimHeader* _internal_mutable_header();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.SessionTestResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_record_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_url_;
  ::vts::protocol::main::SimHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class DebugSession :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.DebugSession) */ {
 public:
  DebugSession();
  virtual ~DebugSession();

  DebugSession(const DebugSession& from);
  DebugSession(DebugSession&& from) noexcept
    : DebugSession() {
    *this = ::std::move(from);
  }

  inline DebugSession& operator=(const DebugSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugSession& operator=(DebugSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugSession* internal_default_instance() {
    return reinterpret_cast<const DebugSession*>(
               &_DebugSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DebugSession& a, DebugSession& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugSession* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugSession* New() const final {
    return CreateMaybeMessage<DebugSession>(nullptr);
  }

  DebugSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugSession>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugSession& from);
  void MergeFrom(const DebugSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.DebugSession";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 2,
    kSessionIdFieldNumber = 1,
  };
  // repeated uint32 params = 2;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_params(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_params() const;
  void _internal_add_params(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_params();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 params(int index) const;
  void set_params(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_params(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      params() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_params();

  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.DebugSession)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > params_;
  mutable std::atomic<int> _params_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class DebugSessionResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.DebugSessionResult) */ {
 public:
  DebugSessionResult();
  virtual ~DebugSessionResult();

  DebugSessionResult(const DebugSessionResult& from);
  DebugSessionResult(DebugSessionResult&& from) noexcept
    : DebugSessionResult() {
    *this = ::std::move(from);
  }

  inline DebugSessionResult& operator=(const DebugSessionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugSessionResult& operator=(DebugSessionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugSessionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugSessionResult* internal_default_instance() {
    return reinterpret_cast<const DebugSessionResult*>(
               &_DebugSessionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DebugSessionResult& a, DebugSessionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugSessionResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugSessionResult* New() const final {
    return CreateMaybeMessage<DebugSessionResult>(nullptr);
  }

  DebugSessionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugSessionResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugSessionResult& from);
  void MergeFrom(const DebugSessionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSessionResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.DebugSessionResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kReasonFieldNumber = 3,
    kResultFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string reason = 3;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // bool result = 2;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.DebugSessionResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ActorPrepare :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.ActorPrepare) */ {
 public:
  ActorPrepare();
  virtual ~ActorPrepare();

  ActorPrepare(const ActorPrepare& from);
  ActorPrepare(ActorPrepare&& from) noexcept
    : ActorPrepare() {
    *this = ::std::move(from);
  }

  inline ActorPrepare& operator=(const ActorPrepare& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorPrepare& operator=(ActorPrepare&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActorPrepare& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActorPrepare* internal_default_instance() {
    return reinterpret_cast<const ActorPrepare*>(
               &_ActorPrepare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ActorPrepare& a, ActorPrepare& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorPrepare* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorPrepare* New() const final {
    return CreateMaybeMessage<ActorPrepare>(nullptr);
  }

  ActorPrepare* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorPrepare>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActorPrepare& from);
  void MergeFrom(const ActorPrepare& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorPrepare* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.ActorPrepare";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kActorIdFieldNumber = 2,
    kArchiveInfoFieldNumber = 3,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string actor_id = 2;
  void clear_actor_id();
  const std::string& actor_id() const;
  void set_actor_id(const std::string& value);
  void set_actor_id(std::string&& value);
  void set_actor_id(const char* value);
  void set_actor_id(const char* value, size_t size);
  std::string* mutable_actor_id();
  std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // .vts.protocol.main.ArchiveInfo archive_info = 3;
  bool has_archive_info() const;
  private:
  bool _internal_has_archive_info() const;
  public:
  void clear_archive_info();
  const ::vts::protocol::main::ArchiveInfo& archive_info() const;
  ::vts::protocol::main::ArchiveInfo* release_archive_info();
  ::vts::protocol::main::ArchiveInfo* mutable_archive_info();
  void set_allocated_archive_info(::vts::protocol::main::ArchiveInfo* archive_info);
  private:
  const ::vts::protocol::main::ArchiveInfo& _internal_archive_info() const;
  ::vts::protocol::main::ArchiveInfo* _internal_mutable_archive_info();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.ActorPrepare)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
  ::vts::protocol::main::ArchiveInfo* archive_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ActorPrepareResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.ActorPrepareResult) */ {
 public:
  ActorPrepareResult();
  virtual ~ActorPrepareResult();

  ActorPrepareResult(const ActorPrepareResult& from);
  ActorPrepareResult(ActorPrepareResult&& from) noexcept
    : ActorPrepareResult() {
    *this = ::std::move(from);
  }

  inline ActorPrepareResult& operator=(const ActorPrepareResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActorPrepareResult& operator=(ActorPrepareResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActorPrepareResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActorPrepareResult* internal_default_instance() {
    return reinterpret_cast<const ActorPrepareResult*>(
               &_ActorPrepareResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ActorPrepareResult& a, ActorPrepareResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ActorPrepareResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActorPrepareResult* New() const final {
    return CreateMaybeMessage<ActorPrepareResult>(nullptr);
  }

  ActorPrepareResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActorPrepareResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActorPrepareResult& from);
  void MergeFrom(const ActorPrepareResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorPrepareResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.ActorPrepareResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kActorIdFieldNumber = 2,
    kReasonFieldNumber = 4,
    kResultFieldNumber = 3,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string actor_id = 2;
  void clear_actor_id();
  const std::string& actor_id() const;
  void set_actor_id(const std::string& value);
  void set_actor_id(std::string&& value);
  void set_actor_id(const char* value);
  void set_actor_id(const char* value, size_t size);
  std::string* mutable_actor_id();
  std::string* release_actor_id();
  void set_allocated_actor_id(std::string* actor_id);
  private:
  const std::string& _internal_actor_id() const;
  void _internal_set_actor_id(const std::string& value);
  std::string* _internal_mutable_actor_id();
  public:

  // string reason = 4;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // bool result = 3;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.ActorPrepareResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actor_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class QueryArchiveInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.QueryArchiveInfo) */ {
 public:
  QueryArchiveInfo();
  virtual ~QueryArchiveInfo();

  QueryArchiveInfo(const QueryArchiveInfo& from);
  QueryArchiveInfo(QueryArchiveInfo&& from) noexcept
    : QueryArchiveInfo() {
    *this = ::std::move(from);
  }

  inline QueryArchiveInfo& operator=(const QueryArchiveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryArchiveInfo& operator=(QueryArchiveInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueryArchiveInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryArchiveInfo* internal_default_instance() {
    return reinterpret_cast<const QueryArchiveInfo*>(
               &_QueryArchiveInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(QueryArchiveInfo& a, QueryArchiveInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryArchiveInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryArchiveInfo* New() const final {
    return CreateMaybeMessage<QueryArchiveInfo>(nullptr);
  }

  QueryArchiveInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryArchiveInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryArchiveInfo& from);
  void MergeFrom(const QueryArchiveInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryArchiveInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.QueryArchiveInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string condition = 2;
  void clear_condition();
  const std::string& condition() const;
  void set_condition(const std::string& value);
  void set_condition(std::string&& value);
  void set_condition(const char* value);
  void set_condition(const char* value, size_t size);
  std::string* mutable_condition();
  std::string* release_condition();
  void set_allocated_condition(std::string* condition);
  private:
  const std::string& _internal_condition() const;
  void _internal_set_condition(const std::string& value);
  std::string* _internal_mutable_condition();
  public:

  // .vts.protocol.main.ArchiveType type = 1;
  void clear_type();
  ::vts::protocol::main::ArchiveType type() const;
  void set_type(::vts::protocol::main::ArchiveType value);
  private:
  ::vts::protocol::main::ArchiveType _internal_type() const;
  void _internal_set_type(::vts::protocol::main::ArchiveType value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.QueryArchiveInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr condition_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ArchiveInfoList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.ArchiveInfoList) */ {
 public:
  ArchiveInfoList();
  virtual ~ArchiveInfoList();

  ArchiveInfoList(const ArchiveInfoList& from);
  ArchiveInfoList(ArchiveInfoList&& from) noexcept
    : ArchiveInfoList() {
    *this = ::std::move(from);
  }

  inline ArchiveInfoList& operator=(const ArchiveInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArchiveInfoList& operator=(ArchiveInfoList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ArchiveInfoList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArchiveInfoList* internal_default_instance() {
    return reinterpret_cast<const ArchiveInfoList*>(
               &_ArchiveInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ArchiveInfoList& a, ArchiveInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(ArchiveInfoList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ArchiveInfoList* New() const final {
    return CreateMaybeMessage<ArchiveInfoList>(nullptr);
  }

  ArchiveInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ArchiveInfoList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ArchiveInfoList& from);
  void MergeFrom(const ArchiveInfoList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArchiveInfoList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.ArchiveInfoList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArchiveInfoListFieldNumber = 1,
  };
  // repeated .vts.protocol.main.ArchiveInfo archive_info_list = 1;
  int archive_info_list_size() const;
  private:
  int _internal_archive_info_list_size() const;
  public:
  void clear_archive_info_list();
  ::vts::protocol::main::ArchiveInfo* mutable_archive_info_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::ArchiveInfo >*
      mutable_archive_info_list();
  private:
  const ::vts::protocol::main::ArchiveInfo& _internal_archive_info_list(int index) const;
  ::vts::protocol::main::ArchiveInfo* _internal_add_archive_info_list();
  public:
  const ::vts::protocol::main::ArchiveInfo& archive_info_list(int index) const;
  ::vts::protocol::main::ArchiveInfo* add_archive_info_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::ArchiveInfo >&
      archive_info_list() const;

  // @@protoc_insertion_point(class_scope:vts.protocol.main.ArchiveInfoList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::ArchiveInfo > archive_info_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SubRole :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.SubRole) */ {
 public:
  SubRole();
  virtual ~SubRole();

  SubRole(const SubRole& from);
  SubRole(SubRole&& from) noexcept
    : SubRole() {
    *this = ::std::move(from);
  }

  inline SubRole& operator=(const SubRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubRole& operator=(SubRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubRole* internal_default_instance() {
    return reinterpret_cast<const SubRole*>(
               &_SubRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SubRole& a, SubRole& b) {
    a.Swap(&b);
  }
  inline void Swap(SubRole* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubRole* New() const final {
    return CreateMaybeMessage<SubRole>(nullptr);
  }

  SubRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubRole& from);
  void MergeFrom(const SubRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.SubRole";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleTypesFieldNumber = 2,
    kRoleIdsFieldNumber = 3,
    kRoleAOIsFieldNumber = 4,
    kSessionIdFieldNumber = 1,
  };
  // repeated string role_types = 2;
  int role_types_size() const;
  private:
  int _internal_role_types_size() const;
  public:
  void clear_role_types();
  const std::string& role_types(int index) const;
  std::string* mutable_role_types(int index);
  void set_role_types(int index, const std::string& value);
  void set_role_types(int index, std::string&& value);
  void set_role_types(int index, const char* value);
  void set_role_types(int index, const char* value, size_t size);
  std::string* add_role_types();
  void add_role_types(const std::string& value);
  void add_role_types(std::string&& value);
  void add_role_types(const char* value);
  void add_role_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& role_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_role_types();
  private:
  const std::string& _internal_role_types(int index) const;
  std::string* _internal_add_role_types();
  public:

  // repeated string role_ids = 3;
  int role_ids_size() const;
  private:
  int _internal_role_ids_size() const;
  public:
  void clear_role_ids();
  const std::string& role_ids(int index) const;
  std::string* mutable_role_ids(int index);
  void set_role_ids(int index, const std::string& value);
  void set_role_ids(int index, std::string&& value);
  void set_role_ids(int index, const char* value);
  void set_role_ids(int index, const char* value, size_t size);
  std::string* add_role_ids();
  void add_role_ids(const std::string& value);
  void add_role_ids(std::string&& value);
  void add_role_ids(const char* value);
  void add_role_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& role_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_role_ids();
  private:
  const std::string& _internal_role_ids(int index) const;
  std::string* _internal_add_role_ids();
  public:

  // repeated .vts.protocol.main.AOIInfo role_AOIs = 4;
  int role_aois_size() const;
  private:
  int _internal_role_aois_size() const;
  public:
  void clear_role_aois();
  ::vts::protocol::main::AOIInfo* mutable_role_aois(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::AOIInfo >*
      mutable_role_aois();
  private:
  const ::vts::protocol::main::AOIInfo& _internal_role_aois(int index) const;
  ::vts::protocol::main::AOIInfo* _internal_add_role_aois();
  public:
  const ::vts::protocol::main::AOIInfo& role_aois(int index) const;
  ::vts::protocol::main::AOIInfo* add_role_aois();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::AOIInfo >&
      role_aois() const;

  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.SubRole)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> role_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> role_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::AOIInfo > role_aois_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SubRoleResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.SubRoleResult) */ {
 public:
  SubRoleResult();
  virtual ~SubRoleResult();

  SubRoleResult(const SubRoleResult& from);
  SubRoleResult(SubRoleResult&& from) noexcept
    : SubRoleResult() {
    *this = ::std::move(from);
  }

  inline SubRoleResult& operator=(const SubRoleResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubRoleResult& operator=(SubRoleResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubRoleResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubRoleResult* internal_default_instance() {
    return reinterpret_cast<const SubRoleResult*>(
               &_SubRoleResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SubRoleResult& a, SubRoleResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SubRoleResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubRoleResult* New() const final {
    return CreateMaybeMessage<SubRoleResult>(nullptr);
  }

  SubRoleResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubRoleResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubRoleResult& from);
  void MergeFrom(const SubRoleResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubRoleResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.SubRoleResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kResultFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // string session_id = 3;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.SubRoleResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class PubRole :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.PubRole) */ {
 public:
  PubRole();
  virtual ~PubRole();

  PubRole(const PubRole& from);
  PubRole(PubRole&& from) noexcept
    : PubRole() {
    *this = ::std::move(from);
  }

  inline PubRole& operator=(const PubRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubRole& operator=(PubRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PubRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PubRole* internal_default_instance() {
    return reinterpret_cast<const PubRole*>(
               &_PubRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PubRole& a, PubRole& b) {
    a.Swap(&b);
  }
  inline void Swap(PubRole* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PubRole* New() const final {
    return CreateMaybeMessage<PubRole>(nullptr);
  }

  PubRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PubRole>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PubRole& from);
  void MergeFrom(const PubRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PubRole* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.PubRole";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSRolesFieldNumber = 3,
    kCRolesFieldNumber = 4,
    kSessionIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .vts.protocol.main.SingleRole s_roles = 3;
  int s_roles_size() const;
  private:
  int _internal_s_roles_size() const;
  public:
  void clear_s_roles();
  ::vts::protocol::main::SingleRole* mutable_s_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole >*
      mutable_s_roles();
  private:
  const ::vts::protocol::main::SingleRole& _internal_s_roles(int index) const;
  ::vts::protocol::main::SingleRole* _internal_add_s_roles();
  public:
  const ::vts::protocol::main::SingleRole& s_roles(int index) const;
  ::vts::protocol::main::SingleRole* add_s_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole >&
      s_roles() const;

  // repeated .vts.protocol.main.CompoundRole c_roles = 4;
  int c_roles_size() const;
  private:
  int _internal_c_roles_size() const;
  public:
  void clear_c_roles();
  ::vts::protocol::main::CompoundRole* mutable_c_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::CompoundRole >*
      mutable_c_roles();
  private:
  const ::vts::protocol::main::CompoundRole& _internal_c_roles(int index) const;
  ::vts::protocol::main::CompoundRole* _internal_add_c_roles();
  public:
  const ::vts::protocol::main::CompoundRole& c_roles(int index) const;
  ::vts::protocol::main::CompoundRole* add_c_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::CompoundRole >&
      c_roles() const;

  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .vts.protocol.main.SimHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::vts::protocol::main::SimHeader& header() const;
  ::vts::protocol::main::SimHeader* release_header();
  ::vts::protocol::main::SimHeader* mutable_header();
  void set_allocated_header(::vts::protocol::main::SimHeader* header);
  private:
  const ::vts::protocol::main::SimHeader& _internal_header() const;
  ::vts::protocol::main::SimHeader* _internal_mutable_header();
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.PubRole)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole > s_roles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::CompoundRole > c_roles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::vts::protocol::main::SimHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Notify :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vts.protocol.main.Notify) */ {
 public:
  Notify();
  virtual ~Notify();

  Notify(const Notify& from);
  Notify(Notify&& from) noexcept
    : Notify() {
    *this = ::std::move(from);
  }

  inline Notify& operator=(const Notify& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notify& operator=(Notify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Notify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Notify* internal_default_instance() {
    return reinterpret_cast<const Notify*>(
               &_Notify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Notify& a, Notify& b) {
    a.Swap(&b);
  }
  inline void Swap(Notify* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Notify* New() const final {
    return CreateMaybeMessage<Notify>(nullptr);
  }

  Notify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Notify>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Notify& from);
  void MergeFrom(const Notify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vts.protocol.main.Notify";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDParamFieldNumber = 6,
    kSessionIdFieldNumber = 2,
    kRoleIdFieldNumber = 3,
    kSParamFieldNumber = 5,
    kHeaderFieldNumber = 1,
    kTypeFieldNumber = 4,
  };
  // repeated double d_param = 6;
  int d_param_size() const;
  private:
  int _internal_d_param_size() const;
  public:
  void clear_d_param();
  private:
  double _internal_d_param(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_d_param() const;
  void _internal_add_d_param(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_d_param();
  public:
  double d_param(int index) const;
  void set_d_param(int index, double value);
  void add_d_param(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      d_param() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_d_param();

  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string role_id = 3;
  void clear_role_id();
  const std::string& role_id() const;
  void set_role_id(const std::string& value);
  void set_role_id(std::string&& value);
  void set_role_id(const char* value);
  void set_role_id(const char* value, size_t size);
  std::string* mutable_role_id();
  std::string* release_role_id();
  void set_allocated_role_id(std::string* role_id);
  private:
  const std::string& _internal_role_id() const;
  void _internal_set_role_id(const std::string& value);
  std::string* _internal_mutable_role_id();
  public:

  // string s_param = 5;
  void clear_s_param();
  const std::string& s_param() const;
  void set_s_param(const std::string& value);
  void set_s_param(std::string&& value);
  void set_s_param(const char* value);
  void set_s_param(const char* value, size_t size);
  std::string* mutable_s_param();
  std::string* release_s_param();
  void set_allocated_s_param(std::string* s_param);
  private:
  const std::string& _internal_s_param() const;
  void _internal_set_s_param(const std::string& value);
  std::string* _internal_mutable_s_param();
  public:

  // .vts.protocol.main.SimHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::vts::protocol::main::SimHeader& header() const;
  ::vts::protocol::main::SimHeader* release_header();
  ::vts::protocol::main::SimHeader* mutable_header();
  void set_allocated_header(::vts::protocol::main::SimHeader* header);
  private:
  const ::vts::protocol::main::SimHeader& _internal_header() const;
  ::vts::protocol::main::SimHeader* _internal_mutable_header();
  public:

  // .vts.protocol.main.NotifyType type = 4;
  void clear_type();
  ::vts::protocol::main::NotifyType type() const;
  void set_type(::vts::protocol::main::NotifyType value);
  private:
  ::vts::protocol::main::NotifyType _internal_type() const;
  void _internal_set_type(::vts::protocol::main::NotifyType value);
  public:

  // @@protoc_insertion_point(class_scope:vts.protocol.main.Notify)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > d_param_;
  mutable std::atomic<int> _d_param_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_param_;
  ::vts::protocol::main::SimHeader* header_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Register

// string account = 1;
inline void Register::clear_account() {
  account_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Register::account() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Register.account)
  return _internal_account();
}
inline void Register::set_account(const std::string& value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Register.account)
}
inline std::string* Register::mutable_account() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Register.account)
  return _internal_mutable_account();
}
inline const std::string& Register::_internal_account() const {
  return account_.GetNoArena();
}
inline void Register::_internal_set_account(const std::string& value) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Register::set_account(std::string&& value) {
  
  account_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.Register.account)
}
inline void Register::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.Register.account)
}
inline void Register::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.Register.account)
}
inline std::string* Register::_internal_mutable_account() {
  
  return account_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Register::release_account() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Register.account)
  
  return account_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Register.account)
}

// string password = 2;
inline void Register::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Register::password() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Register.password)
  return _internal_password();
}
inline void Register::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Register.password)
}
inline std::string* Register::mutable_password() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Register.password)
  return _internal_mutable_password();
}
inline const std::string& Register::_internal_password() const {
  return password_.GetNoArena();
}
inline void Register::_internal_set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Register::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.Register.password)
}
inline void Register::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.Register.password)
}
inline void Register::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.Register.password)
}
inline std::string* Register::_internal_mutable_password() {
  
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Register::release_password() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Register.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Register.password)
}

// -------------------------------------------------------------------

// Login

// string account = 1;
inline void Login::clear_account() {
  account_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Login::account() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Login.account)
  return _internal_account();
}
inline void Login::set_account(const std::string& value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Login.account)
}
inline std::string* Login::mutable_account() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Login.account)
  return _internal_mutable_account();
}
inline const std::string& Login::_internal_account() const {
  return account_.GetNoArena();
}
inline void Login::_internal_set_account(const std::string& value) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Login::set_account(std::string&& value) {
  
  account_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.Login.account)
}
inline void Login::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.Login.account)
}
inline void Login::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.Login.account)
}
inline std::string* Login::_internal_mutable_account() {
  
  return account_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Login::release_account() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Login.account)
  
  return account_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Login.account)
}

// string password = 2;
inline void Login::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Login.password)
  return _internal_password();
}
inline void Login::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Login.password)
}
inline std::string* Login::mutable_password() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Login.password)
  return _internal_mutable_password();
}
inline const std::string& Login::_internal_password() const {
  return password_.GetNoArena();
}
inline void Login::_internal_set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Login::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.Login.password)
}
inline void Login::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.Login.password)
}
inline void Login::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.Login.password)
}
inline std::string* Login::_internal_mutable_password() {
  
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Login::release_password() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Login.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Login.password)
}

// .vts.protocol.main.RoleContainerType type = 3;
inline void Login::clear_type() {
  type_ = 0;
}
inline ::vts::protocol::main::RoleContainerType Login::_internal_type() const {
  return static_cast< ::vts::protocol::main::RoleContainerType >(type_);
}
inline ::vts::protocol::main::RoleContainerType Login::type() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Login.type)
  return _internal_type();
}
inline void Login::_internal_set_type(::vts::protocol::main::RoleContainerType value) {
  
  type_ = value;
}
inline void Login::set_type(::vts::protocol::main::RoleContainerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Login.type)
}

// -------------------------------------------------------------------

// Logout

// string reason = 1;
inline void Logout::clear_reason() {
  reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Logout::reason() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Logout.reason)
  return _internal_reason();
}
inline void Logout::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Logout.reason)
}
inline std::string* Logout::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Logout.reason)
  return _internal_mutable_reason();
}
inline const std::string& Logout::_internal_reason() const {
  return reason_.GetNoArena();
}
inline void Logout::_internal_set_reason(const std::string& value) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Logout::set_reason(std::string&& value) {
  
  reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.Logout.reason)
}
inline void Logout::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.Logout.reason)
}
inline void Logout::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.Logout.reason)
}
inline std::string* Logout::_internal_mutable_reason() {
  
  return reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Logout::release_reason() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Logout.reason)
  
  return reason_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Logout::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Logout.reason)
}

// -------------------------------------------------------------------

// AccountResult

// .vts.protocol.main.AccountOPType op = 1;
inline void AccountResult::clear_op() {
  op_ = 0;
}
inline ::vts::protocol::main::AccountOPType AccountResult::_internal_op() const {
  return static_cast< ::vts::protocol::main::AccountOPType >(op_);
}
inline ::vts::protocol::main::AccountOPType AccountResult::op() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.AccountResult.op)
  return _internal_op();
}
inline void AccountResult::_internal_set_op(::vts::protocol::main::AccountOPType value) {
  
  op_ = value;
}
inline void AccountResult::set_op(::vts::protocol::main::AccountOPType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.AccountResult.op)
}

// bool result = 2;
inline void AccountResult::clear_result() {
  result_ = false;
}
inline bool AccountResult::_internal_result() const {
  return result_;
}
inline bool AccountResult::result() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.AccountResult.result)
  return _internal_result();
}
inline void AccountResult::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void AccountResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.AccountResult.result)
}

// string version = 3;
inline void AccountResult::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AccountResult::version() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.AccountResult.version)
  return _internal_version();
}
inline void AccountResult::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.AccountResult.version)
}
inline std::string* AccountResult::mutable_version() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.AccountResult.version)
  return _internal_mutable_version();
}
inline const std::string& AccountResult::_internal_version() const {
  return version_.GetNoArena();
}
inline void AccountResult::_internal_set_version(const std::string& value) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AccountResult::set_version(std::string&& value) {
  
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.AccountResult.version)
}
inline void AccountResult::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.AccountResult.version)
}
inline void AccountResult::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.AccountResult.version)
}
inline std::string* AccountResult::_internal_mutable_version() {
  
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AccountResult::release_version() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.AccountResult.version)
  
  return version_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AccountResult::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.AccountResult.version)
}

// string reason = 4;
inline void AccountResult::clear_reason() {
  reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AccountResult::reason() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.AccountResult.reason)
  return _internal_reason();
}
inline void AccountResult::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.AccountResult.reason)
}
inline std::string* AccountResult::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.AccountResult.reason)
  return _internal_mutable_reason();
}
inline const std::string& AccountResult::_internal_reason() const {
  return reason_.GetNoArena();
}
inline void AccountResult::_internal_set_reason(const std::string& value) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AccountResult::set_reason(std::string&& value) {
  
  reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.AccountResult.reason)
}
inline void AccountResult::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.AccountResult.reason)
}
inline void AccountResult::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.AccountResult.reason)
}
inline std::string* AccountResult::_internal_mutable_reason() {
  
  return reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AccountResult::release_reason() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.AccountResult.reason)
  
  return reason_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AccountResult::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.AccountResult.reason)
}

// -------------------------------------------------------------------

// TryTest

// string case_file_id = 1;
inline void TryTest::clear_case_file_id() {
  case_file_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TryTest::case_file_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryTest.case_file_id)
  return _internal_case_file_id();
}
inline void TryTest::set_case_file_id(const std::string& value) {
  _internal_set_case_file_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryTest.case_file_id)
}
inline std::string* TryTest::mutable_case_file_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.TryTest.case_file_id)
  return _internal_mutable_case_file_id();
}
inline const std::string& TryTest::_internal_case_file_id() const {
  return case_file_id_.GetNoArena();
}
inline void TryTest::_internal_set_case_file_id(const std::string& value) {
  
  case_file_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TryTest::set_case_file_id(std::string&& value) {
  
  case_file_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.TryTest.case_file_id)
}
inline void TryTest::set_case_file_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  case_file_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.TryTest.case_file_id)
}
inline void TryTest::set_case_file_id(const char* value, size_t size) {
  
  case_file_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.TryTest.case_file_id)
}
inline std::string* TryTest::_internal_mutable_case_file_id() {
  
  return case_file_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TryTest::release_case_file_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.TryTest.case_file_id)
  
  return case_file_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TryTest::set_allocated_case_file_id(std::string* case_file_id) {
  if (case_file_id != nullptr) {
    
  } else {
    
  }
  case_file_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), case_file_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.TryTest.case_file_id)
}

// -------------------------------------------------------------------

// TryReplay

// string test_record_id = 1;
inline void TryReplay::clear_test_record_id() {
  test_record_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TryReplay::test_record_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryReplay.test_record_id)
  return _internal_test_record_id();
}
inline void TryReplay::set_test_record_id(const std::string& value) {
  _internal_set_test_record_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryReplay.test_record_id)
}
inline std::string* TryReplay::mutable_test_record_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.TryReplay.test_record_id)
  return _internal_mutable_test_record_id();
}
inline const std::string& TryReplay::_internal_test_record_id() const {
  return test_record_id_.GetNoArena();
}
inline void TryReplay::_internal_set_test_record_id(const std::string& value) {
  
  test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TryReplay::set_test_record_id(std::string&& value) {
  
  test_record_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.TryReplay.test_record_id)
}
inline void TryReplay::set_test_record_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.TryReplay.test_record_id)
}
inline void TryReplay::set_test_record_id(const char* value, size_t size) {
  
  test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.TryReplay.test_record_id)
}
inline std::string* TryReplay::_internal_mutable_test_record_id() {
  
  return test_record_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TryReplay::release_test_record_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.TryReplay.test_record_id)
  
  return test_record_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TryReplay::set_allocated_test_record_id(std::string* test_record_id) {
  if (test_record_id != nullptr) {
    
  } else {
    
  }
  test_record_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), test_record_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.TryReplay.test_record_id)
}

// -------------------------------------------------------------------

// TryResult

// string session_id = 1;
inline void TryResult::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TryResult::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryResult.session_id)
  return _internal_session_id();
}
inline void TryResult::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.session_id)
}
inline std::string* TryResult::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.TryResult.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& TryResult::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void TryResult::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TryResult::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.TryResult.session_id)
}
inline void TryResult::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.TryResult.session_id)
}
inline void TryResult::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.TryResult.session_id)
}
inline std::string* TryResult::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TryResult::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.TryResult.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TryResult::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.TryResult.session_id)
}

// bool result = 2;
inline void TryResult::clear_result() {
  result_ = false;
}
inline bool TryResult::_internal_result() const {
  return result_;
}
inline bool TryResult::result() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryResult.result)
  return _internal_result();
}
inline void TryResult::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void TryResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.result)
}

// int32 progress = 3;
inline void TryResult::clear_progress() {
  progress_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TryResult::_internal_progress() const {
  return progress_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TryResult::progress() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryResult.progress)
  return _internal_progress();
}
inline void TryResult::_internal_set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  progress_ = value;
}
inline void TryResult::set_progress(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.progress)
}

// int32 wait_second = 4;
inline void TryResult::clear_wait_second() {
  wait_second_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TryResult::_internal_wait_second() const {
  return wait_second_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TryResult::wait_second() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryResult.wait_second)
  return _internal_wait_second();
}
inline void TryResult::_internal_set_wait_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  wait_second_ = value;
}
inline void TryResult::set_wait_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wait_second(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.wait_second)
}

// string reason = 5;
inline void TryResult::clear_reason() {
  reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TryResult::reason() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryResult.reason)
  return _internal_reason();
}
inline void TryResult::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.reason)
}
inline std::string* TryResult::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.TryResult.reason)
  return _internal_mutable_reason();
}
inline const std::string& TryResult::_internal_reason() const {
  return reason_.GetNoArena();
}
inline void TryResult::_internal_set_reason(const std::string& value) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TryResult::set_reason(std::string&& value) {
  
  reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.TryResult.reason)
}
inline void TryResult::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.TryResult.reason)
}
inline void TryResult::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.TryResult.reason)
}
inline std::string* TryResult::_internal_mutable_reason() {
  
  return reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TryResult::release_reason() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.TryResult.reason)
  
  return reason_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TryResult::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.TryResult.reason)
}

// string case_file_id = 6;
inline bool TryResult::_internal_has_case_file_id() const {
  return archive_id_case() == kCaseFileId;
}
inline void TryResult::set_has_case_file_id() {
  _oneof_case_[0] = kCaseFileId;
}
inline void TryResult::clear_case_file_id() {
  if (_internal_has_case_file_id()) {
    archive_id_.case_file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_archive_id();
  }
}
inline const std::string& TryResult::case_file_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryResult.case_file_id)
  return _internal_case_file_id();
}
inline void TryResult::set_case_file_id(const std::string& value) {
  _internal_set_case_file_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.case_file_id)
}
inline std::string* TryResult::mutable_case_file_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.TryResult.case_file_id)
  return _internal_mutable_case_file_id();
}
inline const std::string& TryResult::_internal_case_file_id() const {
  if (_internal_has_case_file_id()) {
    return archive_id_.case_file_id_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TryResult::_internal_set_case_file_id(const std::string& value) {
  if (!_internal_has_case_file_id()) {
    clear_archive_id();
    set_has_case_file_id();
    archive_id_.case_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  archive_id_.case_file_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TryResult::set_case_file_id(std::string&& value) {
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.case_file_id)
  if (!_internal_has_case_file_id()) {
    clear_archive_id();
    set_has_case_file_id();
    archive_id_.case_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  archive_id_.case_file_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.TryResult.case_file_id)
}
inline void TryResult::set_case_file_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_case_file_id()) {
    clear_archive_id();
    set_has_case_file_id();
    archive_id_.case_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  archive_id_.case_file_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.TryResult.case_file_id)
}
inline void TryResult::set_case_file_id(const char* value, size_t size) {
  if (!_internal_has_case_file_id()) {
    clear_archive_id();
    set_has_case_file_id();
    archive_id_.case_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  archive_id_.case_file_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.TryResult.case_file_id)
}
inline std::string* TryResult::_internal_mutable_case_file_id() {
  if (!_internal_has_case_file_id()) {
    clear_archive_id();
    set_has_case_file_id();
    archive_id_.case_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return archive_id_.case_file_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TryResult::release_case_file_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.TryResult.case_file_id)
  if (_internal_has_case_file_id()) {
    clear_has_archive_id();
    return archive_id_.case_file_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void TryResult::set_allocated_case_file_id(std::string* case_file_id) {
  if (has_archive_id()) {
    clear_archive_id();
  }
  if (case_file_id != nullptr) {
    set_has_case_file_id();
    archive_id_.case_file_id_.UnsafeSetDefault(case_file_id);
  }
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.TryResult.case_file_id)
}

// string test_record_id = 7;
inline bool TryResult::_internal_has_test_record_id() const {
  return archive_id_case() == kTestRecordId;
}
inline void TryResult::set_has_test_record_id() {
  _oneof_case_[0] = kTestRecordId;
}
inline void TryResult::clear_test_record_id() {
  if (_internal_has_test_record_id()) {
    archive_id_.test_record_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_archive_id();
  }
}
inline const std::string& TryResult::test_record_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.TryResult.test_record_id)
  return _internal_test_record_id();
}
inline void TryResult::set_test_record_id(const std::string& value) {
  _internal_set_test_record_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.test_record_id)
}
inline std::string* TryResult::mutable_test_record_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.TryResult.test_record_id)
  return _internal_mutable_test_record_id();
}
inline const std::string& TryResult::_internal_test_record_id() const {
  if (_internal_has_test_record_id()) {
    return archive_id_.test_record_id_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TryResult::_internal_set_test_record_id(const std::string& value) {
  if (!_internal_has_test_record_id()) {
    clear_archive_id();
    set_has_test_record_id();
    archive_id_.test_record_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  archive_id_.test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TryResult::set_test_record_id(std::string&& value) {
  // @@protoc_insertion_point(field_set:vts.protocol.main.TryResult.test_record_id)
  if (!_internal_has_test_record_id()) {
    clear_archive_id();
    set_has_test_record_id();
    archive_id_.test_record_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  archive_id_.test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.TryResult.test_record_id)
}
inline void TryResult::set_test_record_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_test_record_id()) {
    clear_archive_id();
    set_has_test_record_id();
    archive_id_.test_record_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  archive_id_.test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.TryResult.test_record_id)
}
inline void TryResult::set_test_record_id(const char* value, size_t size) {
  if (!_internal_has_test_record_id()) {
    clear_archive_id();
    set_has_test_record_id();
    archive_id_.test_record_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  archive_id_.test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.TryResult.test_record_id)
}
inline std::string* TryResult::_internal_mutable_test_record_id() {
  if (!_internal_has_test_record_id()) {
    clear_archive_id();
    set_has_test_record_id();
    archive_id_.test_record_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return archive_id_.test_record_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TryResult::release_test_record_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.TryResult.test_record_id)
  if (_internal_has_test_record_id()) {
    clear_has_archive_id();
    return archive_id_.test_record_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void TryResult::set_allocated_test_record_id(std::string* test_record_id) {
  if (has_archive_id()) {
    clear_archive_id();
  }
  if (test_record_id != nullptr) {
    set_has_test_record_id();
    archive_id_.test_record_id_.UnsafeSetDefault(test_record_id);
  }
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.TryResult.test_record_id)
}

inline bool TryResult::has_archive_id() const {
  return archive_id_case() != ARCHIVE_ID_NOT_SET;
}
inline void TryResult::clear_has_archive_id() {
  _oneof_case_[0] = ARCHIVE_ID_NOT_SET;
}
inline TryResult::ArchiveIdCase TryResult::archive_id_case() const {
  return TryResult::ArchiveIdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SessionInfo

// .vts.protocol.main.SimHeader header = 1;
inline bool SessionInfo::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SessionInfo::has_header() const {
  return _internal_has_header();
}
inline const ::vts::protocol::main::SimHeader& SessionInfo::_internal_header() const {
  const ::vts::protocol::main::SimHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::SimHeader*>(
      &::vts::protocol::main::_SimHeader_default_instance_);
}
inline const ::vts::protocol::main::SimHeader& SessionInfo::header() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionInfo.header)
  return _internal_header();
}
inline ::vts::protocol::main::SimHeader* SessionInfo::release_header() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SessionInfo.header)
  
  ::vts::protocol::main::SimHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::SimHeader* SessionInfo::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::SimHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::vts::protocol::main::SimHeader* SessionInfo::mutable_header() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SessionInfo.header)
  return _internal_mutable_header();
}
inline void SessionInfo::set_allocated_header(::vts::protocol::main::SimHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SessionInfo.header)
}

// string session_id = 2;
inline void SessionInfo::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SessionInfo::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionInfo.session_id)
  return _internal_session_id();
}
inline void SessionInfo::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SessionInfo.session_id)
}
inline std::string* SessionInfo::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SessionInfo.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& SessionInfo::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void SessionInfo::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SessionInfo::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SessionInfo.session_id)
}
inline void SessionInfo::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SessionInfo.session_id)
}
inline void SessionInfo::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SessionInfo.session_id)
}
inline std::string* SessionInfo::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionInfo::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SessionInfo.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionInfo::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SessionInfo.session_id)
}

// float percent = 3;
inline void SessionInfo::clear_percent() {
  percent_ = 0;
}
inline float SessionInfo::_internal_percent() const {
  return percent_;
}
inline float SessionInfo::percent() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionInfo.percent)
  return _internal_percent();
}
inline void SessionInfo::_internal_set_percent(float value) {
  
  percent_ = value;
}
inline void SessionInfo::set_percent(float value) {
  _internal_set_percent(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SessionInfo.percent)
}

// int64 session_time = 4;
inline void SessionInfo::clear_session_time() {
  session_time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SessionInfo::_internal_session_time() const {
  return session_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SessionInfo::session_time() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionInfo.session_time)
  return _internal_session_time();
}
inline void SessionInfo::_internal_set_session_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  session_time_ = value;
}
inline void SessionInfo::set_session_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_session_time(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SessionInfo.session_time)
}

// repeated .vts.protocol.main.RoleContainerInfo clients = 5;
inline int SessionInfo::_internal_clients_size() const {
  return clients_.size();
}
inline int SessionInfo::clients_size() const {
  return _internal_clients_size();
}
inline ::vts::protocol::main::RoleContainerInfo* SessionInfo::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SessionInfo.clients)
  return clients_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::RoleContainerInfo >*
SessionInfo::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.SessionInfo.clients)
  return &clients_;
}
inline const ::vts::protocol::main::RoleContainerInfo& SessionInfo::_internal_clients(int index) const {
  return clients_.Get(index);
}
inline const ::vts::protocol::main::RoleContainerInfo& SessionInfo::clients(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionInfo.clients)
  return _internal_clients(index);
}
inline ::vts::protocol::main::RoleContainerInfo* SessionInfo::_internal_add_clients() {
  return clients_.Add();
}
inline ::vts::protocol::main::RoleContainerInfo* SessionInfo::add_clients() {
  // @@protoc_insertion_point(field_add:vts.protocol.main.SessionInfo.clients)
  return _internal_add_clients();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::RoleContainerInfo >&
SessionInfo::clients() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.SessionInfo.clients)
  return clients_;
}

// -------------------------------------------------------------------

// FetchSessionTestResult

// string session_id = 1;
inline void FetchSessionTestResult::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FetchSessionTestResult::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.FetchSessionTestResult.session_id)
  return _internal_session_id();
}
inline void FetchSessionTestResult::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.FetchSessionTestResult.session_id)
}
inline std::string* FetchSessionTestResult::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.FetchSessionTestResult.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& FetchSessionTestResult::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void FetchSessionTestResult::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void FetchSessionTestResult::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.FetchSessionTestResult.session_id)
}
inline void FetchSessionTestResult::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.FetchSessionTestResult.session_id)
}
inline void FetchSessionTestResult::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.FetchSessionTestResult.session_id)
}
inline std::string* FetchSessionTestResult::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FetchSessionTestResult::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.FetchSessionTestResult.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FetchSessionTestResult::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.FetchSessionTestResult.session_id)
}

// -------------------------------------------------------------------

// SessionTestResult

// .vts.protocol.main.SimHeader header = 1;
inline bool SessionTestResult::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SessionTestResult::has_header() const {
  return _internal_has_header();
}
inline const ::vts::protocol::main::SimHeader& SessionTestResult::_internal_header() const {
  const ::vts::protocol::main::SimHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::SimHeader*>(
      &::vts::protocol::main::_SimHeader_default_instance_);
}
inline const ::vts::protocol::main::SimHeader& SessionTestResult::header() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionTestResult.header)
  return _internal_header();
}
inline ::vts::protocol::main::SimHeader* SessionTestResult::release_header() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SessionTestResult.header)
  
  ::vts::protocol::main::SimHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::SimHeader* SessionTestResult::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::SimHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::vts::protocol::main::SimHeader* SessionTestResult::mutable_header() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SessionTestResult.header)
  return _internal_mutable_header();
}
inline void SessionTestResult::set_allocated_header(::vts::protocol::main::SimHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SessionTestResult.header)
}

// string session_id = 2;
inline void SessionTestResult::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SessionTestResult::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionTestResult.session_id)
  return _internal_session_id();
}
inline void SessionTestResult::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SessionTestResult.session_id)
}
inline std::string* SessionTestResult::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SessionTestResult.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& SessionTestResult::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void SessionTestResult::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SessionTestResult::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SessionTestResult.session_id)
}
inline void SessionTestResult::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SessionTestResult.session_id)
}
inline void SessionTestResult::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SessionTestResult.session_id)
}
inline std::string* SessionTestResult::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionTestResult::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SessionTestResult.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionTestResult::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SessionTestResult.session_id)
}

// string test_record_id = 3;
inline void SessionTestResult::clear_test_record_id() {
  test_record_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SessionTestResult::test_record_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionTestResult.test_record_id)
  return _internal_test_record_id();
}
inline void SessionTestResult::set_test_record_id(const std::string& value) {
  _internal_set_test_record_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SessionTestResult.test_record_id)
}
inline std::string* SessionTestResult::mutable_test_record_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SessionTestResult.test_record_id)
  return _internal_mutable_test_record_id();
}
inline const std::string& SessionTestResult::_internal_test_record_id() const {
  return test_record_id_.GetNoArena();
}
inline void SessionTestResult::_internal_set_test_record_id(const std::string& value) {
  
  test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SessionTestResult::set_test_record_id(std::string&& value) {
  
  test_record_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SessionTestResult.test_record_id)
}
inline void SessionTestResult::set_test_record_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SessionTestResult.test_record_id)
}
inline void SessionTestResult::set_test_record_id(const char* value, size_t size) {
  
  test_record_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SessionTestResult.test_record_id)
}
inline std::string* SessionTestResult::_internal_mutable_test_record_id() {
  
  return test_record_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionTestResult::release_test_record_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SessionTestResult.test_record_id)
  
  return test_record_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionTestResult::set_allocated_test_record_id(std::string* test_record_id) {
  if (test_record_id != nullptr) {
    
  } else {
    
  }
  test_record_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), test_record_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SessionTestResult.test_record_id)
}

// string result_url = 4;
inline void SessionTestResult::clear_result_url() {
  result_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SessionTestResult::result_url() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SessionTestResult.result_url)
  return _internal_result_url();
}
inline void SessionTestResult::set_result_url(const std::string& value) {
  _internal_set_result_url(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SessionTestResult.result_url)
}
inline std::string* SessionTestResult::mutable_result_url() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SessionTestResult.result_url)
  return _internal_mutable_result_url();
}
inline const std::string& SessionTestResult::_internal_result_url() const {
  return result_url_.GetNoArena();
}
inline void SessionTestResult::_internal_set_result_url(const std::string& value) {
  
  result_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SessionTestResult::set_result_url(std::string&& value) {
  
  result_url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SessionTestResult.result_url)
}
inline void SessionTestResult::set_result_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  result_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SessionTestResult.result_url)
}
inline void SessionTestResult::set_result_url(const char* value, size_t size) {
  
  result_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SessionTestResult.result_url)
}
inline std::string* SessionTestResult::_internal_mutable_result_url() {
  
  return result_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionTestResult::release_result_url() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SessionTestResult.result_url)
  
  return result_url_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionTestResult::set_allocated_result_url(std::string* result_url) {
  if (result_url != nullptr) {
    
  } else {
    
  }
  result_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result_url);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SessionTestResult.result_url)
}

// -------------------------------------------------------------------

// DebugSession

// string session_id = 1;
inline void DebugSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DebugSession::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.DebugSession.session_id)
  return _internal_session_id();
}
inline void DebugSession::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.DebugSession.session_id)
}
inline std::string* DebugSession::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.DebugSession.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& DebugSession::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void DebugSession::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DebugSession::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.DebugSession.session_id)
}
inline void DebugSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.DebugSession.session_id)
}
inline void DebugSession::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.DebugSession.session_id)
}
inline std::string* DebugSession::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DebugSession::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.DebugSession.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DebugSession::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.DebugSession.session_id)
}

// repeated uint32 params = 2;
inline int DebugSession::_internal_params_size() const {
  return params_.size();
}
inline int DebugSession::params_size() const {
  return _internal_params_size();
}
inline void DebugSession::clear_params() {
  params_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DebugSession::_internal_params(int index) const {
  return params_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DebugSession::params(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.DebugSession.params)
  return _internal_params(index);
}
inline void DebugSession::set_params(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  params_.Set(index, value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.DebugSession.params)
}
inline void DebugSession::_internal_add_params(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  params_.Add(value);
}
inline void DebugSession::add_params(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_params(value);
  // @@protoc_insertion_point(field_add:vts.protocol.main.DebugSession.params)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
DebugSession::_internal_params() const {
  return params_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
DebugSession::params() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.DebugSession.params)
  return _internal_params();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
DebugSession::_internal_mutable_params() {
  return &params_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
DebugSession::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.DebugSession.params)
  return _internal_mutable_params();
}

// -------------------------------------------------------------------

// DebugSessionResult

// string session_id = 1;
inline void DebugSessionResult::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DebugSessionResult::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.DebugSessionResult.session_id)
  return _internal_session_id();
}
inline void DebugSessionResult::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.DebugSessionResult.session_id)
}
inline std::string* DebugSessionResult::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.DebugSessionResult.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& DebugSessionResult::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void DebugSessionResult::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DebugSessionResult::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.DebugSessionResult.session_id)
}
inline void DebugSessionResult::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.DebugSessionResult.session_id)
}
inline void DebugSessionResult::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.DebugSessionResult.session_id)
}
inline std::string* DebugSessionResult::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DebugSessionResult::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.DebugSessionResult.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DebugSessionResult::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.DebugSessionResult.session_id)
}

// bool result = 2;
inline void DebugSessionResult::clear_result() {
  result_ = false;
}
inline bool DebugSessionResult::_internal_result() const {
  return result_;
}
inline bool DebugSessionResult::result() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.DebugSessionResult.result)
  return _internal_result();
}
inline void DebugSessionResult::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void DebugSessionResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.DebugSessionResult.result)
}

// string reason = 3;
inline void DebugSessionResult::clear_reason() {
  reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DebugSessionResult::reason() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.DebugSessionResult.reason)
  return _internal_reason();
}
inline void DebugSessionResult::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.DebugSessionResult.reason)
}
inline std::string* DebugSessionResult::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.DebugSessionResult.reason)
  return _internal_mutable_reason();
}
inline const std::string& DebugSessionResult::_internal_reason() const {
  return reason_.GetNoArena();
}
inline void DebugSessionResult::_internal_set_reason(const std::string& value) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DebugSessionResult::set_reason(std::string&& value) {
  
  reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.DebugSessionResult.reason)
}
inline void DebugSessionResult::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.DebugSessionResult.reason)
}
inline void DebugSessionResult::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.DebugSessionResult.reason)
}
inline std::string* DebugSessionResult::_internal_mutable_reason() {
  
  return reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DebugSessionResult::release_reason() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.DebugSessionResult.reason)
  
  return reason_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DebugSessionResult::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.DebugSessionResult.reason)
}

// -------------------------------------------------------------------

// ActorPrepare

// string session_id = 1;
inline void ActorPrepare::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ActorPrepare::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ActorPrepare.session_id)
  return _internal_session_id();
}
inline void ActorPrepare::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ActorPrepare.session_id)
}
inline std::string* ActorPrepare::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ActorPrepare.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& ActorPrepare::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void ActorPrepare::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ActorPrepare::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.ActorPrepare.session_id)
}
inline void ActorPrepare::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.ActorPrepare.session_id)
}
inline void ActorPrepare::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.ActorPrepare.session_id)
}
inline std::string* ActorPrepare::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActorPrepare::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ActorPrepare.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActorPrepare::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ActorPrepare.session_id)
}

// string actor_id = 2;
inline void ActorPrepare::clear_actor_id() {
  actor_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ActorPrepare::actor_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ActorPrepare.actor_id)
  return _internal_actor_id();
}
inline void ActorPrepare::set_actor_id(const std::string& value) {
  _internal_set_actor_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ActorPrepare.actor_id)
}
inline std::string* ActorPrepare::mutable_actor_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ActorPrepare.actor_id)
  return _internal_mutable_actor_id();
}
inline const std::string& ActorPrepare::_internal_actor_id() const {
  return actor_id_.GetNoArena();
}
inline void ActorPrepare::_internal_set_actor_id(const std::string& value) {
  
  actor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ActorPrepare::set_actor_id(std::string&& value) {
  
  actor_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.ActorPrepare.actor_id)
}
inline void ActorPrepare::set_actor_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  actor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.ActorPrepare.actor_id)
}
inline void ActorPrepare::set_actor_id(const char* value, size_t size) {
  
  actor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.ActorPrepare.actor_id)
}
inline std::string* ActorPrepare::_internal_mutable_actor_id() {
  
  return actor_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActorPrepare::release_actor_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ActorPrepare.actor_id)
  
  return actor_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActorPrepare::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  actor_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ActorPrepare.actor_id)
}

// .vts.protocol.main.ArchiveInfo archive_info = 3;
inline bool ActorPrepare::_internal_has_archive_info() const {
  return this != internal_default_instance() && archive_info_ != nullptr;
}
inline bool ActorPrepare::has_archive_info() const {
  return _internal_has_archive_info();
}
inline const ::vts::protocol::main::ArchiveInfo& ActorPrepare::_internal_archive_info() const {
  const ::vts::protocol::main::ArchiveInfo* p = archive_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::ArchiveInfo*>(
      &::vts::protocol::main::_ArchiveInfo_default_instance_);
}
inline const ::vts::protocol::main::ArchiveInfo& ActorPrepare::archive_info() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ActorPrepare.archive_info)
  return _internal_archive_info();
}
inline ::vts::protocol::main::ArchiveInfo* ActorPrepare::release_archive_info() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ActorPrepare.archive_info)
  
  ::vts::protocol::main::ArchiveInfo* temp = archive_info_;
  archive_info_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::ArchiveInfo* ActorPrepare::_internal_mutable_archive_info() {
  
  if (archive_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::ArchiveInfo>(GetArenaNoVirtual());
    archive_info_ = p;
  }
  return archive_info_;
}
inline ::vts::protocol::main::ArchiveInfo* ActorPrepare::mutable_archive_info() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ActorPrepare.archive_info)
  return _internal_mutable_archive_info();
}
inline void ActorPrepare::set_allocated_archive_info(::vts::protocol::main::ArchiveInfo* archive_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(archive_info_);
  }
  if (archive_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      archive_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, archive_info, submessage_arena);
    }
    
  } else {
    
  }
  archive_info_ = archive_info;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ActorPrepare.archive_info)
}

// -------------------------------------------------------------------

// ActorPrepareResult

// string session_id = 1;
inline void ActorPrepareResult::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ActorPrepareResult::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ActorPrepareResult.session_id)
  return _internal_session_id();
}
inline void ActorPrepareResult::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ActorPrepareResult.session_id)
}
inline std::string* ActorPrepareResult::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ActorPrepareResult.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& ActorPrepareResult::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void ActorPrepareResult::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ActorPrepareResult::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.ActorPrepareResult.session_id)
}
inline void ActorPrepareResult::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.ActorPrepareResult.session_id)
}
inline void ActorPrepareResult::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.ActorPrepareResult.session_id)
}
inline std::string* ActorPrepareResult::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActorPrepareResult::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ActorPrepareResult.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActorPrepareResult::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ActorPrepareResult.session_id)
}

// string actor_id = 2;
inline void ActorPrepareResult::clear_actor_id() {
  actor_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ActorPrepareResult::actor_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ActorPrepareResult.actor_id)
  return _internal_actor_id();
}
inline void ActorPrepareResult::set_actor_id(const std::string& value) {
  _internal_set_actor_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ActorPrepareResult.actor_id)
}
inline std::string* ActorPrepareResult::mutable_actor_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ActorPrepareResult.actor_id)
  return _internal_mutable_actor_id();
}
inline const std::string& ActorPrepareResult::_internal_actor_id() const {
  return actor_id_.GetNoArena();
}
inline void ActorPrepareResult::_internal_set_actor_id(const std::string& value) {
  
  actor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ActorPrepareResult::set_actor_id(std::string&& value) {
  
  actor_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.ActorPrepareResult.actor_id)
}
inline void ActorPrepareResult::set_actor_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  actor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.ActorPrepareResult.actor_id)
}
inline void ActorPrepareResult::set_actor_id(const char* value, size_t size) {
  
  actor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.ActorPrepareResult.actor_id)
}
inline std::string* ActorPrepareResult::_internal_mutable_actor_id() {
  
  return actor_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActorPrepareResult::release_actor_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ActorPrepareResult.actor_id)
  
  return actor_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActorPrepareResult::set_allocated_actor_id(std::string* actor_id) {
  if (actor_id != nullptr) {
    
  } else {
    
  }
  actor_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actor_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ActorPrepareResult.actor_id)
}

// bool result = 3;
inline void ActorPrepareResult::clear_result() {
  result_ = false;
}
inline bool ActorPrepareResult::_internal_result() const {
  return result_;
}
inline bool ActorPrepareResult::result() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ActorPrepareResult.result)
  return _internal_result();
}
inline void ActorPrepareResult::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void ActorPrepareResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ActorPrepareResult.result)
}

// string reason = 4;
inline void ActorPrepareResult::clear_reason() {
  reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ActorPrepareResult::reason() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ActorPrepareResult.reason)
  return _internal_reason();
}
inline void ActorPrepareResult::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.ActorPrepareResult.reason)
}
inline std::string* ActorPrepareResult::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ActorPrepareResult.reason)
  return _internal_mutable_reason();
}
inline const std::string& ActorPrepareResult::_internal_reason() const {
  return reason_.GetNoArena();
}
inline void ActorPrepareResult::_internal_set_reason(const std::string& value) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ActorPrepareResult::set_reason(std::string&& value) {
  
  reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.ActorPrepareResult.reason)
}
inline void ActorPrepareResult::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.ActorPrepareResult.reason)
}
inline void ActorPrepareResult::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.ActorPrepareResult.reason)
}
inline std::string* ActorPrepareResult::_internal_mutable_reason() {
  
  return reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActorPrepareResult::release_reason() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.ActorPrepareResult.reason)
  
  return reason_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActorPrepareResult::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.ActorPrepareResult.reason)
}

// -------------------------------------------------------------------

// QueryArchiveInfo

// .vts.protocol.main.ArchiveType type = 1;
inline void QueryArchiveInfo::clear_type() {
  type_ = 0;
}
inline ::vts::protocol::main::ArchiveType QueryArchiveInfo::_internal_type() const {
  return static_cast< ::vts::protocol::main::ArchiveType >(type_);
}
inline ::vts::protocol::main::ArchiveType QueryArchiveInfo::type() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.QueryArchiveInfo.type)
  return _internal_type();
}
inline void QueryArchiveInfo::_internal_set_type(::vts::protocol::main::ArchiveType value) {
  
  type_ = value;
}
inline void QueryArchiveInfo::set_type(::vts::protocol::main::ArchiveType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.QueryArchiveInfo.type)
}

// string condition = 2;
inline void QueryArchiveInfo::clear_condition() {
  condition_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& QueryArchiveInfo::condition() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.QueryArchiveInfo.condition)
  return _internal_condition();
}
inline void QueryArchiveInfo::set_condition(const std::string& value) {
  _internal_set_condition(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.QueryArchiveInfo.condition)
}
inline std::string* QueryArchiveInfo::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.QueryArchiveInfo.condition)
  return _internal_mutable_condition();
}
inline const std::string& QueryArchiveInfo::_internal_condition() const {
  return condition_.GetNoArena();
}
inline void QueryArchiveInfo::_internal_set_condition(const std::string& value) {
  
  condition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void QueryArchiveInfo::set_condition(std::string&& value) {
  
  condition_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.QueryArchiveInfo.condition)
}
inline void QueryArchiveInfo::set_condition(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  condition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.QueryArchiveInfo.condition)
}
inline void QueryArchiveInfo::set_condition(const char* value, size_t size) {
  
  condition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.QueryArchiveInfo.condition)
}
inline std::string* QueryArchiveInfo::_internal_mutable_condition() {
  
  return condition_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* QueryArchiveInfo::release_condition() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.QueryArchiveInfo.condition)
  
  return condition_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void QueryArchiveInfo::set_allocated_condition(std::string* condition) {
  if (condition != nullptr) {
    
  } else {
    
  }
  condition_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), condition);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.QueryArchiveInfo.condition)
}

// -------------------------------------------------------------------

// ArchiveInfoList

// repeated .vts.protocol.main.ArchiveInfo archive_info_list = 1;
inline int ArchiveInfoList::_internal_archive_info_list_size() const {
  return archive_info_list_.size();
}
inline int ArchiveInfoList::archive_info_list_size() const {
  return _internal_archive_info_list_size();
}
inline ::vts::protocol::main::ArchiveInfo* ArchiveInfoList::mutable_archive_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.ArchiveInfoList.archive_info_list)
  return archive_info_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::ArchiveInfo >*
ArchiveInfoList::mutable_archive_info_list() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.ArchiveInfoList.archive_info_list)
  return &archive_info_list_;
}
inline const ::vts::protocol::main::ArchiveInfo& ArchiveInfoList::_internal_archive_info_list(int index) const {
  return archive_info_list_.Get(index);
}
inline const ::vts::protocol::main::ArchiveInfo& ArchiveInfoList::archive_info_list(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.ArchiveInfoList.archive_info_list)
  return _internal_archive_info_list(index);
}
inline ::vts::protocol::main::ArchiveInfo* ArchiveInfoList::_internal_add_archive_info_list() {
  return archive_info_list_.Add();
}
inline ::vts::protocol::main::ArchiveInfo* ArchiveInfoList::add_archive_info_list() {
  // @@protoc_insertion_point(field_add:vts.protocol.main.ArchiveInfoList.archive_info_list)
  return _internal_add_archive_info_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::ArchiveInfo >&
ArchiveInfoList::archive_info_list() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.ArchiveInfoList.archive_info_list)
  return archive_info_list_;
}

// -------------------------------------------------------------------

// SubRole

// string session_id = 1;
inline void SubRole::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SubRole::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SubRole.session_id)
  return _internal_session_id();
}
inline void SubRole::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SubRole.session_id)
}
inline std::string* SubRole::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SubRole.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& SubRole::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void SubRole::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SubRole::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SubRole.session_id)
}
inline void SubRole::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SubRole.session_id)
}
inline void SubRole::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SubRole.session_id)
}
inline std::string* SubRole::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SubRole::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SubRole.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SubRole::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SubRole.session_id)
}

// repeated string role_types = 2;
inline int SubRole::_internal_role_types_size() const {
  return role_types_.size();
}
inline int SubRole::role_types_size() const {
  return _internal_role_types_size();
}
inline void SubRole::clear_role_types() {
  role_types_.Clear();
}
inline std::string* SubRole::add_role_types() {
  // @@protoc_insertion_point(field_add_mutable:vts.protocol.main.SubRole.role_types)
  return _internal_add_role_types();
}
inline const std::string& SubRole::_internal_role_types(int index) const {
  return role_types_.Get(index);
}
inline const std::string& SubRole::role_types(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SubRole.role_types)
  return _internal_role_types(index);
}
inline std::string* SubRole::mutable_role_types(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SubRole.role_types)
  return role_types_.Mutable(index);
}
inline void SubRole::set_role_types(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vts.protocol.main.SubRole.role_types)
  role_types_.Mutable(index)->assign(value);
}
inline void SubRole::set_role_types(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vts.protocol.main.SubRole.role_types)
  role_types_.Mutable(index)->assign(std::move(value));
}
inline void SubRole::set_role_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  role_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SubRole.role_types)
}
inline void SubRole::set_role_types(int index, const char* value, size_t size) {
  role_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SubRole.role_types)
}
inline std::string* SubRole::_internal_add_role_types() {
  return role_types_.Add();
}
inline void SubRole::add_role_types(const std::string& value) {
  role_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vts.protocol.main.SubRole.role_types)
}
inline void SubRole::add_role_types(std::string&& value) {
  role_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vts.protocol.main.SubRole.role_types)
}
inline void SubRole::add_role_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  role_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vts.protocol.main.SubRole.role_types)
}
inline void SubRole::add_role_types(const char* value, size_t size) {
  role_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vts.protocol.main.SubRole.role_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubRole::role_types() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.SubRole.role_types)
  return role_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubRole::mutable_role_types() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.SubRole.role_types)
  return &role_types_;
}

// repeated string role_ids = 3;
inline int SubRole::_internal_role_ids_size() const {
  return role_ids_.size();
}
inline int SubRole::role_ids_size() const {
  return _internal_role_ids_size();
}
inline void SubRole::clear_role_ids() {
  role_ids_.Clear();
}
inline std::string* SubRole::add_role_ids() {
  // @@protoc_insertion_point(field_add_mutable:vts.protocol.main.SubRole.role_ids)
  return _internal_add_role_ids();
}
inline const std::string& SubRole::_internal_role_ids(int index) const {
  return role_ids_.Get(index);
}
inline const std::string& SubRole::role_ids(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SubRole.role_ids)
  return _internal_role_ids(index);
}
inline std::string* SubRole::mutable_role_ids(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SubRole.role_ids)
  return role_ids_.Mutable(index);
}
inline void SubRole::set_role_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vts.protocol.main.SubRole.role_ids)
  role_ids_.Mutable(index)->assign(value);
}
inline void SubRole::set_role_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vts.protocol.main.SubRole.role_ids)
  role_ids_.Mutable(index)->assign(std::move(value));
}
inline void SubRole::set_role_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  role_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SubRole.role_ids)
}
inline void SubRole::set_role_ids(int index, const char* value, size_t size) {
  role_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SubRole.role_ids)
}
inline std::string* SubRole::_internal_add_role_ids() {
  return role_ids_.Add();
}
inline void SubRole::add_role_ids(const std::string& value) {
  role_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vts.protocol.main.SubRole.role_ids)
}
inline void SubRole::add_role_ids(std::string&& value) {
  role_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vts.protocol.main.SubRole.role_ids)
}
inline void SubRole::add_role_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  role_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vts.protocol.main.SubRole.role_ids)
}
inline void SubRole::add_role_ids(const char* value, size_t size) {
  role_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vts.protocol.main.SubRole.role_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubRole::role_ids() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.SubRole.role_ids)
  return role_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubRole::mutable_role_ids() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.SubRole.role_ids)
  return &role_ids_;
}

// repeated .vts.protocol.main.AOIInfo role_AOIs = 4;
inline int SubRole::_internal_role_aois_size() const {
  return role_aois_.size();
}
inline int SubRole::role_aois_size() const {
  return _internal_role_aois_size();
}
inline ::vts::protocol::main::AOIInfo* SubRole::mutable_role_aois(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SubRole.role_AOIs)
  return role_aois_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::AOIInfo >*
SubRole::mutable_role_aois() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.SubRole.role_AOIs)
  return &role_aois_;
}
inline const ::vts::protocol::main::AOIInfo& SubRole::_internal_role_aois(int index) const {
  return role_aois_.Get(index);
}
inline const ::vts::protocol::main::AOIInfo& SubRole::role_aois(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SubRole.role_AOIs)
  return _internal_role_aois(index);
}
inline ::vts::protocol::main::AOIInfo* SubRole::_internal_add_role_aois() {
  return role_aois_.Add();
}
inline ::vts::protocol::main::AOIInfo* SubRole::add_role_aois() {
  // @@protoc_insertion_point(field_add:vts.protocol.main.SubRole.role_AOIs)
  return _internal_add_role_aois();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::AOIInfo >&
SubRole::role_aois() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.SubRole.role_AOIs)
  return role_aois_;
}

// -------------------------------------------------------------------

// SubRoleResult

// bool result = 1;
inline void SubRoleResult::clear_result() {
  result_ = false;
}
inline bool SubRoleResult::_internal_result() const {
  return result_;
}
inline bool SubRoleResult::result() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SubRoleResult.result)
  return _internal_result();
}
inline void SubRoleResult::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void SubRoleResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SubRoleResult.result)
}

// string reason = 2;
inline void SubRoleResult::clear_reason() {
  reason_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SubRoleResult::reason() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SubRoleResult.reason)
  return _internal_reason();
}
inline void SubRoleResult::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SubRoleResult.reason)
}
inline std::string* SubRoleResult::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SubRoleResult.reason)
  return _internal_mutable_reason();
}
inline const std::string& SubRoleResult::_internal_reason() const {
  return reason_.GetNoArena();
}
inline void SubRoleResult::_internal_set_reason(const std::string& value) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SubRoleResult::set_reason(std::string&& value) {
  
  reason_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SubRoleResult.reason)
}
inline void SubRoleResult::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SubRoleResult.reason)
}
inline void SubRoleResult::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SubRoleResult.reason)
}
inline std::string* SubRoleResult::_internal_mutable_reason() {
  
  return reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SubRoleResult::release_reason() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SubRoleResult.reason)
  
  return reason_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SubRoleResult::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SubRoleResult.reason)
}

// string session_id = 3;
inline void SubRoleResult::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SubRoleResult::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.SubRoleResult.session_id)
  return _internal_session_id();
}
inline void SubRoleResult::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.SubRoleResult.session_id)
}
inline std::string* SubRoleResult::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.SubRoleResult.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& SubRoleResult::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void SubRoleResult::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SubRoleResult::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.SubRoleResult.session_id)
}
inline void SubRoleResult::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.SubRoleResult.session_id)
}
inline void SubRoleResult::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.SubRoleResult.session_id)
}
inline std::string* SubRoleResult::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SubRoleResult::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.SubRoleResult.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SubRoleResult::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.SubRoleResult.session_id)
}

// -------------------------------------------------------------------

// PubRole

// .vts.protocol.main.SimHeader header = 1;
inline bool PubRole::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool PubRole::has_header() const {
  return _internal_has_header();
}
inline const ::vts::protocol::main::SimHeader& PubRole::_internal_header() const {
  const ::vts::protocol::main::SimHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::SimHeader*>(
      &::vts::protocol::main::_SimHeader_default_instance_);
}
inline const ::vts::protocol::main::SimHeader& PubRole::header() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.PubRole.header)
  return _internal_header();
}
inline ::vts::protocol::main::SimHeader* PubRole::release_header() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.PubRole.header)
  
  ::vts::protocol::main::SimHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::SimHeader* PubRole::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::SimHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::vts::protocol::main::SimHeader* PubRole::mutable_header() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.PubRole.header)
  return _internal_mutable_header();
}
inline void PubRole::set_allocated_header(::vts::protocol::main::SimHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.PubRole.header)
}

// string session_id = 2;
inline void PubRole::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PubRole::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.PubRole.session_id)
  return _internal_session_id();
}
inline void PubRole::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.PubRole.session_id)
}
inline std::string* PubRole::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.PubRole.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& PubRole::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void PubRole::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PubRole::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.PubRole.session_id)
}
inline void PubRole::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.PubRole.session_id)
}
inline void PubRole::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.PubRole.session_id)
}
inline std::string* PubRole::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PubRole::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.PubRole.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PubRole::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.PubRole.session_id)
}

// repeated .vts.protocol.main.SingleRole s_roles = 3;
inline int PubRole::_internal_s_roles_size() const {
  return s_roles_.size();
}
inline int PubRole::s_roles_size() const {
  return _internal_s_roles_size();
}
inline ::vts::protocol::main::SingleRole* PubRole::mutable_s_roles(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.PubRole.s_roles)
  return s_roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole >*
PubRole::mutable_s_roles() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.PubRole.s_roles)
  return &s_roles_;
}
inline const ::vts::protocol::main::SingleRole& PubRole::_internal_s_roles(int index) const {
  return s_roles_.Get(index);
}
inline const ::vts::protocol::main::SingleRole& PubRole::s_roles(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.PubRole.s_roles)
  return _internal_s_roles(index);
}
inline ::vts::protocol::main::SingleRole* PubRole::_internal_add_s_roles() {
  return s_roles_.Add();
}
inline ::vts::protocol::main::SingleRole* PubRole::add_s_roles() {
  // @@protoc_insertion_point(field_add:vts.protocol.main.PubRole.s_roles)
  return _internal_add_s_roles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::SingleRole >&
PubRole::s_roles() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.PubRole.s_roles)
  return s_roles_;
}

// repeated .vts.protocol.main.CompoundRole c_roles = 4;
inline int PubRole::_internal_c_roles_size() const {
  return c_roles_.size();
}
inline int PubRole::c_roles_size() const {
  return _internal_c_roles_size();
}
inline ::vts::protocol::main::CompoundRole* PubRole::mutable_c_roles(int index) {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.PubRole.c_roles)
  return c_roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::CompoundRole >*
PubRole::mutable_c_roles() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.PubRole.c_roles)
  return &c_roles_;
}
inline const ::vts::protocol::main::CompoundRole& PubRole::_internal_c_roles(int index) const {
  return c_roles_.Get(index);
}
inline const ::vts::protocol::main::CompoundRole& PubRole::c_roles(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.PubRole.c_roles)
  return _internal_c_roles(index);
}
inline ::vts::protocol::main::CompoundRole* PubRole::_internal_add_c_roles() {
  return c_roles_.Add();
}
inline ::vts::protocol::main::CompoundRole* PubRole::add_c_roles() {
  // @@protoc_insertion_point(field_add:vts.protocol.main.PubRole.c_roles)
  return _internal_add_c_roles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vts::protocol::main::CompoundRole >&
PubRole::c_roles() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.PubRole.c_roles)
  return c_roles_;
}

// -------------------------------------------------------------------

// Notify

// .vts.protocol.main.SimHeader header = 1;
inline bool Notify::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool Notify::has_header() const {
  return _internal_has_header();
}
inline const ::vts::protocol::main::SimHeader& Notify::_internal_header() const {
  const ::vts::protocol::main::SimHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vts::protocol::main::SimHeader*>(
      &::vts::protocol::main::_SimHeader_default_instance_);
}
inline const ::vts::protocol::main::SimHeader& Notify::header() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Notify.header)
  return _internal_header();
}
inline ::vts::protocol::main::SimHeader* Notify::release_header() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Notify.header)
  
  ::vts::protocol::main::SimHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::vts::protocol::main::SimHeader* Notify::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::vts::protocol::main::SimHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  return header_;
}
inline ::vts::protocol::main::SimHeader* Notify::mutable_header() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Notify.header)
  return _internal_mutable_header();
}
inline void Notify::set_allocated_header(::vts::protocol::main::SimHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Notify.header)
}

// string session_id = 2;
inline void Notify::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Notify::session_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Notify.session_id)
  return _internal_session_id();
}
inline void Notify::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Notify.session_id)
}
inline std::string* Notify::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Notify.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& Notify::_internal_session_id() const {
  return session_id_.GetNoArena();
}
inline void Notify::_internal_set_session_id(const std::string& value) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Notify::set_session_id(std::string&& value) {
  
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.Notify.session_id)
}
inline void Notify::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.Notify.session_id)
}
inline void Notify::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.Notify.session_id)
}
inline std::string* Notify::_internal_mutable_session_id() {
  
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Notify::release_session_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Notify.session_id)
  
  return session_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Notify::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Notify.session_id)
}

// string role_id = 3;
inline void Notify::clear_role_id() {
  role_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Notify::role_id() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Notify.role_id)
  return _internal_role_id();
}
inline void Notify::set_role_id(const std::string& value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Notify.role_id)
}
inline std::string* Notify::mutable_role_id() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Notify.role_id)
  return _internal_mutable_role_id();
}
inline const std::string& Notify::_internal_role_id() const {
  return role_id_.GetNoArena();
}
inline void Notify::_internal_set_role_id(const std::string& value) {
  
  role_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Notify::set_role_id(std::string&& value) {
  
  role_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.Notify.role_id)
}
inline void Notify::set_role_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  role_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.Notify.role_id)
}
inline void Notify::set_role_id(const char* value, size_t size) {
  
  role_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.Notify.role_id)
}
inline std::string* Notify::_internal_mutable_role_id() {
  
  return role_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Notify::release_role_id() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Notify.role_id)
  
  return role_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Notify::set_allocated_role_id(std::string* role_id) {
  if (role_id != nullptr) {
    
  } else {
    
  }
  role_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), role_id);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Notify.role_id)
}

// .vts.protocol.main.NotifyType type = 4;
inline void Notify::clear_type() {
  type_ = 0;
}
inline ::vts::protocol::main::NotifyType Notify::_internal_type() const {
  return static_cast< ::vts::protocol::main::NotifyType >(type_);
}
inline ::vts::protocol::main::NotifyType Notify::type() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Notify.type)
  return _internal_type();
}
inline void Notify::_internal_set_type(::vts::protocol::main::NotifyType value) {
  
  type_ = value;
}
inline void Notify::set_type(::vts::protocol::main::NotifyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Notify.type)
}

// string s_param = 5;
inline void Notify::clear_s_param() {
  s_param_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Notify::s_param() const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Notify.s_param)
  return _internal_s_param();
}
inline void Notify::set_s_param(const std::string& value) {
  _internal_set_s_param(value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Notify.s_param)
}
inline std::string* Notify::mutable_s_param() {
  // @@protoc_insertion_point(field_mutable:vts.protocol.main.Notify.s_param)
  return _internal_mutable_s_param();
}
inline const std::string& Notify::_internal_s_param() const {
  return s_param_.GetNoArena();
}
inline void Notify::_internal_set_s_param(const std::string& value) {
  
  s_param_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Notify::set_s_param(std::string&& value) {
  
  s_param_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vts.protocol.main.Notify.s_param)
}
inline void Notify::set_s_param(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  s_param_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vts.protocol.main.Notify.s_param)
}
inline void Notify::set_s_param(const char* value, size_t size) {
  
  s_param_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vts.protocol.main.Notify.s_param)
}
inline std::string* Notify::_internal_mutable_s_param() {
  
  return s_param_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Notify::release_s_param() {
  // @@protoc_insertion_point(field_release:vts.protocol.main.Notify.s_param)
  
  return s_param_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Notify::set_allocated_s_param(std::string* s_param) {
  if (s_param != nullptr) {
    
  } else {
    
  }
  s_param_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_param);
  // @@protoc_insertion_point(field_set_allocated:vts.protocol.main.Notify.s_param)
}

// repeated double d_param = 6;
inline int Notify::_internal_d_param_size() const {
  return d_param_.size();
}
inline int Notify::d_param_size() const {
  return _internal_d_param_size();
}
inline void Notify::clear_d_param() {
  d_param_.Clear();
}
inline double Notify::_internal_d_param(int index) const {
  return d_param_.Get(index);
}
inline double Notify::d_param(int index) const {
  // @@protoc_insertion_point(field_get:vts.protocol.main.Notify.d_param)
  return _internal_d_param(index);
}
inline void Notify::set_d_param(int index, double value) {
  d_param_.Set(index, value);
  // @@protoc_insertion_point(field_set:vts.protocol.main.Notify.d_param)
}
inline void Notify::_internal_add_d_param(double value) {
  d_param_.Add(value);
}
inline void Notify::add_d_param(double value) {
  _internal_add_d_param(value);
  // @@protoc_insertion_point(field_add:vts.protocol.main.Notify.d_param)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Notify::_internal_d_param() const {
  return d_param_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Notify::d_param() const {
  // @@protoc_insertion_point(field_list:vts.protocol.main.Notify.d_param)
  return _internal_d_param();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Notify::_internal_mutable_d_param() {
  return &d_param_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Notify::mutable_d_param() {
  // @@protoc_insertion_point(field_mutable_list:vts.protocol.main.Notify.d_param)
  return _internal_mutable_d_param();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace main
}  // namespace protocol
}  // namespace vts

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
