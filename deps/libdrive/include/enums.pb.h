// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_enums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_enums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_enums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_enums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_enums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace vts {
namespace protocol {
namespace main {

enum MsgType : int {
  MT_INVALID = 0,
  MT_REGISTER = 1,
  MT_LOGIN = 2,
  MT_LOGOUT = 3,
  MT_ACCOUNT_RESULT = 4,
  MT_TRY_TEST = 5,
  MT_TRY_REPLAY = 6,
  MT_TRY_RESULT = 7,
  MT_SESSIONINFO = 8,
  MT_FETCH_SESSION_TEST_RESULT = 9,
  MT_SESSION_TEST_RESULT = 10,
  MT_DEBUG_SESSION = 11,
  MT_DEBUG_SESSION_RESULT = 12,
  MT_ACTOR_PREPARE = 13,
  MT_ACTOR_PREPARE_RESULT = 14,
  MT_QUERY_ARCHIVEINFO = 15,
  MT_ARCHIVEINFO_LIST = 16,
  MT_SUBROLE = 17,
  MT_SUBROLE_RESULT = 18,
  MT_PUBROLE = 19,
  MT_NOTIFY = 20,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = MT_INVALID;
constexpr MsgType MsgType_MAX = MT_NOTIFY;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    const std::string& name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum RoleContainerType : int {
  RCT_INVALID = 0,
  RCT_CONSOLE = 1,
  RCT_TESTEE = 2,
  RCT_OBSERVER = 3,
  RCT_DRIVE_SIMULATOR = 4,
  RCT_PARTICIPANT_VEHICLE = 5,
  RCT_PARTICIPANT_UNMOTORIZED_VEHICLE = 6,
  RCT_PARTICIPANT_HUMAN = 7,
  RCT_PARTICIPANT_ANIMAL = 8,
  RCT_PARTICIPANT_ENV = 9,
  RCT_EVALUATION = 10,
  RoleContainerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoleContainerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoleContainerType_IsValid(int value);
constexpr RoleContainerType RoleContainerType_MIN = RCT_INVALID;
constexpr RoleContainerType RoleContainerType_MAX = RCT_EVALUATION;
constexpr int RoleContainerType_ARRAYSIZE = RoleContainerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoleContainerType_descriptor();
template<typename T>
inline const std::string& RoleContainerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleContainerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleContainerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoleContainerType_descriptor(), enum_t_value);
}
inline bool RoleContainerType_Parse(
    const std::string& name, RoleContainerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoleContainerType>(
    RoleContainerType_descriptor(), name, value);
}
enum AccountOPType : int {
  AOT_INVALID = 0,
  AOT_REGISTER = 1,
  AOT_LOGIN = 2,
  AOT_LOGOUT = 3,
  AccountOPType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AccountOPType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AccountOPType_IsValid(int value);
constexpr AccountOPType AccountOPType_MIN = AOT_INVALID;
constexpr AccountOPType AccountOPType_MAX = AOT_LOGOUT;
constexpr int AccountOPType_ARRAYSIZE = AccountOPType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccountOPType_descriptor();
template<typename T>
inline const std::string& AccountOPType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccountOPType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccountOPType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccountOPType_descriptor(), enum_t_value);
}
inline bool AccountOPType_Parse(
    const std::string& name, AccountOPType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountOPType>(
    AccountOPType_descriptor(), name, value);
}
enum NotifyType : int {
  NT_INVALID = 0,
  NT_START_TEST = 1,
  NT_ABORT_TEST = 2,
  NT_PAUSE_TEST = 3,
  NT_RESUME_TEST = 4,
  NT_STEP_TEST = 5,
  NT_FINISH_TEST = 6,
  NT_COLLIDE_ROLE = 7,
  NT_DESTROY_ROLE = 8,
  NT_CROSS_SOLID_LINE = 9,
  NT_CROSS_DOTTED_LINE = 10,
  NT_EXCEED_SPEED = 11,
  NT_DRIVE_REVERSED = 12,
  NT_DEVIATE_DRIVING_AREA = 13,
  NT_DRIVE_RED_LIGHT = 14,
  NT_DRIVE_LOW_SPEED = 15,
  NT_WRONG_TURN_SIGNAL = 16,
  NT_SCORE_CHANGE = 17,
  NT_ARRIVED_ROLE = 18,
  NT_ROLLED = 19,
  NT_RISK_COLLIDE = 20,
  NotifyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NotifyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NotifyType_IsValid(int value);
constexpr NotifyType NotifyType_MIN = NT_INVALID;
constexpr NotifyType NotifyType_MAX = NT_RISK_COLLIDE;
constexpr int NotifyType_ARRAYSIZE = NotifyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NotifyType_descriptor();
template<typename T>
inline const std::string& NotifyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NotifyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NotifyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NotifyType_descriptor(), enum_t_value);
}
inline bool NotifyType_Parse(
    const std::string& name, NotifyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NotifyType>(
    NotifyType_descriptor(), name, value);
}
enum ArchiveType : int {
  AT_INVALID = 0,
  AT_TEST_CASE = 1,
  AT_MAP = 2,
  AT_TEST_RESULT = 3,
  AT_TEST_RECORD = 4,
  ArchiveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ArchiveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ArchiveType_IsValid(int value);
constexpr ArchiveType ArchiveType_MIN = AT_INVALID;
constexpr ArchiveType ArchiveType_MAX = AT_TEST_RECORD;
constexpr int ArchiveType_ARRAYSIZE = ArchiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArchiveType_descriptor();
template<typename T>
inline const std::string& ArchiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArchiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArchiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArchiveType_descriptor(), enum_t_value);
}
inline bool ArchiveType_Parse(
    const std::string& name, ArchiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArchiveType>(
    ArchiveType_descriptor(), name, value);
}
enum RoleType : int {
  RT_INVALID = 0,
  RT_TREE = 1,
  RT_GRASS = 2,
  RT_SHRUB = 3,
  RT_LAMP = 4,
  RT_OUTDOOR = 5,
  RT_TRASHBIN = 6,
  RT_HYDRANT = 7,
  RT_DISTRIBUTIONBOX = 8,
  RT_PAVEMENT = 9,
  RT_MAILBOX = 10,
  RT_UTILITYPOLE = 11,
  RT_UTILITYTOWER = 12,
  RT_BUILDING = 13,
  RT_WALL = 14,
  RT_STATICSIGN = 15,
  RT_DYNAMICSIGN = 16,
  RT_TRAFFICLIGHT = 17,
  RT_DISPLAY = 18,
  RT_BARRIERGATE = 19,
  RT_BUMP = 20,
  RT_CONE = 21,
  RT_BARRIER = 22,
  RT_CAMERA = 23,
  RT_VELOCIMETER = 24,
  RT_FLASH = 25,
  RT_ROCK = 26,
  RT_HOLE = 27,
  RT_GULLYHOLE = 28,
  RT_MANHOLE = 29,
  RT_COIL = 30,
  RT_PUDDLE = 31,
  RT_CRACK = 32,
  RT_SWELL = 33,
  RT_TRASH = 34,
  RT_LEAVES = 35,
  RT_OTHER = 36,
  RT_MOTORVEHICLE = 37,
  RT_EMERGENCY = 38,
  RT_TRAIN = 39,
  RT_COMBINATIONVEHICLE = 40,
  RT_NONMOTORVEHICLE = 41,
  RT_PEDESTRIAN = 42,
  RT_ANIMAL = 43,
  RT_CLOUD = 44,
  RT_RAIN = 45,
  RoleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoleType_IsValid(int value);
constexpr RoleType RoleType_MIN = RT_INVALID;
constexpr RoleType RoleType_MAX = RT_RAIN;
constexpr int RoleType_ARRAYSIZE = RoleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoleType_descriptor();
template<typename T>
inline const std::string& RoleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoleType_descriptor(), enum_t_value);
}
inline bool RoleType_Parse(
    const std::string& name, RoleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoleType>(
    RoleType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace main
}  // namespace protocol
}  // namespace vts

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vts::protocol::main::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vts::protocol::main::MsgType>() {
  return ::vts::protocol::main::MsgType_descriptor();
}
template <> struct is_proto_enum< ::vts::protocol::main::RoleContainerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vts::protocol::main::RoleContainerType>() {
  return ::vts::protocol::main::RoleContainerType_descriptor();
}
template <> struct is_proto_enum< ::vts::protocol::main::AccountOPType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vts::protocol::main::AccountOPType>() {
  return ::vts::protocol::main::AccountOPType_descriptor();
}
template <> struct is_proto_enum< ::vts::protocol::main::NotifyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vts::protocol::main::NotifyType>() {
  return ::vts::protocol::main::NotifyType_descriptor();
}
template <> struct is_proto_enum< ::vts::protocol::main::ArchiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vts::protocol::main::ArchiveType>() {
  return ::vts::protocol::main::ArchiveType_descriptor();
}
template <> struct is_proto_enum< ::vts::protocol::main::RoleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vts::protocol::main::RoleType>() {
  return ::vts::protocol::main::RoleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_enums_2eproto
